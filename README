Smarty 3.0 Alpha 1 : Proof of Concept

Author: Monte Ohrt <monte at ohrt dot com >

This code is a proof of concept as a basis of the Smarty 3 template engine.
It is by no means complete, it is only a shell of an infrastructure to build
the 3.0 codebase upon. What I need is feedback before continuing! Now is the
time to make decisions that will affect the engine fundamentals.

So, a quick intro to the thinking behind this alpha code.

If you take a look at the file structure, you should see this:

index.php
/libs/
  Smarty.class.php
/plugins/
  function.mailto.php
  internal.compiler.php
  internal.displayphp.php
  internal.displaytpl.php
  internal.pluginbase.php
  modifier.escape.php
/templates/
  index.tpl
  index_view.php
  

If you execute the index.php file, you will see an example of using Smarty to
display a couple of template files. Since this alpha code is a shell, the
compiler doesn't actually compile the tags yet. But the framework is in place
to make it happen.

The way to use Smarty 3 should look extremely familiar:

require('Smarty.class.php');
$smarty = new Smarty;
$smarty->assign('foo','bar');
$smarty->display('index.tpl');


However, Smarty works completely different on the inside. The majority of
the Smarty system now lies in the plugin directory. The core Smarty.class.php
class is extremely slim. The fundamental idea is for Smarty to lazy-load all
requirements (objects) on an as-needed basis. The PHP5 __autoload() feature
is used to automate this task.

FEATURE 1: AUTOLOAD

The moment you fire up a Smarty object:

require('Smarty.class.php');
$smarty = new Smarty;

The engine is ready to go. Now you can load any Smarty plugin from anywhere in
PHP like so:

$plugin = new Smarty_Foo_Bar;

If the Smarty_Foo_Bar class does not exist, Smarty will automagically find the
proper plugin file and load it, and instantiate it. In the above example, the
file is called foo.bar.php in the plugins directory. So long as the plugin file
name and class name follow the naming conventions, everything falls into place.

Now you can see how things start happening in the core of Smarty. Does a
template need compiling? Ok, let's do it:

$compiler = new Smarty_Internal_Compiler;
$compiler->compile($tpl_filepath,$compiled_filepath);

Do we need to load an output filter?

$filter = new Smarty_Outputfilter_Whitespace;

Do you want to use a template function/modifier?

$mailto = new Smarty_Function_Mailto;
echo $mailto->execute(array('address'=>'me@example.com'));

As you can see, __autoload() makes plugins a snap from anywhere in PHP.

FEATURE 2: $smarty object singleton

Do you need a reference to the Smarty object instance? No problem:

$smarty = Smarty::instance();

You can do this from anywhere in your PHP code, and get the instance. You can
be buried in a php function, in a class method, or wherever. The $smarty
object is quickly obtainable.

Since all plugins are now classes (did I mention that yet?), They all extend
Smarty_Internal_PluginBase, which makes $this->smarty a reference to the Smarty
object instance. This is available to all plugins.

FEATURE 3: PHP templates

Smarty's fundamental design goals are meant to separate business logic from
presentation logic. Since Smarty 2.0 templates work on a tag-based syntax, this
has usually equated to "Don't put PHP in the templates." But, these two
philosophies are completely separate. You could conceivably use plain PHP
scripts as your templates and still maintain business logic separation.
Even though PHP is used in the template, it is still just presentation logic.

So now you have your choice: Use templates that are just plain PHP code, or
use the compiled templates using the familiar {$foo} tag syntax. Whatever is
more important to you (PHP or tags/security/etc), make your own choice. Just
remember, PHP templates require YOU to keep the separation yourself. It won't
be as obvious.

If you want to use a PHP template, just name it with the .php extension:

$smarty->display('mytemplate.php');

Smarty will not compile it, it will just get executed as PHP. You have full
reign of PHP in your template code. Your assigned template vars are available
simply as <?=$foo?> <?=$bar?>, etc. (BTW, extract() doesn't carry the burden you
may initially think.)

If you want to use a traditional compiled template, name it with any other
extention. Most use the default .tpl extention:

$smarty->display('mytemplate.tpl');

You will notice in the sample code the template tags do not get compiled. That
is because I have not written the compiler yet. Do we give Smarty 3 a new
syntax? Do we make a Smarty 2 compatability layer? Anything is possible.


Ok that pretty much wraps up the principles behind the alpha code. Some
questions that are lingering:

1) Do we make a separate plugin directory for internal.* plugins? This is
   just a code organization decision.
2) Is this code structure fundamentally sound? This is where I can use
   help from other OOP gurus :) Obviously we are leveraging some
   PHP-specific stuff such as __autoload(), but there may be places where
   extending core classes or implementing well-known interfaces will do
   some good for the future.
   
Please send your thoughts to the forums. I will be creating a place
there specifically for this development discussion.

Monte
