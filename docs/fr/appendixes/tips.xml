<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision$ -->
<!-- EN-Revision: 1.4 Maintainer: didou Status: ready -->
<chapter id="tips">
 <title>Trucs et astuces</title>
 <para></para>
 <sect1 id="tips.blank.var.handling">
  <title>Gestion des variables non-assignées</title>
  <para>
   Peut-être voudrez-vous des fois afficher une valeur par 
   défaut pour une variable qui n'a pas été assignée, comme
   pour afficher "&amp;nbsp;" afin que les couleurs de fond
   des tableaux fonctionnent. Beaucoup utiliseraient une 
   instruction {if} pour gérer cela, mais il existe un moyen 
   plus facile dans Smarty : l'utilisation du modificateur 
   de variable <emphasis>default</emphasis>.
  </para>      
  <example>
   <title>afficher &amp;nbsp; quand une variable est vide</title>
   <programlisting>
<![CDATA[
{* la méthode pas adaptée *}

{if $title eq ""}
   &nbsp;
{else}
   {$title}
{/if}


{* la bonne méthode *}

{$title|default:"&nbsp;"}
]]>
   </programlisting>
  </example>
 </sect1>

    <sect1 id="tips.default.var.handling">
      <title>Gestion des variables par défaut</title>
      <para>
      Si une variable est utilisée fréquemment dans vos templates,
      lui appliquer le modificateur par défaut peut être un peu fastidieux.
      Vous pouvez remédier à cela en lui assignant une valeur par défaut
      avec la fonction <link linkend="language.function.assign">assign</link>.
      </para>
<example>
<title>assigner une valeur par défaut à une variable de template</title>
<programlisting>
{* faites cela qq part en haut de votre template *}
{assign var="title" value=$title|default:"no title"}

{* si $title est vide, il contiendra alors no "no title" *}
{$title}</programlisting>
</example>
   </sect1>
    <sect1 id="tips.passing.vars">
      <title>Passage du titre à un template d'en-tête</title>
      <para>
      Quand la majorité de vos templates utilisent les mêmes en-tête et pied-de-page,
      il est d'usage de les mettre dans leurs propres templates et de les inclure.
      Mais comment faire si l'en-tête doit avoir un titre différent, selon la page
      d'où on vient ? Vous pouvez passer le titre à l'en-tête quand il est inclus.
      </para>
<example>
<title>passer le titre au template d'en-tête</title>
<programlisting>

mainpage.tpl
------------

{include file="header.tpl" title="Main Page"}
{* le corps du template va ici *}
{include file="footer.tpl"}


archives.tpl
------------

{config_load file="archive_page.conf"}
{include file="header.tpl" title=#archivePageTitle#}
{* le corps du template va ici *}
{include file="footer.tpl"}


header.tpl
----------
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;TITLE&gt;{$title|default:"BC News"}&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;


footer.tpl
----------
&lt;/BODY&gt;
&lt;/HTML&gt;</programlisting>
</example>
   <para>
   Quand la page principale est conçue, le titre "Main page" est passé à header.tpl
   et sera donc utilisé pour le titre. Quand la page d'archive est conçue,
   le titre sera "Archives". Notez que dans l'exemple des archives, on utilise
   le fichier archives_page.conf plutôt que des variables codées en dur.
   Remarquez aussi que "BC News" est affichée si la variable $title
   n'est pas définie, grâce au modificateur de variable <emphasis>default</emphasis>.
   </para>   
   </sect1>
    <sect1 id="tips.dates">
       <title>Dates</title>
       <para>
       De façon générale, essayez de toujours passer les dates à Smarty
       sous forme de timestamp. Cela permet aux designers de templates d'utiliser
       <link linkend="language.modifier.date.format">date_format</link>
       pour avoir un contrôle total sur le formatage des dates et de comparer
       facilement les dates entre elles.
       </para>
       <para>
       NOTE : à partir Smarty 1.4.0, vous pouvez passer les dates à Smarty
       sous la forme de timestamps Unix ou MySQL, ou tout autre format de dates
       que comprend strtotime().
       </para>
<example>
<title>utilisation de date_format</title>
<programlisting>
{$startDate|date_format}

OUTPUT:

Jan 4, 2001


{$startDate|date_format:"%Y/%m/%d"}

OUTPUT:

2001/01/04


{if $date1 &lt; $date2}
   ...
{/if}</programlisting>
</example>
      <para>
      En utilisant la fonction {html_select_date} dans un template, le programmeur
      veut en général convertir le résultat d'un formulaire en un timestamp.
      Voici une fonction qui devrait vous être utile.
      </para>
<example>
<title>conversion des éléments date d'un formulaire en timestamp</title>
<programlisting>
// cela suppose que vos éléments de formulaire soient nommés
// startDate_Day, startDate_Month, startDate_Year

$startDate = makeTimeStamp($startDate_Year,$startDate_Month,$startDate_Day);

function makeTimeStamp($year="",$month="",$day="")
{
   if(empty($year))
      $year = strftime("%Y");
   if(empty($month))
      $month = strftime("%m");
   if(empty($day))
      $day = strftime("%d");

   return mktime(0,0,0,$month,$day,$year);
}</programlisting>
</example>
   </sect1>
    <sect1 id="tips.wap">
      <title>WAP/WML</title>
      <para>
      Les templates WAP/WML nécessitent un en-tête "Content-Type" qui doit être
      passé avec le template. Le moyen le plus facile de faire cela est d'écrire
      une fonction utilisateur qui écrit l'en-tête. Si vous utilisez le cache,
      cela ne fonctionnera pas. Nous utiliserons donc une balise d'insertion
    (rappelez-vous que les balises d'insertion ne sont pas mises en cache !).
    Assurez-vous qu'aucune sortie
      rien n'est transmise au navigateur avant l'appel du template, sans quoi
    la modification de l'en-tête échouera.
      </para>
<example>
<title>utilisation d'insert pour écrire un en-tête Content-Type WML</title>
<programlisting>
// assurez-vous que Apache est configuré pour les extensions .wml !
// mettez cette fonction qq part dans votre applications
// ou dans Smarty.addons.php
function insert_header() {
    // cette fonction attend un argument $content
    extract(func_get_arg(0));
    if(empty($content))
        return;
    header($content);
    return;
}

// votre template Smarty DOIT commencer avec la balise d'insertion

&lt;?xml version="1.0"?&gt;  
&lt;!DOCTYPE wml PUBLIC "-//WAPFORUM//DTD WML 1.1//EN" "http://www.wapforum.org/DTD/wml_1.1.xml"&gt; 

&lt;!-- begin new wml deck --&gt; 
&lt;wml&gt; 
&lt;!-- begin first card --&gt; 
&lt;card&gt; 
&lt;do type="accept"&gt; 
&lt;go href="#two"/&gt; 
&lt;/do&gt;  
&lt;p&gt; 
Welcome to WAP with Smarty!
Press OK to continue...  
&lt;/p&gt; 
&lt;/card&gt;  
&lt;!-- begin second card --&gt; 
&lt;card id="two"&gt;  
&lt;p&gt; 
Pretty easy isn't it?
&lt;/p&gt; 
&lt;/card&gt; 
&lt;/wml&gt;</programlisting>
</example>
   </sect1>
   <sect1 id="tips.componentized.templates">
      <title>Templates composants</title>
      <para>
      Cette astuce tient plus du hack qu'autre chose mais n'en demeure pas
      moins une idée plutôt chouette. Utilisez-la à vos propres risques. ;-)
      </para>
      <para>
      Traditionnellemnt, la programmation avec des templates dans les applications
      se déroule de la façon suivante : d'abord vous récupérez vos variables
      dans l'application PHP (peut-être avec des requêtes en base de données), puis
      vous instanciez votre objet Smarty, assignez les variables et affichez le
      template. Disons par exemple que nous avons un téléscripteur dans
      notre template. Nous récupérerions les données dans notre application,
      puis les assignerions ensuite pour les afficher. Mais ne serait-ce pas
      mieux de pouvoir ajouter ce téléscripteur à n'importe quelle application
      en incluant directement le template sans avoir à se soucier de la récupération
      des données.
      </para>
      <para>
      Vous pouvez intégrer du PHP dans vos templates avec les balises
      {php}{/php}. Avec cette méthode, vous pouvez inclure des templates complets,
    dans la mesure où ils récupèrent leurs propres données pour les assigner
    à leurs propres variables. Avec le traitement intégré
      de cette façon, vous pouvez garder le template et le traitement ensemble.
      Ainsi, on ne se soucie plus d'où vient le contenu du template,
      tout vient comme un seul et unique composant.
      </para>
<example>
<title>template composant</title>
<programlisting>
{* Smarty *}

{php}

   // notre fonction pour récupérer les données
   function fetch_ticker($symbol,&amp;$ticker_name,&amp;$ticker_price) {
      // du traitement qui récupère $ticker_name
      // $ticker_price
   }

   // appelle la fonction
   fetch_ticker("YHOO",$ticker_name,$ticker_price);
   
   // assigne les variables
  $this->assign("ticker_name",$ticker_name);
  $this->assign("ticker_price",$ticker_price);

{/php}

Stock Name: {$ticker_name} Stock Price: {$ticker_price}</programlisting>
</example>
        <para>
        A partir de Smarty 1.5.0, il y a même un moyen plus propre. Vous
        pouvez inclure du PHP dans votre template avec la balise {include_php ...}.
        De cette façon, vous pouvez garder séparée la logique applicative
        de la logique de présentation. Reportez-vous à la fonction <link
        linkend="language.function.include.php">include_php</link> pour plus
         d'informations.
        </para>
<example>
<title>template composant avec include_php</title>
<programlisting>
load_ticker.php
---------------

&lt;?php
   // notre fonction pour récupérer les données
   function fetch_ticker($symbol,&amp;$ticker_name,&amp;$ticker_price) {
      // put logic here that fetches $ticker_name
      // and $ticker_price from some resource
   }

   // appelle la fonction
   fetch_ticker("YHOO",$ticker_name,$ticker_price);
   
   // assigne les variables
   $this->assign("ticker_name",$ticker_name);
   $this->assign("ticker_price",$ticker_price);
?&gt;


index.tpl
---------

{* Smarty *}

{include_php file="load_ticker.php"}

Stock Name: {$ticker_name} Stock Price: {$ticker_price}</programlisting>
</example>
   </sect1>
   <sect1 id="tips.obfuscating.email">
      <title>Dissimuler les adresses email</title>
      <para>
      Vous-êtes vous déjà demandé pourquoi vos adresses emails sont sur autant
      de mailing listes de spam ? Une façon pour les spammers de récupérer les
      adresses est de parcourir les pages Web. Voici une façon de remédier
      à ce problème : mettre votre adresse email dans du Javascript brouillé
      au milieu de votre source HTML, sans que cela ne gêne l'affichage sur le
      navigateur Web. Cela est fait grâce au plugin mailto.
      </para>
<example>
<title>exemple de dissimulation d'une adresse email</title>
<programlisting>

index.tpl
---------

Send inquiries to
{mailto address=$EmailAddress encode="javascript" subject="Hello"}

</programlisting>
</example>
   <note>
   <title>Note technique</title>
   <para>
   Cette méthode n'est pas infaillible. Un spammer peut programmer son
   collecteur d'email pour passer outre cette astuce, mais c'est cependant
   peu probable.
   </para>
   </note>
   </sect1>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
