<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision$ -->
 <chapter id="plugins">
  <title>Etendre Smarty avec des plugins</title>
  <para>
  La version 2.0 a introduit l'architecture de plugin qui est
  utilisée pour pratiquement toute les fonctionnalités
  personnalisables de Smarty. Ceci comprend : 
  <itemizedlist spacing="compact">
    <listitem><simpara>les fonctions</simpara></listitem>
    <listitem><simpara>les modificateurs</simpara></listitem>
    <listitem><simpara>les fonctions de blocs</simpara></listitem>
    <listitem><simpara>les fonctions de compilation</simpara></listitem>
    <listitem><simpara>les filtres de pré-compilation</simpara></listitem>
    <listitem><simpara>les filtres de post-compilation</simpara></listitem>
    <listitem><simpara>les filtres de sorties</simpara></listitem>
    <listitem><simpara>les ressources</simpara></listitem>
    <listitem><simpara>les insertions</simpara></listitem>
  </itemizedlist>
  A part pour les ressources, la compatibilité avec les anciennes
  fatons d'enregistrer les fonctions de gestion avec l'API register_
  est conservée. Si vous n'avez pas utilisé cette API et que vous avez
  a la place directement modifié les variables de classes 
  <literal>$custom_funcs</literal>, <literal>$custom_mods</literal> et
  d'autres, vous devez alors modifier vos scripts pour utiliser
  l'API ou convertir vos fonctionnalités personnalisées en plugins.
  </para>
     
  <sect1>
   <title>Comment fonctionnent les plugins</title>
   <para>
   Les plugins sont toujours chargés a la demande. Seuls les modificateurs
   de variables, les ressources, etc invoqués dans les scripts de templates
   seront chargés. De plus, chaque plugin n'est chargé qu'une fois, et ce
   même si vous avez plusieurs instances de Smarty qui tournent dans
   la même requête.
   </para>
   <para>
   Les filtres de post/pré-compilation et les filtres de sortie sont des cas
   un peu spéciaux.
   Comme ils ne sont pas mentionnés dans les templates, ils doivent être déclarés
   ou chargés explicitement via les fonctions de l'API avant que le template
   ne soit exécuté. L'ordre dans lequel les filtres multiples d'un même type
   sont exécutés dépend de l'ordre dans lequel ils sont enregistrés ou chargés.
   </para>
   <para>
   Il n'existe qu'un seul répertoire de plugin (pour des raisons de performances).
   Pour installer un plugin, copiez-le simplement dans le répertoire et Smarty
   l'utilisera automatiquement.
   </para>   
  </sect1>

   <sect1 id="plugins.naming.conventions">
    <title>Conventions de nommage</title>
    <para>
    Les fichiers et les fonctions de plugins doivent suivre une convention
    de nommage trés spécifique pour être localisés par Smarty.
    </para>
    <para>
    Les fichiers de plugins doivent être nommés de la faton suivante :
    <blockquote>
      <para>
       <filename>
        <replaceable>type</replaceable>.<replaceable>nom</replaceable>.php
       </filename>
      </para>
     </blockquote>
    </para>
    <para>
    Oú <literal>type</literal> est l'une des valeurs suivantes :
    <itemizedlist spacing="compact">
      <listitem><simpara>function</simpara></listitem>
      <listitem><simpara>modifier</simpara></listitem>
      <listitem><simpara>block</simpara></listitem>
      <listitem><simpara>compiler</simpara></listitem>
      <listitem><simpara>prefilter</simpara></listitem>
      <listitem><simpara>postfilter</simpara></listitem>
      <listitem><simpara>outputfilter</simpara></listitem>
      <listitem><simpara>resource</simpara></listitem>
      <listitem><simpara>insert</simpara></listitem>
     </itemizedlist>
    </para>
    <para>
    Et <literal>nom</literal> doit être un identifiant valide (lettres, nombres
    et underscore seulement).
    </para>
    <para>
    Quelques exemples : <literal>function.html_select_date.php</literal>,
    <literal>resource.db.php</literal>,
    <literal>modifier.spacify.php</literal>.
    </para>
    <para>
    Les fonctions de plugins dans les fichiers de plugins doivent être
    nommées de la faton suivante :
    <blockquote>
      <para>
       <function>smarty_<replaceable>type</replaceable>_<replaceable>nom</replaceable></function>
      </para>
     </blockquote> 
    </para>
    <para>
    Les significations de <literal>type</literal> et de <literal>nom</literal> sont les mêmes
    que précédemment.
    </para>
    <para>
    Smarty donnera des messages d'erreur approprié si le fichier de plugin
    n'est pas trouvé, ou si le fichier ou la fonction de plugin ne sont
    pas nommés correctement.
    </para>
    </sect1>

   <sect1 id="plugins.writing">
    <title>Ecrire des plugins</title>
    <para>
    Les plugins peuvent être soit chargés automatiquement par Smarty
    depuis le systéme de fichier, soit être déclarés
    pendant l'exécution via une fonction register_* de l'API. Ils peuvent
    aussi être désalloués en utilisant une fonction unregister_* de
    l'API.
    </para>
    <para>
    Pour les plugins qui ne sont pas enregistrés pendant l'exécution, le nom
    des fonctions n'ont pas a suivre la convention de nommage.
    </para>
    <para>
    Si certaines fonctionnalités d'un plugin dépendent d'un autre plugin
    (comme c'est le cas de certains plugins accompagnant Smarty), alors la maniére appropriée
    de charger le plugin est la suivante :
    </para>
    
    <programlisting>
require_once SMARTY_DIR . 'plugins/function.html_options.php';</programlisting>
    <para>
    Une régle générale est que chaque objet Smarty est toujours passé au plugin
    en tant que dernier paramétre (a part pour les modificateurs).
    </para>    
   </sect1>

   <sect1 id="plugins.functions"><title>Les fonctions de templates</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>void <function>smarty_function_<replaceable>name</replaceable></function></funcdef>
      <paramdef>array <parameter>$params</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
    Tous les attributs passés aux fonctions de template a partir du template
    sont contenus dans le tableau associatif <parameter>$params</parameter>.
    Vous pouvez accéder a ces valeurs soit directement, par exemple
    <varname>$params['start']</varname>, soit en utilisant
    <varname>extract($params)</varname> pour les importer dans la table
    des symboles.
    </para>
    <para>
    Le retour de la fonction sera substituée a la balise de fonction
    du template (fonction <function>fetch</function> par exemple). Sinon,
    la fonction peut simplement accomplir une autre tGche sans sortie
    (la fonction <function>assign</function> par exemple)
    </para>
    <para>
    Si la fonction a besoin d'assigner des variables aux templates ou d'utiliser
    d'autres fonctionnalités fournies par Smarty, elle peut recevoir un
    objet <parameter>$smarty</parameter> pour cela.
    </para>
    <para>
     Référez-vous aussi a :
     <link linkend="api.register.function">register_function()</link>,
     <link linkend="api.unregister.function">unregister_function()</link>.
    </para>
    <para>
     <example>
      <title>fonction de plugin avec sortie</title>
      <programlisting>
&lt;?php
/*
 * Smarty plugin
 * -------------------------------------------------------------
 * Fichier :  function.eightball.php
 * Type :     fonction
 * Nom :      eightball
 * Rôle :     renvoie une phrase magique au hasard
 * -------------------------------------------------------------
 */
function smarty_function_eightball($params, &amp;$smarty)
{
    $answers = array('Yes',
                     'No',
                     'No way',
                     'Outlook not so good',
                     'Ask again soon',
                     'Maybe in your reality');

    $result = array_rand($answers);
    return $answers[$result];
}
?&gt;</programlisting>
     </example>
    </para>
    <para>
     peut être utilisée dans le template de la faton suivante :
    </para>
    <programlisting>
Question: Will we ever have time travel?
Answer: {eightball}.</programlisting>
    <para>
     <example>
      <title>fonction de plugin sans sortie</title>
      <programlisting>
&lt;?php
/*
 * Smarty plugin
 * -------------------------------------------------------------
 * Fichier :  function.assign.php
 * Type :     fonction
 * Nom :      assign
 * Purpose :  assigne une valeur a une variable de template
 * -------------------------------------------------------------
 */
function smarty_function_assign($params, &amp;$smarty)
{
    extract($params);

    if (empty($var)) {
        $smarty->trigger_error("assign: missing 'var' parameter");
        return;
    }

    if (!in_array('value', array_keys($params))) {
        $smarty->trigger_error("assign: missing 'value' parameter");
        return;
    }

    $smarty->assign($var, $value);
}
?&gt;</programlisting>
     </example>
    </para>
   </sect1>

   <sect1 id="plugins.modifiers"><title>Modificateurs</title>
    <para>
    Les modificateurs sont des petites fonctions appliquées a une variable
    de template avant qu'elle ne soit affichée ou utilisée dans un autre contexte.
    Les modificateurs peuvent être chaenés entre eux.
    </para>
    <funcsynopsis>
     <funcprototype>
      <funcdef>mixed <function>smarty_modifier_<replaceable>name</replaceable></function></funcdef>
      <paramdef>mixed <parameter>$value</parameter></paramdef>
      <paramdef>[mixed <parameter>$param1</parameter>, ...]</paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
    Le premier paramétre passé au modificateur est la valeur
    sur laquelle le modificateur est supposé opérer. Les autres paramétres
    peuvent être optionnels, dépendant de quel genre d'opération doit être
    effectué.
    </para>
    <para>
    Le modificateur doit retourner le résultat de son exécution.
    </para>
    <para>
    Regardez aussi
    <link linkend="api.register.modifier">register_modifier()</link>,
     <link linkend="api.unregister.modifier">unregister_modifier()</link>.
    </para>
    <example>
     <title>plugin modificateur simple</title>
     <para>
     Ce plugin est un alias d'une fonction PHP. Il n'a aucun paramétre
     supplémentaires.
     </para>
     <programlisting>
&lt;?php
/*
 * Smarty plugin
 * -------------------------------------------------------------
 * Fichier :  modifier.capitalize.php
 * Type :     modificateur
 * Name :     capitalize
 * Rôle :     met une majuscule aux mots d'une phrase
 * -------------------------------------------------------------
 */
function smarty_modifier_capitalize($string)
{
    return ucwords($string);
}
?&gt;</programlisting>
    </example>
    <para></para>
    <example>
     <title>un plugin modificateur un peu plus complexe</title>
     <programlisting>
&lt;?php
/*
 * Smarty plugin
 * -------------------------------------------------------------
 * Fichier :  modifier.truncate.php
 * Type :     modificateur
 * Name :     truncate
 * Rôle :     Tronque une chaene a une certaine longueur si
 *            nécessaire, la coupe optionnellement au milieu
 *            d'un mot et ajoute la chaene $etc 
 * -------------------------------------------------------------
 */
function smarty_modifier_truncate($string, $length = 80, $etc = '...',
                                  $break_words = false)
{
    if ($length == 0)
        return '';

    if (strlen($string) > $length) {
        $length -= strlen($etc);
        $fragment = substr($string, 0, $length+1);
        if ($break_words)
            $fragment = substr($fragment, 0, -1);
        else
            $fragment = preg_replace('/\s+(\S+)?$/', '', $fragment);
        return $fragment.$etc;
    } else
        return $string;
}
?&gt;</programlisting>
    </example>
   </sect1>

   <sect1 id="plugins.block.functions"><title>Fonctions de blocs</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>void <function>smarty_block_<replaceable>name</replaceable></function></funcdef>
      <paramdef>array <parameter>$params</parameter></paramdef>
      <paramdef>mixed <parameter>$content</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
    Les fonctions de blocs sont des fonctions de la forme {func} .. {/func}.
    En d'autres mots, elles englobent des blocs de template et opérent sur les
    contenus de ces blocs. Les fonctions de blocs ont la priorité sur les
    fonctions utilisateurs de même nom, ce qui signifie que vous ne
    pouvez avoir une fonction utilisateur {func} et une fonction de bloc
    {func} .. {/func}.
    </para>
    <para>
    L'implémentation de votre fonction est appelée deux fois par Smarty :
    une fois pour la balise ouvrante et une autre fois pour la balise
    fermante.
    </para>
    <para>
    Seule la balise ouvrante d'une fonction de bloc peut avoir des attributs.
    Tous les attributs passés par le template aux fonctions de templates sont
    contenues dans le tableau associatif <parameter>$params</parameter>.
    Vous pouvez accéder a ces valeurs soit directement, par exemple
    <varname>$params['start']</varname>, soit en utilisant
    <varname>extract($params)</varname> pour les importer dans la table
    des symboles. Votre fonction a aussi accés aux attributs de la balise
    ouvrante quand c'est la balise fermante qui est exécutée.     
    </para>
    <para>
    La valeur de la variable <parameter>$content</parameter> est différente
    selon si votre fonction est appelée pour la balise ouvrante ou la
    balise fermante. Si c'est pour la balise ouvrante, elle sera a
    <literal>null</literal> et si c'est la balise fermante elle sera
    égale au contenu du bloc de template. Notez que le bloc de template
    aura déjà été exécuté par Smarty, vous recevrez donc la sortie du
    template et non sa source.    
    </para>
    <para>
    Si vous imbriqué des fonctions de bloc, il est possible de connaetre
    la fonction de bloc parente grGce a la variable <varname>$smarty->_tag_stack</varname>.
    Faites un var_dump() dessus et la structure devrait apparaetre.
    </para>    
    <para>
     Regardez aussi :
     <link linkend="api.register.block">register_block()</link>,
     <link linkend="api.unregister.block">unregister_block()</link>.
    </para>
    <example>
     <title>fonction de bloc</title>
     <programlisting>
&lt;?php
/*
 * Smarty plugin
 * -------------------------------------------------------------
 * Fichier :  block.translate.php
 * Type :     bloc
 * Nom :      translate
 * Rôle :     traduire un bloc de texte
 * -------------------------------------------------------------
 */
function smarty_block_translate($params, $content, &amp;$smarty)
{
    if ($content) {
        $lang = $params['lang'];
        // fait une traduction de $content
        echo $translation;
    }
}</programlisting>
    </example>
   </sect1>

   <sect1 id="plugins.compiler.functions"><title>Fonctions de compilation</title>
    <para>
    Les fonctions de compilation sont appelées durant la compilation du template.
    Elles sont utiles pour injecter du code PHP ou du contenu "statique variant
    avec le temps" (bandeau de pub par ex.). Si une fonction de compilation et
    une fonction personnalisée ont le même
    nom, la fonction de compilation a priorité. 
    </para>
    <funcsynopsis>
     <funcprototype>
      <funcdef>mixed <function>smarty_compiler_<replaceable>name</replaceable></function></funcdef>
      <paramdef>string <parameter>$tag_arg</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
    Les fonctions de compilation ont deux paramétres : une chaene contenant
    la balise - en gros, tout, depuis le nom de la fonction jusqu'au délimiteur de fin - et
    l'objet Smarty. Elles sont censées retourner le code PHP qui doit être
    injecté dans le template compilé.
    </para>
    <para>
     Regardez aussi
     <link linkend="api.register.compiler.function">register_compiler_function()</link>,
     <link linkend="api.unregister.compiler.function">unregister_compiler_function()</link>.
    </para>
    <example>
     <title>fonction de compilation simple</title>
     <programlisting>
&lt;?php
/*
 * Smarty plugin
 * -------------------------------------------------------------
 * Fichier :   compiler.tplheader.php
 * Type :      compilation
 * Nom :       tplheader
 * Rôle :      Renvoie l'en-tête contenant le nom du fichier
 *             source et le temps de compilation.
 * -------------------------------------------------------------
 */
function smarty_compiler_tplheader($tag_arg, &amp;$smarty)
{
    return "\necho '" . $smarty-&gt;_current_file . " compiled at " . date('Y-m-d H:M'). "';";
}
?&gt;</programlisting>
     <para>
     Cette fonction peut-être appelé depuis le template comme suivant :
     </para>     
     <programlisting>
{* cette fonction n'est executée que lors de la compilation *}
{tplheader}</programlisting>
     <para>
     Le code PHP résultant dans les templates compilés ressemblerait a ta :
     </para>
     <programlisting>
&lt;php
echo 'index.tpl compiled at 2002-02-20 20:02';
?&gt;</programlisting>
    </example>
   </sect1>

   <sect1 id="plugins.prefilters.postfilters">
    <title>filtres de pré-compilation/filtres de post-compilation</title>
    <para>
    Les filtres de pré-compilation et les filtres de post-compilation ont des concepts trés
    proches. Ils différent dans leur exécution, plus précisément dans le
    moment oú ils sont exécutés.
    </para>
    <funcsynopsis>
     <funcprototype>
      <funcdef>string <function>smarty_prefilter_<replaceable>name</replaceable></function></funcdef>
      <paramdef>string <parameter>$source</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
    Les filtres de pré-compilation sont utilisés pour transformer la source d'un template
    juste avant la compilation. Le premier paramétre passé a la fonction
    de filtre de pré-compilation est la source du template, éventuellement modifiée par
    d'autres filtre de pré-compilations. Le plugin est supposé retourner la source modifiée.
    Notez que cette source n'est sauvegardée nulle part, elle est seulement
    utilisé pour la compilation.
    </para>
    <funcsynopsis>
     <funcprototype>
      <funcdef>string <function>smarty_postfilter_<replaceable>name</replaceable></function></funcdef>
      <paramdef>string <parameter>$compiled</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
    Les filtres de post-compilation sont utilisés pour modifier la sortie du template
    (le code PHP) juste aprés que la compilation a été faite mais juste
    avant que le template ne soit sauvegardé sur le systéme de fichiers.
    Le premier paramétre passé a la fonction de filtre de post-compilation est le code
    du template compilé, éventuellement déja modifié par d'autres filtre de post-compilations.
    Le plugin est censé retourner la version modifié du code.
    </para>
    <example>
     <title>plugin de filtre de post-compilation</title>
     <programlisting>
&lt;?php
/*
 * Smarty plugin
 * -------------------------------------------------------------
 * Fichier :  prefilter.pre01.php
 * Type :     filtre de pré-compilation
 * Nom :      pre01
 * Rôle :     Passe les balises HTML en minuscules.
 * -------------------------------------------------------------
 */
 function smarty_prefilter_pre01($source, &amp;$smarty)
 {
     return preg_replace('!&lt;(\w+)[^&gt;]+&gt;!e', 'strtolower("$1")', $source);
 }
?&gt;</programlisting>
    </example>
    <para></para>
    <example>
     <title>plugin de filtre de post-compilation</title>
     <programlisting>
&lt;?php
/*
 * Smarty plugin
 * -------------------------------------------------------------
 * Fichier :  postfilter.post01.php
 * Type:      filtre de post-compilation
 * Nom :      post01
 * Rôle :     Renvoie du code qui liste toutes les variables
 *            du template.
 * -------------------------------------------------------------
 */
 function smarty_postfilter_post01($compiled, &amp;$smarty)
 {
     $compiled = "&lt;pre&gt;\n&lt;?php print_r(\$this-&gt;get_template_vars()); ?&gt;\n&lt;/pre&gt;" . $compiled;
     return $compiled;
 }
?&gt;</programlisting>
    </example>
   </sect1>

   <sect1 id="plugins.outputfilters"><title>Filtres de sortie</title>
    <para>
    Les plugins de filtres de sortie opérent sur la sortie du template,
    aprés que le template a été chargé et exécuté, mais avant que
    la sortie ne soit affichée.
    </para>    
    <funcsynopsis>
     <funcprototype>
      <funcdef>string <function>smarty_outputfilter_<replaceable>name</replaceable></function></funcdef>
      <paramdef>string <parameter>$template_output</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
    Le premier paramétre passé a la fonction du filtre de sortie est la
    sortie du template qui doit être modifiée et le second paramétre
    est l'instance de Smarty appelant le plugin. Le plugin est supposé
    faire un traitement et en retourner le résultat.
    </para>
    <example>
     <title>plugin de filtre de sortie</title>
     <programlisting>
/*
 * Smarty plugin
 * -------------------------------------------------------------
 * Fichier :  outputfilter.protect_email.php
 * Type :     filtre de sortie
 * Nom :      protect_email
 * Rôle:     Convertie les @ en %40 pour protéger des 
 *           robots spammers.
 * -------------------------------------------------------------
 */
 function smarty_outputfilter_protect_email($output, &amp;$smarty)
 {
     return preg_replace('!(\S+)@([a-zA-Z0-9\.\-]+\.([a-zA-Z]{2,3}|[0-9]{1,3}))!',
                         '$1%40$2', $output);
 }
     </programlisting>
    </example>
   </sect1>

   <sect1 id="plugins.resources"><title>Ressources</title>
    <para>
    Les plugins ressources sont un moyen générique de fournir des sources
    de templates ou des composants de scripts PHP a Smarty. Quelques exemples
    de ressources : bases de données, LDAP, mémoire partagée, sockets, et ainsi
    de suite.
    </para>
    <para>
    Il y au total 4 fonctions qui ont besoin d'être enregistrées pour
    chaque type de ressource. Chaque fonction retoit le nom de la ressource demandée
    comme premier paramétre et l'objet Smarty comme dernier paramétre.
    Les autres paramétres dépendent de la fonction.
    </para>
    <funcsynopsis>
     <funcprototype>
      <funcdef>bool <function>smarty_resource_<replaceable>name</replaceable>_source</function></funcdef>
      <paramdef>string <parameter>$rsrc_name</parameter></paramdef>
      <paramdef>string <parameter>&amp;$source</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
     <funcprototype>
      <funcdef>bool <function>smarty_resource_<replaceable>name</replaceable>_timestamp</function></funcdef>
      <paramdef>string <parameter>$rsrc_name</parameter></paramdef>
      <paramdef>int <parameter>&amp;$timestamp</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
     <funcprototype>
      <funcdef>bool <function>smarty_resource_<replaceable>name</replaceable>_secure</function></funcdef>
      <paramdef>string <parameter>$rsrc_name</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
     <funcprototype>
      <funcdef>bool <function>smarty_resource_<replaceable>name</replaceable>_trusted</function></funcdef>
      <paramdef>string <parameter>$rsrc_name</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>

    <para>
    La premiére fonction est supposée récupérer la ressource. Son second
    paramétre est une variable passée par référence oú le résultat doit être
    stocké. La fonction est supposée retourner <literal>true</literal> si
    elle réussi a récupérer la ressource et <literal>false</literal> sinon.
    </para>

    <para>
    La seconde fonction est supposée récupérer la date de derniére modification 
    de la ressource demandée (comme un timestamp UNIX). Le second paramétre
    est une variable passée par référence dans laquelle la date doit
    être stockée. La fonction est supposée renvoyer <literal>true</literal> si elle
    a réussi a récupérer la date et <literal>false</literal> sinon.
    </para>

    <para>
    La troisiéme fonction est supposée retourner <literal>true</literal>
    ou <literal>false</literal> selon si la ressource demandée est svre
    ou non. La fonction est utilisée seulement pour les ressources templates
    mais doit tout de même être définie.
    </para>

    <para>
    La quatriéme fonction est supposée retourner <literal>true</literal>
    ou <literal>false</literal> selon si on peut faire confiance ou
    non a la ressource demandée. Cette fonction est utilisée seulement
    pour les composants de scripts PHP demandés par les balises
    <command>include_php</command> ou <command>insert</command>
    ayant un attribut <structfield>src</structfield>. Quoiqu'il en soit,
    elle doit être définie pour les ressources templates.
    </para>

    <para>
     Regardez aussi
     <link linkend="api.register.resource">register_resource()</link>,
     <link linkend="api.unregister.resource">unregister_resource()</link>.
    </para>
    <example>
     <title>resource plugin</title>
     <programlisting>
&lt;?php
/*
 * Smarty plugin
 * ------------------------------------------------------------- 
 * Fichier :  resource.db.php
 * Type :     ressource
 * Nom :      db
 * Rôle :     Récupére des templates depuis une base de données
 * -------------------------------------------------------------
 */
function smarty_resource_db_source($tpl_name, &amp;$tpl_source, &amp;$smarty)
{
    // fait des requêtes BD pour récupérer votre template
    // et remplir $tpl_source
    $sql = new SQL;
    $sql->query("select tpl_source
                   from my_table
                  where tpl_name='$tpl_name'");
    if ($sql->num_rows) {
        $tpl_source = $sql->record['tpl_source'];
        return true;
    } else {
        return false;
    }
}

function smarty_resource_db_timestamp($tpl_name, &amp;$tpl_timestamp, &amp;$smarty)
{
    // fait des requêtes BD pour remplir $tpl_timestamp
    $sql = new SQL;
    $sql->query("select tpl_timestamp
                   from my_table
                  where tpl_name='$tpl_name'");
    if ($sql->num_rows) {
        $tpl_timestamp = $sql->record['tpl_timestamp'];
        return true;
    } else {
        return false;
    }
}

function smarty_resource_db_secure($tpl_name, &amp;$smarty)
{
    // suppose que tous les templates sont svrs
    return true;
}

function smarty_resource_db_trusted($tpl_name, &amp;$smarty)
{
    // inutilisée pour les templates
}
?&gt;</programlisting>
    </example>
   </sect1>

   <sect1 id="plugins.inserts"><title>Insertions</title>
    <para>
    Les plugins d'insertion sont utilisés pour implémenter les fonctions
    qui sont appelées par les balises 
    <link linkend="language.function.insert"><command>insert</command></link>
    dans les templates.
    </para>
    <funcsynopsis>
     <funcprototype>
      <funcdef>string <function>smarty_insert_<replaceable>name</replaceable></function></funcdef>
      <paramdef>array <parameter>$params</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
    Le premier paramétre passé a la fonction est une tableau associatif
    d'attributs. Vous pouvez accéder a ces valeurs soit directement, par exemple
    <varname>$params['start']</varname>, soit en utilisant
    <varname>extract($params)</varname> pour les importer dans la table
    des symboles.
    </para>
    <para>
    La fonction d'insertion est supposée retourner le résultat qui sera
    substitué a la balise <command>insert</command> dans le template.
    </para>    
    <example>
     <title>plugin d'insertion</title>
     <programlisting>
&lt;?php
/*
 * Smarty plugin
 * ------------------------------------------------------------- 
 * Fichier :  insert.time.php
 * Type :     temps
 * Nom :      time
 * Rôle :     Insert la date/heure courante conformément
 *            au format
 * -------------------------------------------------------------
 */
function smarty_insert_time($params, &amp;$smarty)
{
    if (empty($params['format'])) {
        $smarty->trigger_error("insert time: missing 'format' parameter");
        return;
    }

    $datetime = strftime($params['format']);
    return $datetime;
}
?&gt;</programlisting>
    </example>
   </sect1>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
