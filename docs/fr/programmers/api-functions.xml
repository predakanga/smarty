<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision$ -->
   <chapter id="api.functions">
     <title>Méthodes</title>
        <sect1 id="api.append">
         <title>append</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>append</function></funcdef>
           <paramdef>mixed <parameter>var</parameter></paramdef>
          </funcprototype>
          <funcprototype>
           <funcdef>void <function>append</function></funcdef>
           <paramdef>string <parameter>varname</parameter></paramdef>
           <paramdef>mixed <parameter>var</parameter></paramdef>
          </funcprototype>
          <funcprototype>
           <funcdef>void <function>append</function></funcdef>
           <paramdef>string <parameter>varname</parameter></paramdef>
           <paramdef>mixed <parameter>var</parameter></paramdef>
           <paramdef>boolean <parameter>merge</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
         Utilisée pour ajouter un élément a un tableau assigné. Si vous utilisez
         cette fonction avec une chaîne de caractères, elle est convertie en
         tableau auquel on ajoute ensuite l'élément. Vous pouvez explicitement passer
         des paires nom/valeur. Si vous passez le troisième paramètre
         (optionel) a vrai, la valeur sera fusionnée avec le tableau plut(t que
         d'être ajoutée.
         </para>
		 <note>
		 <title>Note technique</title>
		 <para>
		 Le paramètre de fusion respecte les clés des tableaux, ainsi si vous
		 fusionnez deux tableaux indexés numériquement, ils pourront s'écraser
		 l'un l'autre ou donner des clés qui ne se suivent pas. Cela diffère
		 donc de la fonction PHP array_merge() qui supprime les clés numériques
		 et les renumérote.
		 </para>
		 </note>
         <example>
          <title>append</title>
          <programlisting>
// passe des paires nom/valeur
$smarty->append("Name","Fred");
$smarty->append("Address",$address);

// passe un tableau associatif
$smarty->append(array("city" => "Lincoln","state" => "Nebraska"));</programlisting>
</example>
		</sect1>
     <sect1 id="api.append.by.ref">
      <title>append_by_ref</title>
      <funcsynopsis>
       <funcprototype>
        <funcdef>void <function>append_by_ref</function></funcdef>
        <paramdef>string <parameter>varname</parameter></paramdef>
        <paramdef>mixed <parameter>var</parameter></paramdef>
       </funcprototype>
       <funcprototype>
        <funcdef>void <function>append_by_ref</function></funcdef>
        <paramdef>string <parameter>varname</parameter></paramdef>
        <paramdef>mixed <parameter>var</parameter></paramdef>
        <paramdef>boolean <parameter>merge</parameter></paramdef>
       </funcprototype>
      </funcsynopsis>
      <para>
      Utilisée pour ajouter des valeurs a un template par référence plut(t que
      par copie. Si vous ajoutez une variable par référence puis changez sa
      valeur, le changement est aussi répercuté sur la valeur assignée.
      Pour les objets, append_by_ref ne fait pas de copie en mémoire de l'objet
      assigné. Voir la documentation PHP pour plus d'informations sur les
      références de variable.
      Si vous passez le troisième paramètre a vrai, la valeur sera fusionnée
      avec le tableau courant plut(t que d'être ajoutée.
      </para>
	  <note>
	  <title>Note technique</title>
     <para>
       Le paramètre de fusion respecte les clés des tableaux, ainsi si vous
      fusionnez deux tableaux indexés numériquement, ils pourront s'écraser
      l'un l'autre ou donner des clés qui ne se suivent pas. Cela diffère
      donc de la fonction PHP array_merge() qui supprime les clés numériques
      et les renumérote.
     </para>
	  </note>
      <example>
       <title>append_by_ref</title>
       <programlisting>
// ajoute des paires nom/valeur
$smarty->append_by_ref("Name",$myname);
$smarty->append_by_ref("Address",$address);</programlisting>
</example>
		</sect1>
     <sect1 id="api.assign">
      <title>assign</title>
      <funcsynopsis>
       <funcprototype>
        <funcdef>void <function>assign</function></funcdef>
        <paramdef>mixed <parameter>var</parameter></paramdef>
       </funcprototype>
       <funcprototype>
        <funcdef>void <function>assign</function></funcdef>
        <paramdef>string <parameter>varname</parameter></paramdef>
        <paramdef>mixed <parameter>var</parameter></paramdef>
       </funcprototype>
      </funcsynopsis>
      <para>
      Utilisée pour assigner des valeurs aux templates. Vous pouvez
      explicitement passer des paires nom/valeur, ou des tableaux
      associatifs contenant des paires nom/valeur.
      </para>
      <example>
       <title>assign</title>
       <programlisting>
// passe des paires nom/valeur
$smarty->assign("Name","Fred");
$smarty->assign("Address",$address);

// passe un tableau associatif
$smarty->assign(array("city" => "Lincoln","state" => "Nebraska"));</programlisting>
</example>
		</sect1>
     <sect1 id="api.assign.by.ref">
      <title>assign_by_ref</title>
      <funcsynopsis>
       <funcprototype>
        <funcdef>void <function>assign_by_ref</function></funcdef>
        <paramdef>string <parameter>varname</parameter></paramdef>
        <paramdef>mixed <parameter>var</parameter></paramdef>
       </funcprototype>
      </funcsynopsis>
      <para>
      Utilisée pour assigner des valeurs aux templates par référence plut(t
      que par copie. Référez-vous au manuel PHP pour une explication plus précise
      sur les références des variables.
      </para>
	  <note>
	  <title>Note technique</title>
	  <para>
	    Si vous assignez une variable par référence puis changez sa
      valeur, le changement est aussi répercuté sur la valeur assignée.
      Pour les objets, assign_by_ref ne fait pas de copie en mémoire de l'objet
      assigné. Référez-vous au manuel PHP pour une explication plus précise sur
      les références de variable.
	  </para>
	  </note>
      <example>
       <title>assign_by_ref</title>
       <programlisting>
// passe des paires noms/valeurs
$smarty->assign_by_ref("Name",$myname);
$smarty->assign_by_ref("Address",$address);</programlisting>
</example>
		</sect1>
		<sect1 id="api.clear.all.assign">
			<title>clear_all_assign</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>clear_all_assign</function></funcdef>
				<paramdef><parameter></parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			Utilisée pour effacer les valeurs de toutes les variables assignées.
			</para>
<example>
<title>clear_all_assign</title>
<programlisting>
// efface toutes les variables assignées
$smarty->clear_all_assign();</programlisting>
</example>
		</sect1>
		<sect1 id="api.clear.all.cache">
			<title>clear_all_cache</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>clear_all_cache</function></funcdef>
				<paramdef>int <parameter>expire time</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
         Utilisée pour effacer les fichiers de cache des templates. Vous pouvez passer un
         paramètre optionnel afin d'indiquer l'Gge minimun que doivent avoir
         les fichiers  de cache pour qu'ils soient effacés.
			</para>
<example>
<title>clear_all_cache</title>
<programlisting>
// efface le cache
$smarty->clear_all_cache();</programlisting>
</example>
		</sect1>
		<sect1 id="api.clear.assign">
			<title>clear_assign</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>clear_assign</function></funcdef>
				<paramdef>string <parameter>var</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
         <para>
         Efface la valeur d'une variable assignée. Il peut s'agir
         d'une simple valeur ou d'un tableau de valeur.
         </para>
<example>
<title>clear_assign</title>
<programlisting>
// efface une variable
$smarty->clear_assign("Name");

// efface plusieurs variables
$smarty->clear_assign(array("Name","Address","Zip"));</programlisting>
</example>
		</sect1>
		<sect1 id="api.clear.cache">
			<title>clear_cache</title>
   <methodsynopsis>
    <type>void</type><methodname>clear_cache</methodname>
    <methodparam choice="opt"><type>string</type><parameter>template</parameter></methodparam>
    <methodparam choice="opt"><type>string</type><parameter>cache id</parameter></methodparam>
    <methodparam choice="opt"><type>string</type><parameter>compile id</parameter></methodparam>
    <methodparam choice="opt"><type>int</type><parameter>expire time</parameter></methodparam>
   </methodsynopsis>
			<para>
			Utilisée pour nettoyer le(s) fichier(s) de cache d'un template en particulier.
			Si vous avez plusieurs fichiers de cache pour ce template vous
			pouvez en spécifier un en  particulier en passant son identifiant
			en deuxième paramètre. Vous pouvez aussi passer un identifiant
			de compilation en troisième paramètre. Vous pouvez grouper des
			templates ensemble afin qu'ils puissent être supprimés en groupe.
			Référez-vous a la section sur le
			<link linkend="caching">cache</link>
			pour plus d'informations. Vous pouvez passer un quatrième paramètre
			pour indiquer un Gge minimum en secondes que le fichier en cache doit
			avoir avant d'être effacé.
			</para>
<example>
<title>clear_cache</title>
<programlisting>
// efface le fichier de cache de ce template
$smarty->clear_cache("index.tpl");

// efface un fichier de cache grGce a son identifiant de cache
$smarty->clear_cache("index.tpl","CACHEID");</programlisting>
</example>
		</sect1>
		<sect1 id="api.clear.compiled.tpl">
			<title>clear_compiled_tpl</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>clear_compiled_tpl</function></funcdef>
				<paramdef>string <parameter>tpl_file</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			Utilisée pour effacer la version compilée du template spécifié ou
			de tous les templates si aucun n'est spécifié. Cette fonction
			est destinée a un usage avancé et n'est pas habituellement utilisée.
			</para>
<example>
<title>clear_compiled_tpl</title>
<programlisting>
// efface la version compilée du template spécifié
$smarty->clear_compiled_tpl("index.tpl");

// efface tout le contenu du répertoire des templates compilés
$smarty->clear_compiled_tpl();</programlisting>
</example>
		</sect1>
		<sect1 id="api.clear.config">
			<title>clear_config</title>
   <methodsynopsis>
    <type>void</type><methodname>clear_config</methodname>
    <methodparam choice="opt"><type>string</type><parameter>var</parameter></methodparam>
   </methodsynopsis>
			<para>
         Utilisée pour effacer toutes les variables de configuration s'étant
         vues assigner une valeur. Si une variable est spécifiée, seule cette
         variable est effacée.
			</para>
<example>
<title>clear_config</title>
<programlisting>
// efface toutes les variables de configuration assignées
$smarty->clear_config();

// efface une seule variable
$smarty->clear_config('foobar');</programlisting>
</example>
		</sect1>
		<sect1 id="api.config.load">
			<title>config_load</title>
   <methodsynopsis>
    <type>void</type><methodname>config_load</methodname>
    <methodparam><type>string</type><parameter>file</parameter></methodparam>
    <methodparam choice="opt"><type>string</type><parameter>section</parameter></methodparam>
   </methodsynopsis>
			<para>
			Utilisée pour charger des données d'un fichier de config et les
			assigner a un template. Cette fonction fonctionne exactement comme
			la fonction de template <link
			linkend="language.function.config.load">config_load</link>.
			</para>
		  <note>
		  <title>Note technique</title>
		  <para>
		  Comme pour Smarty 2.4.0, les variables de templates assignées
        sont conservées entre chaque appel a fetch et display.
		  Les variables de configuration chargées avec config_load sont
        globales. Les fichiers de config sont aussi compilés pour une
        exécution plus rapide et respecte les réglages de <link
		   linkend="variable.force.compile">force_compile</link> et de <link
		   linkend="variable.compile.check">compile_check</link>.
		  </para>
		  </note>
<example>
<title>config_load</title>
<programlisting>
// charge les variables de configuration et les assigne
$smarty->config_load('my.conf');

// charge une section
$smarty->config_load('my.conf','foobar');</programlisting>
</example>
		</sect1>
		<sect1 id="api.display">
			<title>display</title>
   <methodsynopsis>
    <type>void</type><methodname>display</methodname>
    <methodparam><type>string</type><parameter>template</parameter></methodparam>
    <methodparam choice="opt"><type>string</type><parameter>cache_id</parameter></methodparam>
    <methodparam choice="opt"><type>string</type><parameter>compile_id</parameter></methodparam>
   </methodsynopsis>
			<para>
         Utilisée pour afficher un template. Il faut fournir un type et un
         chemin de <link
                linkend="template.resources">ressource template</link>
         valides. Vous pouvez passer en second paramètre un identifiant
         de fichier de cache. Reportez-vous a la section
         <link linkend="caching">cache</link> pour plus de renseignements.
			</para>
			<para>
			Le troisième paramètre optionnel est un identifiant de compilation.
         Cela s'avère utile quand vous voulez compiler différentes versions
         d'un même template, pour par exemple avoir des templates
         compilés séparés pour différents langages. Une autre utilité de ce
         paramètre est le cas oú vous utilisez plus d'un $template_dir mais un seul
         $compile_dir, car certains templates avec le même nom s'écraseraient
         entre eux. Vous pouvez aussi régler la variable <link
			linkend="variable.compile.id">$compile_id</link> une seule
			fois au lieu de la passer a chaque appel.
			</para>
<example>
<title>affichage</title>
<programlisting>
include("Smarty.class.php");
$smarty = new Smarty;
$smarty->caching = true;

// ne fait un appel a la base de données que si le fichier
// de cache n'existe pas
if(!$smarty->is_cached("index.tpl"))
{

    // quelques données
    $address = "245 N 50th";
    $db_data = array(
	    "City" => "Lincoln",
	    "State" => "Nebraska",
	    "Zip" = > "68502"
	    );

    $smarty->assign("Name","Fred");
    $smarty->assign("Address",$address);
    $smarty->assign($db_data);

}

// display the output
$smarty->display("index.tpl");</programlisting>
</example>
         <para>
         Utilisez la syntaxe des <link
			linkend="template.resources">ressources templates</link>
         pour afficher des fichiers en-dehors du répertoire
         $template_dir
         </para>

<example>
<title>exemples de fonction d'affichage de ressources templates</title>
<programlisting>
// chemin absolu
$smarty->display("/usr/local/include/templates/header.tpl");

// chemin absolu (pareil)
$smarty->display("file:/usr/local/include/templates/header.tpl");

// chemin absolu Windows (on DOIT utiliser le préfixe "file:")
$smarty->display("file:C:/www/pub/templates/header.tpl");

// inclue a partir de la ressource template "db"
$smarty->display("db:header.tpl");</programlisting>
</example>

		</sect1>
		<sect1 id="api.fetch">
			<title>fetch</title>
   <methodsynopsis>
    <type>string</type><methodname>fetch</methodname>
    <methodparam><type>string</type><parameter>template</parameter></methodparam>
    <methodparam choice="opt"><type>string</type><parameter>cache_id</parameter></methodparam>
    <methodparam choice="opt"><type>string</type><parameter>compile_id</parameter></methodparam>
   </methodsynopsis>
			<para>
			Utilisée pour renvoyer le résultat du template plut(t que de l'afficher.
         Il faut passer un type et un chemin de <link
         linkend="template.resources">ressource template</link>
         valides. Vous pouvez passer un identifiant de cache en deuxième
         paramètre. Reportez-vous a la section <link linkend="caching">cache
         </link> pour plus de renseignements.
			</para>
			<para>
         Un troisième paramètre optionnel est un identifiant de compilation.
         Cela s'avère utile quand vous voulez compiler différentes versions
         d'un même template, pour par exemple avoir des templates
         compilés séparés pour différents langages. Une autre utilité de ce
         paramètre est le cas oú vous utilisez plus d'un $template_dir
         mais un seul $compile_dir, car certains templates avec le même nom
         s'écraseraient entre eux. Vous pouvez aussi régler la variable <link
			linkend="variable.compile.id">$compile_id</link> une seule
			fois plut(t que de la passer a chaque appel.
			</para>
<example>
<title>fetch</title>
<programlisting>
include("Smarty.class.php");
$smarty = new Smarty;

$smarty->caching = true;

// ne fait un appel a la base de données que si le fichier
// de cache n'existe pas
if(!$smarty->is_cached("index.tpl"))
{

    // quelques données
    $address = "245 N 50th";
    $db_data = array(
	    "City" => "Lincoln",
	    "State" => "Nebraska",
	    "Zip" = > "68502"
	    );

    $smarty->assign("Name","Fred");
    $smarty->assign("Address",$address);
    $smarty->assign($db_data);

}

// récupère le résultat
$output = $smarty->fetch("index.tpl");

// fait quelque chose avec $output

echo $output;</programlisting>
</example>
		</sect1>
		<sect1 id="api.get.config.vars">
			<title>get_config_vars</title>
   <methodsynopsis>
    <type>array</type><methodname>get_config_vars</methodname>
    <methodparam choice="opt"><type>string</type><parameter>varname</parameter></methodparam>
   </methodsynopsis>
			<para>
			Retourne la valeur de la variable de configuration passée en paramètre.
			Si aucun paramètre n'est donné, un tableau de toutes les variables de
			configuration chargées est renvoyé.
			</para>
<example>
<title>get_config_vars</title>
<programlisting>
// récupère la variable de configuration chargée 'foo'
$foo = $smarty->get_config_vars('foo');

// récupère toutes les variables de configuration chargées
$config_vars = $smarty->get_config_vars();

// les affiche a l'écran
print_r($config_vars);</programlisting>
</example>
		</sect1>
		<sect1 id="api.get.registered.object">
			<title>get_registered_object</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>array <function>get_registered_object</function></funcdef>
				<paramdef>string <parameter>object_name</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			Retourne la référence d'un objet enregistré. Utile quand vous
			voulez accéder directement a un objet enregistré avec une
			fonction utilisateur.
			</para>
<example>
<title>get_registered_object</title>
<programlisting>
function smarty_block_foo($params, &amp;$smarty) {
	if (isset[$params['object']]) {
      // récupère la référence de l'objet enregistré
   		$obj_ref =&amp; $smarty->get_registered_object($params['object']);
   	// $obj_ref est maintenant une référence vers l'objet
	}
}</programlisting>
</example>
		</sect1>
		<sect1 id="api.get.template.vars">
			<title>get_template_vars</title>
   <methodsynopsis>
    <type>array</type><methodname>get_template_vars</methodname>
    <methodparam choice="opt"><type>string</type><parameter>varname</parameter></methodparam>
   </methodsynopsis>
			<para>
			Retourne la valeur assignée passée en paramètre. Si aucun paramètre
			n'est donné, un tableau de toutes les variables assignées est
			renvoyé.
			</para>
<example>
<title>get_template_vars</title>
<programlisting>
// récupère la variable 'foo' assignée au template
// get assigned template var 'foo'
$foo = $smarty->get_template_vars('foo');

// récupère toutes les variables assignées a ce template
$tpl_vars = $smarty->get_template_vars();

// les affiche a l'écran
print_r($tpl_vars);</programlisting>
</example>
		</sect1>
		<sect1 id="api.is.cached">
			<title>is_cached</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>is_cached</function></funcdef>
				<paramdef>string <parameter>template</parameter></paramdef>
				<paramdef>[string <parameter>cache_id</parameter>]</paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			Retourne vrai s'il y a un fichier de cache valide pour ce template.
			Cela fonctionne seulement si <link
         linkend="variable.caching">caching</link> est a vrai.
			</para>
<example>
<title>is_cached</title>
<programlisting>
$smarty->caching = true;

if(!$smarty->is_cached("index.tpl")) {
    // faire des requêtes base de données et assigner
    // des variables ici.
}

$smarty->display("index.tpl");</programlisting>
</example>
            <para>
            Vous pouvez aussi passer en second paramètre un identifiant
            de cache au cas oú vous voudriez plusieurs fichiers de cache
            pour ce template.
            </para>
<example>
<title>is_cached with multiple-cache template</title>
<programlisting>
$smarty->caching = true;

if(!$smarty->is_cached("index.tpl","FrontPage")) {
    // faire des requêtes base de données et assigner
    // des variables ici.
}

$smarty->display("index.tpl","FrontPage");</programlisting>
</example>
		</sect1>
        <sect1 id="api.load.filter">
         <title>load_filter</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>load_filter</function></funcdef>
           <paramdef>string <parameter>type</parameter></paramdef>
           <paramdef>string <parameter>name</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
         Cette fonction peut être utilisée pour charger un plugin
         de filtrage. Le premier argument spécifie le type du filtre
         et peut prendre l'une des valeurs suivantes : 'pre', 'post'
         ou 'output'. Le second argument spécifie le nom du plugin
         de filtrage, par exemple 'trim'.
         </para>
<example>
<title>Chargement de plugins de filtrage</title>
<programlisting>
$smarty->load_filter('pre', 'trim'); // charge le filtre 'trim' de type 'pre'
$smarty->load_filter('pre', 'datefooter'); // charge un autre filtre de type 'pre' appelé 'datefooter'
$smarty->load_filter('output', 'compress'); // charge le filtre 'compress' de type 'output'</programlisting>
</example>
        </sect1>
		<sect1 id="api.register.block">
			<title>register_block</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>register_block</function></funcdef>
				<paramdef>string <parameter>name</parameter></paramdef>
				<paramdef>string <parameter>impl</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
         Utilisée pour déclarrer dynamiquement des plugins de fonction
         de blocs. Il faut passer en paramètre le nom de la fonction
         de blocs, suivi du nom de la fonction PHP qui l'implémente.
         </para>
<example>
<title>register_block</title>
<programlisting>
/* PHP */
$smarty->register_block("translate", "do_translation");

function do_translation ($params, $content, &amp;$smarty) {
    if ($content) {
        $lang = $params['lang'];
        // fait de la traduction avec la variable $content
        echo $translation;
    }
}

{* template *}
{translate lang="br"}
   Hello, world!
{/translate}</programlisting>
</example>
		</sect1>
		<sect1 id="api.register.compiler.function">
			<title>register_compiler_function</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>register_compiler_function</function></funcdef>
				<paramdef>string <parameter>name</parameter></paramdef>
				<paramdef>string <parameter>impl</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			Utilisée pour déclarer dynamiquement un plugin de fonction
			de compilation. Il faut passer en paramètres le nom de la fonction
			de compilation, suivi par la fonction PHP qui
			l'implémente.
			</para>
		</sect1>
		<sect1 id="api.register.function">
			<title>register_function</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>register_function</function></funcdef>
				<paramdef>string <parameter>name</parameter></paramdef>
				<paramdef>string <parameter>impl</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			Utilisée pour déclarer dynamiquement des plugins de fonction
			de templates. Il faut passer en paramètres le nom de la fonction
			de templates, suivi par le nom de la fonction PHP qui l'implémente.
			</para>
<example>
<title>register_function</title>
<programlisting>
$smarty->register_function("date_now", "print_current_date");

function print_current_date ($params) {
    extract($params);
    if(empty($format))
        $format="%b %e, %Y";
    echo strftime($format,time());
}

// vous pouvez maintenant utiliser ceci dans Smarty pour afficher
// la date actuelle : {date_now} ou {date_now format="%Y/%m/%d"}
// pour la formater</programlisting>
</example>
		</sect1>
		<sect1 id="api.register.modifier">
         <title>register_modifier</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>register_modifier</function></funcdef>
           <paramdef>string <parameter>name</parameter></paramdef>
           <paramdef>string <parameter>impl</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
         Utilisée pour déclarer dynamiquement un plugin de modificateur.
         Il faut passer en paramètre le nom du modificateur de variables,
         suivi de la fonction PHP qui l'implémente.
         </para>
<example>
<title>register_modifier</title>
<programlisting>
// associons la fonction PHP stripslashes a un modificateur Smarty.

$smarty->register_modifier("sslash","stripslashes");

// vous pouvez maintenant utiliser {$var|sslash} pour supprimer les slash des variables</programlisting>
</example>
		</sect1>
		<sect1 id="api.register.object">
			<title>register_object</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>register_object</function></funcdef>
				<paramdef>string <parameter>object_name</parameter></paramdef>
				<paramdef>object <parameter>$object</parameter></paramdef>
				<paramdef>array <parameter>allowed methods/properties</parameter></paramdef>
				<paramdef>boolean <parameter>format</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			Utilisée pour enregistrer un objet a utiliser dans un template.
			Reportez-vous a la section
         <link linkend="advanced.features.objects">objet</link> de
         ce manuel pour des exemples.
         </para>
		</sect1>
		<sect1 id="api.register.outputfilter">
			<title>register_outputfilter</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>register_outputfilter</function></funcdef>
				<paramdef>string <parameter>function_name</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			Utilisée pour déclarer dynamiquement des filtres de sortie, pour
			agir sur la sortie d'un template avant qu'elle ne soit affichée.
			Reportez-vous a la section <link linkend="advanced.features.outputfilters">
         filtres de sortie</link> pour plus d'information sur le sujet.
			</para>
		</sect1>
		<sect1 id="api.register.postfilter">
			<title>register_postfilter</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>register_postfilter</function></funcdef>
				<paramdef>string <parameter>function_name</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
         Utilisée pour déclarer dynamiquement des filtres de post-compilation pour y faire
         passer des templates une fois qu'ils ont été compilés. Reportez-vous
         a la section
          <link linkend="advanced.features.postfilters">filtres de post-compilation de templates</link>
         pour avoir plus de renseignements sur la faton de paramétrer les fonctions
         de post-compilation.
			</para>
		</sect1>
		<sect1 id="api.register.prefilter">
			<title>register_prefilter</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>register_prefilter</function></funcdef>
				<paramdef>string <parameter>function_name</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			Utilisée pour déclarer dynamiquement des filtres de pré-compilation pour y faire
         passer des templates avant qu'ils ne soient compilés. Reportez-vous
         a la section
          <link linkend="advanced.features.postfilters">filtres de pré-compilation de templates</link>
         pour avoir plus de renseignements sur la faton de paramétrer les fonctions
         de pré-compilation.
			</para>
		</sect1>
        <sect1 id="api.register.resource">
         <title>register_resource</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>register_resource</function></funcdef>
           <paramdef>string <parameter>name</parameter></paramdef>
           <paramdef>array <parameter>resource_funcs</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
         Utilisée pour déclarer dynamiquement une ressource plugin
         dans Smarty. Il faut passer en paramètre le nom de la ressource
         et le tableau des fonctions PHP qui l'implémentent. Reportez-vous
         a la section <link linkend="template.resources">ressources templates</link>
         pour avoir plus d'informations sur la faton de paramétrer une fonction
         récupérant des templates.
         </para>
<example>
<title>register_resource</title>
<programlisting>
$smarty->register_resource("db", array("db_get_template",
                                       "db_get_timestamp",
                                       "db_get_secure",
                                       "db_get_trusted"));</programlisting>
</example>
		</sect1>
        <sect1 id="api.trigger.error">
         <title>trigger_error</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>trigger_error</function></funcdef>
           <paramdef>string <parameter>error_msg</parameter></paramdef>
           <paramdef>[int <parameter>level</parameter>]</paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
         Cette fonction peut-être utilisée pour afficher un message d'erreur
         en utilisant Smarty. Le paramètre <parameter>level</parameter>
         peut prendre l'une des valeures utilisées par la fonction PHP
         trigger_error, i.e. E_USER_NOTICE, E_USER_WARNING, etc. Par défaut
         il s'agit de E_USER_WARNING.
         </para>
        </sect1>

        <sect1 id="api.template.exists">
         <title>template_exists</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>bool <function>template_exists</function></funcdef>
           <paramdef>string <parameter>template</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
         Cette fonction vérifie si le template spécifié existe. Elle accepte
         soit un chemin vers le template, soit une ressource de type
         chaene de caractères précisant le nom du template.
         </para>
        </sect1>
        <sect1 id="api.unregister.block">
         <title>unregister_block</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>unregister_block</function></funcdef>
           <paramdef>string <parameter>name</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
         Utilisée pour désallouer dynamiquement un plugin de fonction
         de blocs. Passez en paramètre le nom du bloc.
         </para>
		</sect1>
        <sect1 id="api.unregister.compiler.function">
         <title>unregister_compiler_function</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>unregister_compiler_function</function></funcdef>
           <paramdef>string <parameter>name</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
         Utilisée pour désallouer dynamiquement un fonction de compilation.
         Passez en paramètre le nom de la fonction de compilation.
         </para>
        </sect1>
		<sect1 id="api.unregister.function">
         <title>unregister_function</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>unregister_function</function></funcdef>
           <paramdef>string <parameter>name</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
         Utilisée pour désallouer dynamiquement un plugin de fonction
         de templates. Passez en paramètres le nom de la fonction de templates.
         </para>
<example>
<title>unregister_function</title>
<programlisting>
// nous ne voulons pas que les designers de templates aient accès
// au système de fichiers.

$smarty->unregister_function("fetch");</programlisting>
</example>
		</sect1>
		<sect1 id="api.unregister.modifier">
         <title>unregister_modifier</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>unregister_modifier</function></funcdef>
           <paramdef>string <parameter>name</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
         Utilisée pour désallouer dynamiquement un plugin modificateur de variable.
         Passez en paramètre le nom du modificateur de templates.
         </para>
<example>
<title>unregister_modifier</title>
<programlisting>
// nous ne voulons pas que les designers de templates
// suppriment les balises des élements

$smarty->unregister_modifier("strip_tags");</programlisting>
</example>
		</sect1>
		<sect1 id="api.unregister.object">
			<title>unregister_object</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>unregister_object</function></funcdef>
				<paramdef>string <parameter>object_name</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			Utilisée pour désallouer un objet.
         </para>
		</sect1>
		<sect1 id="api.unregister.outputfilter">
			<title>unregister_outputfilter</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>unregister_outputfilter</function></funcdef>
				<paramdef>string <parameter>function_name</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			Utilisée pour désallouer dynamiquement un filtre de sortie.
			</para>
		</sect1>
		<sect1 id="api.unregister.postfilter">
			<title>unregister_postfilter</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>unregister_postfilter</function></funcdef>
				<paramdef>string <parameter>function_name</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			Utilisée pour désallouer dynamiquement un filtre de post-compilation.
			</para>
		</sect1>
		<sect1 id="api.unregister.prefilter">
			<title>unregister_prefilter</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>unregister_prefilter</function></funcdef>
				<paramdef>string <parameter>function_name</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			Utilisée pour désallouer dynamiquement un filtre de pré-compilation.
			</para>
		</sect1>
        <sect1 id="api.unregister.resource">
         <title>unregister_resource</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>unregister_resource</function></funcdef>
           <paramdef>string <parameter>name</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
         Utilisée pour désallouer dynamiquement un plugin ressource.
         Passez en paramètre le nom de la ressource.
         </para>
<example>
<title>unregister_resource</title>
<programlisting>
$smarty->unregister_resource("db");</programlisting>
</example>
		</sect1>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
