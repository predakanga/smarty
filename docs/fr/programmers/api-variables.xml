<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision$ -->
    <chapter id="api.variables">
     <title>Variables</title>

     <sect1 id="variable.template.dir">
      <title>$template_dir</title>
      <para>
      C'est le nom par dTfaut du rTpertoire des templates.
      Si vous ne spTcifiez aucun chemin lors de l'utilisation de templates, Smarty
      les cherchera a cet emplacement.
      Par dTfaut, il s'agit de "./templates", ce qui signifie
      qu'il va chercher le rTpertoire templates
      dans le rTpertoire oú se trouve le script PHP en cours d'exTcution.
      </para>

	   <note>
		   <title>Note technique</title>
         <para>
         Il n'est pas conseillT de mettre ce rTpertoire
         dans l'arborescence Web.
         </para>
	  </note>
     </sect1>		
     <sect1 id="variable.compile.dir">
      <title>$compile_dir</title>
      <para>
      C'est le nom du rTpertoire oú se trouvent les templates
      compilTs. Par dTfaut, il s'agit de "./templates_c",
      ce qui signifie que Smarty va chercher ce rTpertoire
      dans le mOme rTpertoire que le script PHP en cours d'exTcution.
      </para>
	 <note>
	 <title>Note technique</title>
	 <para>
	 Ce rTglage doit Otre soit un chemin absolu, soit un chemin
	 relatif. include_path n'est pas utilisT pour Tcrire des fichiers.
	 </para>
	 </note>
	 <note>
	 <title>Note technique</title>
	 <para>
	 Il n'est pas conseillT de mettre ce rTpertoire
    sous la racine de l'arborescence Web.
	 </para>
	 </note>
     </sect1>
     <sect1 id="variable.config.dir">
      <title>$config_dir</title>
      <para>
      Il s'agit du rTpertoire utilisT pour stocker les
      fichiers de configuration utilisTs dans les templates.
      La valeur par dTfaut est "./configs", ce qui signifie
      que Smarty va chercher ce rTpertoire
      dans le mOme rTpertoire que le script PHP qui s'exTcute.
      </para>
	 <note>
	 <title>Note technique</title>
	 <para>
       Il n'est pas conseillT de mettre ce rTpertoire
      sous la racine de l'arborescence Web.
    </para>
	 </note>
     </sect1>
     <sect1 id="variable.plugins.dir">
      <title>$plugins_dir</title>
      <para>
      Ce sont les rTpertoire dans lesquels Smarty ira chercher les plugins
      dont il a besoin. La valeur par dTfaut est "plugins" sous le
      rTpertoire SMARTY_DIR. Si vous donnez un chemin relatif, Smarty
      regardera d'abord relativement au SMARTY_DIR, puis relativement au rtc (rTpertoire
      de travail courant), puis relativement a chaque entrTe de votre rTpertoire
      d'inclusion PHP.
      </para>
	  <note>
	  <title>Note technique</title>
	  <para>
	  Pour des raisons de performances, ne rTglez pas votre plugins_dir
	  pour qu'il utilise votre include_path PHP. Utilisez un
	  chemin absolu ou un chemin relatif a SMARTY_DIR ou au rtc.
	  </para>
	  </note>
     </sect1>
     <sect1 id="variable.debugging">
      <title>$debugging</title>
      <para>
      Cela active la
      <link
        linkend="chapter.debugging.console">console de dTbogage</link>.
      La console est une fenOtre javascript qui vous informe des templates
      inclus et des variables assignTes dans la page courante.
      </para>
     </sect1>
     <sect1 id="variable.debug.tpl">
      <title>$debug_tpl</title>
      <para>
      C'est le nom du fichier template utilisT pour la
      console de dTbuggage. Par dTfaut debug.tpl, il se situe dans <link
	   linkend="constant.smarty.dir">SMARTY_DIR</link>
      </para>
     </sect1>
     <sect1 id="variable.debugging.ctrl">
      <title>$debugging_ctrl</title>
      <para>
      Cela permet d'avoir diffTrents moyens pour activer
      le dTbogage. URL signifie que si SMARTY_DEBUG se
      trouve dans QUERY_STRING, le dTbuggage
      est activT a l'invocation du script. Si $debugging
      est a vrai, cette valeur est sans effet.
      </para>
     </sect1>
     <sect1 id="variable.global.assign">
      <title>$global_assign</title>
      <para>
      C'est une liste de variable qui sont toujours
      implicitement assignTes au moteur de templates.
      Ceci est commode pour rendre des variables globales
      ou des variables du serveur accessibles a tous les templates
      plut(t que de devoir les assigner a la main. Chaque TlTment
      de $global_assign doit Otre soit le nom de la variable
      globale, soit une paire clef/valeur, oú clef est le
      nom du tableau global et valeur le tableau de variable
      assignTes depuis ce tableau global.
      $SCRIPT_NAME est globalement assignT par dTfaut depuis
      $HTTP_SERVER_VARS.
      </para>
	 <note>
	 <title>Note technique</title>
	 <para>
	 On peut accTder aux variables du serveur avec la variable
	 $smarty, par exemple {$smarty.server.SCRIPT_NAME}.
	 Se reporter a la section sur la variable
	 <link linkend="language.variables.smarty">$smarty</link>.
	 </para>
	 </note>
     </sect1>
     <sect1 id="variable.undefined">
      <title>$undefined</title>
      <para>
      Cela rFgle la valeur de $undefined, null par dTfaut.
      N'est actuellement utilisT que pour initialiser
      des variables non-dTfinies dans $global_assign a des
      valeurs par dTfaut.
      </para>
     </sect1>
     <sect1 id="variable.autoload.filters">
      <title>$autoload_filters</title>
      <para>
      Si vous dTsirez charger des filtres a chaque invocation
      de templates, vous pouvez le spTcifier en utilisant cette
      variable. Les types de filtres et les valeurs sont des
      tableaux comportant le nom des filtres.
       <informalexample>
        <programlisting>
$smarty-&gt;autoload_filters = array('pre' =&gt; array('trim', 'stamp'),
                                  'output' => array('convert')); 
        </programlisting>
       </informalexample> 
      </para>
     </sect1>
     <sect1 id="variable.compile.check">
      <title>$compile_check</title>
      <para>
      A chaque invocation de l'application PHP, Smarty fait
      un test pour voir si le template courant a TtT modifiT
      (date de derniFre modification diffTrente) depuis sa
      derniFre compilation. S'il a changT, le template est recompilT.
      Si le template n'a pas encore TtT compilT, il le sera
      quelle que soit la valeur ce rTglage.
      Par dTfaut cette valeur est a vrai. Quand
      une application est mise en production (les templates
      ne changent plus), cette vTrification n'est pas nTcessaire.
      Assurez-vous de mettre $compile_check a "false" pour des performances
      maximales. Notez que si vous mettez ce paramFtre a "false" et qu'un
      template est modifiT, vous ne verrez *pas* le changement
      car le template ne sera *pas* recompilT. Si le processus de cache
      est activT et que $compile_check l'est aussi, alors les fichiers
      du cache seront regTnTrTs si un template concernT ou un fichier de
      configuration concernT est modifiT. Voir aussi <link
	   linkend="variable.force.compile">$force_compile</link> ou <link
	   linkend="api.clear.compiled.tpl">clear_compiled_tpl</link>.
      </para>

     </sect1>
     <sect1 id="variable.force.compile">
      <title>$force_compile</title>
      <para>
      Cela oblige Smarty a (re)compiler les templates a chaque
      invocation. Ce rTglage supplante $compile_check. Par dTfaut, il
      est dTsactivT. Ceci est commode pour le dTveloppement et le
      dTbogage mais ne devrait jamais Otre utilisT dans un environnment
      de production. Si le systFme de cache est actif, les
      fichiers du cache seront regTnTrTs a chaque appel.
      </para>
     </sect1>
     <sect1 id="variable.caching">
      <title>$caching</title>
      <para>
      Ce paramFtre demande a Smarty de mettre ou non en cache la sortie des
      templates.
      Par dTfaut ce rTglage est a 0 (dTsactivT). Si vos templates
      gTnFrent du contenu redondant, il est conseillT d'activer le
      cache. Cela permettra un gain de performance consTquent.
      Vous pouvez aussi avoir de nombreux fichiers de cache pour un mOme template.
      Une valeur de 1 ou 2 active le cache. 1 indique a Smarty d'utiliser
      la variable $cache_lifetime pour dTterminer si le fichier de cache a expirT.
      Une valeur de 2 indique a Smarty d'utiliser la valeur
      $cache_lifetime spTcifiTe a la gTnTration du cache. Ainsi vous pouvez rTgler
      la durTe de vie d'un fichier de cache avant de rTcupTrer le template pour avoir
      un certain contr(le quand ce fichier en particulier expire. Voir
      aussi <link linkend="api.is.cached">is_cached</link>.
      </para>
      <para>
      Si $compile_check est actif, le contenu du cache sera regTnTrT
      si un des templates ou un des fichiers de configuration qui fait partie
      de ce fichier de cache a TtT modifiT. Si $force_compile est actif, le contenu
      du cache est toujours regTnTrT.
      </para>
     </sect1>
     <sect1 id="variable.cache.dir">
      <title>$cache_dir</title>
      <para>
      Il s'agit du nom du rTpertoire oú les caches des templates
      sont stockTs. Par dTfaut il s'agit de "./cache", ce qui signifie
      que Smarty va chercher ce rTpertoire
      dans le mOme rTpertoire que le script PHP en cours d'exTcution.
      </para>
	 <note>
	 <title>Note technique</title>
	 <para>
       Ce rTglage doit Otre soit un chemin absolu, soit un chemin
	 relatif. include_path n'a aucune influence lors de l'Tcriture des fichiers.
      </para>
	  </note>
	  <note>
		  <title>Technical Note</title>
		  <para>
         Il n'est pas conseillT de mettre ce rTpertoire
         dans l'arborescence Web.
    	  </para>
	  </note>
     </sect1>
     <sect1 id="variable.cache.lifetime">
      <title>$cache_lifetime</title>
      <para>
      Il s'agit de la durTe en secondes pendant laquelle un cache de template
      est valide. Une fois cette durTe dTpassTe, le cache est regTnTrT.
      $caching doit Otre a "true" pour que $cache_lifetime ait une
      quelconque utilitT. Avec une valeur de -1, le cache n'expire jamais.
      Avec une valeur de 0, le cache est toujours regTnTrT (utile
      a des fins de tests seulement. Une meilleure faton de dTsactiver
      le cache est de mettre <link
	   linkend="variable.caching">$caching</link> a "false").
      </para>
      <para>
      Si <link linkend="variable.force.compile">$force_compile</link> est
      activT, les fichiers du cache seront regTnTrTs a chaque fois,
      dTsactivant ainsi le cache. Vous pouvez effacer tous les fichiers du cache
      avec la function
      <link linkend="api.clear.all.cache">clear_all_cache()</link>
      ou de faton individuelle (ou groupTe)
      avec la fonction <link
	   linkend="api.clear.cache">clear_cache()</link>.
      </para>
	  <note>
	  <title>Note technique</title>
	  <para>
	  Si vous souhaitez donner a certains templates leur propre durTe de vie
	  en cache, vous pouvez le faire en rTglant
	  <link linkend="variable.caching">$caching</link> a 2,
	  puis $cache_lifetime a une unique valeur juste avant d'appeler
	  display ou fetch().
	  </para>
	  </note>
     </sect1>
     <sect1 id="variable.cache.handler.func">
      <title>$cache_handler_func</title>
      <para>
      Vous pouvez utiliser votre propre fonction de gestion du cache plut(t que
      d'utiliser celle livrTe avec Smarty.
      RTfTrez-vous a la section sur la fonction de gestion de cache
      personnalisTe pour plus de dTtails.
      </para>
     </sect1>
     <sect1 id="variable.cache.modified.check">
      <title>$cache_modified_check</title>
      <para>
      Si cette variable est a vrai, Smarty respectera l'en-tOte
      If-Modified-Since envoyT par le client. Si la date de derniFre
      modification du fichier de cache n'a pas changT depuis la derniFre
      visite, alors un en-tOte "304 Not Modified" sera envoyT a la place
      du contenu. Cela ne fonctionne qu'avec du contenu mis en cache hors de la
      balise <command>insert</command>.
      </para>
     </sect1>
     <sect1 id="variable.config.overwrite">
      <title>$config_overwrite</title>
      <para>
      Si cette variable est a vrai, les variables lues dans les fichiers
      de configuration peuvent s'Tcraser entre elles. Sinon les variables
      seront mises dans un tableau. TrFs utile si vous voulez stocker
      des tableaux de donnTes dans des fichiers de configuration, listez
      simplement chaque TlTment plusieurs fois. Mise a faux par dTfaut.
      </para>
     </sect1>
     <sect1 id="variable.config.booleanize">
      <title>$config_booleanize</title>
      <para>
      Si cette variable est a vrai, les valeurs on/true/yes et off/false/no
      dans les fichiers de configuration sont automitiquement converties
      en boolTen. De cette faton vous pouvez utiliser ces valeurs dans le
      template de la faton suivante : {if #foobar#} ... {/if}. Si foobar
      est a on, true ou yes, l'instruction {if} sera exTcutTe. vrai
      par dTfaut.
      </para>
     </sect1>
     <sect1 id="variable.config.read.hidden">
      <title>$config_read_hidden</title>
      <para>
      Si cette variable est a vrai, les sections cachTs (dont les noms
      commencent par un point) dans les fichiers de configuration peuvent
      Otre lues depuis les templates. On laisse habituellement cela a faux, de
      cette faton vous pouvez stocker des donnTes sensibles dans les fichiers
      de configuration, comme par exemple des paramFtres de base de donnTes,
      sans vous soucier de la faton dont les templates les chargent.
      Mise a faux par dTfaut.
      </para>
     </sect1>
     <sect1 id="variable.config.fix.newlines">
      <title>$config_fix_newlines</title>
      <para>
      Si cette variable est mise a vrai, les caractFres de nouvelles lignes mac et dos
      (\r et \r\n) sont convertis en \n quand ils sont analysTs. vrai par dTfaut.
      </para>
     </sect1>
     <sect1 id="variable.default.template.handler.func">
      <title>$default_template_handler_func</title>
      <para>
      Cette fonction est appelTe quand un template ne peut pas Otre
      obtenu avec sa ressource.
      </para>
     </sect1>
     <sect1 id="variable.php.handling">
      <title>$php_handling</title>
      <para>
      Indique a Smarty comment interprTter le code PHP
      intTgrT dans les templates. Il y a quatre valeurs possibles, par
      dTfaut SMARTY_PHP_PASSTHRU. Notez que cela n'affecte PAS le code
      PHP entourT des balises
      <link linkend="language.function.php">{php}{/php}</link>
      dans le template.
      </para>
      <itemizedlist>
       <listitem><para>SMARTY_PHP_PASSTHRU - Smarty Tcrit les balises
       telles quelles.</para></listitem>
       <listitem><para>SMARTY_PHP_QUOTE - Smarty transforme les balises
       en entitTs HTML.</para></listitem>
       <listitem><para>SMARTY_PHP_REMOVE - Smarty supprime les balises
       des templates.</para></listitem>
       <listitem><para>SMARTY_PHP_ALLOW - Smarty exTcute les balises
       comme du code PHP.</para></listitem>
      </itemizedlist>
      <para>
      NOTE : IntTgrer du code PHP dans les templates est vivement
      dTconseillT. PrTfTrez les
      <link linkend="language.custom.functions">fonctions utilisateurs</link>
      ou les <link linkend="language.modifiers">modificateurs de variables</link>.
      </para>
     </sect1>
     <sect1 id="variable.security">
      <title>$security</title>
      <para>
      Cette variable est a faux par dTfaut. $security est de rigueur
      quand vous n'Otes pas complFtement svr des personnes qui Tditent les templates
      (par ftp par exemple) et que vous voulez rTduire le risque que
      la sTcuritT du systFme soit compromise par le language de template.
      Activer cette option de sTcuritT applique les rFgles suivantes
      au langage de template, a moins que $security_settings ne spTcifie
      le contraire :
      </para>
      <itemizedlist>
       <listitem><para>Si $php_handling est rTglTe a SMARTY_PHP_ALLOW,
         cela est implicitement changT a SMARTY_PHP_PASSTHRU.</para></listitem>
       <listitem><para>Les fonctions PHP ne sont pas autorisTes dans les
         instructions IF, a part celles dTclarTes dans
         $security_settings.</para></listitem>
       <listitem><para>Les templates ne peuvent Otre inclus que depuis
         des rTpertoires listTs dans le tableau $security_dir.</para></listitem>
       <listitem><para>Les fichiers locaux ne peuvent Otre rTcupTrTs que depuis
         les rTpertoires listTs dans le tableau $security_dir en
         utilisant {fetch}.</para></listitem>
       <listitem><para>Les balises {php}{/php} ne sont pas autorisTes.</para></listitem>
       <listitem><para>Les fonctions PHP ne sont pas autorisTes en tant
         modificateurs, a part celles spTcifiTes dans $security_settings.</para></listitem>
      </itemizedlist>
     </sect1>
     <sect1 id="variable.secure.dir">
      <title>$secure_dir</title>
      <para>
      Il s'agit d'un tableau contenant tous les rTpertoires locaux qui sont
      considTrTs comme sTcurisTs. {include} et {fetch} l'utilisent quand
      la sTcuritT est activTe.
      </para>
     </sect1>
     <sect1 id="variable.security.settings">
      <title>$security_settings</title>
      <para>
      Ces rTglages servent a Tcraser ou spTcifier les paramFtres de sTcuritT
      quand celle-ci est activTe. Les rTglages possibles sont les suivants :
      </para>
      <itemizedlist>
       <listitem><para>PHP_HANDLING - true/false. Si vrai, le
       rTglage $php_handling n'est pas vTrifiT.</para></listitem>
       <listitem><para>IF_FUNCS - Le tableau des noms de fonctions
       PHP autorisTes dans les intructions IF.</para></listitem>
       <listitem><para>INCLUDE_ANY - true/false. Si vrai,
       les templates peuvent Otre inclus de n'importe oú, quelque soit
       le contenu de $secure_dir.</para></listitem>
       <listitem><para>PHP_TAGS - true/false. Si vrai,
       les balises {php}{/php} sont autorisTes dans les templates.</para></listitem>
       <listitem><para>MODIFIER_FUNCS - Le tableau des noms de fonctions
       autorisTes a Otre utilisTes comme modificateurs de variables.</para></listitem>
      </itemizedlist>
     </sect1>
     <sect1 id="variable.trusted.dir">
      <title>$trusted_dir</title>
      <para>
      $trusted_dir n'est utilisTe lorsque $security est activTe. C'est un
      tableau de tous les rTpertoires qui peuvent Otre considTrTs comme svrs.
      Les rTpertoires svrs sont ceux qui contiennent des scripts PHP qui
      sont exTcutTs directement depuis les templates avec
      <link linkend="language.function.include.php">{include_php}</link>.
      </para>
     </sect1>
     <sect1 id="variable.left.delimiter">
      <title>$left_delimiter</title>
      <para>
      Il s'agit du dTlimiteur gauche utilisT par le moteur de templates. La
      valeur par dTfaut est "{".
      </para>
     </sect1>
     <sect1 id="variable.right.delimiter">
      <title>$right_delimiter</title>
      <para>
      Il s'agit du dTlimiteur droit utilisT par le moteur de templates.
      La valeur par dTfaut est "}".
      </para>
     </sect1>
     <sect1 id="variable.compiler.class">
      <title>$compiler_class</title>
      <para>
      SpTcifie le nom de la classe du compilateur qui va Otre utilisTe pour
      compiler les templates. Le compilateur par dTfaut est
      'Smarty_Compiler'. RTservT aux utilisateurs avancTs.
      </para>
     </sect1>
     <sect1 id="variable.request.vars.order">
      <title>$request_vars_order</title>
      <para>
      L'ordre dans lequel les variables de requOtes sont enregistrTes,
      identique a variables_order dans php.ini.
      </para>
     </sect1>
     <sect1 id="variable.compile.id">
      <title>$compile_id</title>
      <para>
      Identifiant persistant du compilateur. On peut passer le mOme compile_id
      a chaque appel de fonction mais une alternative consiste a rTgler ce
      compile_id, qui sera utilisT implicitement.
      </para>
     </sect1>
     <sect1 id="variable.use.sub.dirs">
      <title>$use_sub_dirs</title>
      <para>
      RTgler cela a faux si votre environnement PHP n'autorise pas Smarty a crTer
      des sous-rTpertoires. Les sous-rTpertoires sont efficaces, utilisez-les quand
      vous le pouvez.
      </para>
     </sect1>
     <sect1 id="variable.default.modifiers">
      <title>$default_modifiers</title>
      <para>
      Il s'agit d'un tableau de modificateurs utilisT pour assigner
      une valeur par dTfaut a chaque variable dans un template.
      Par exemple, pour par dTfaut Tchapper les caractFres HTML de chaque variable,
      utilisez array('escape:"htmlall"'); Pour rendre une variable indTpendante
      des modificateurs par dTfaut, passez-lui en paramFtre le modificateur
      "nodefaults" : {$var|nodefaults}.
      </para>
     </sect1>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->