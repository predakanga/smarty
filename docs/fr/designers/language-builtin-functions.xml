<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision$ -->
    <chapter id="language.builtin.functions">
     <title>Fonctions natives</title>
     <para>
      Smarty est fourni en standard avec plusieurs fonctions natives.
      Les fonctions natives sont partie intégrante du language de template.
      Vous ne pouvez pas créer de fonctions utilisateurs qui portent le même nom
      qu'une fonction native. Vous ne pouvez pas non plus en modifier le
      comportement.
     </para>
     <sect1 id="language.function.capture">
      <title>capture</title>
      <para>
       Capture est utilisé pour récupérer la sortie d'éléments dans une variable
       au lieu de les afficher. Tout contenu situé entre {capture
       name="foo"} et {/capture} est intercepté dans une variable dont le nom est
       spécifié dans l'attribut name. Le contenu capturé peut être utilisé dans
       le template par l'intermédiaire de la variable spéciale $smarty.capture.foo
       ou foo est la valeur de l'attribut name. Si vous ne donnez pas de valeur
       à l'attribut name, alors "default" est utilisé. Toutes les commandes
       {capture} doivent être utilisées de paire avec {/capture}. Vous pouvez
       imbriquer les demandes de captures.
      </para>
	  <note>
	  <title>Note technique</title>
      <para>
       Smarty 1.4.0 - 1.4.4 plaçait les contenus capturés dans une variable
       appelée $return. Depuis Smarty 1.4.5, ce comportement à été modifié et
       Smarty utilise maintenant l'attribut name en lieu et place.
       Veuillez donc mettre vos templates à jour selon cette règle.
      </para>
	  </note>
      <caution>
       <para>
        Faites attention lorsque vous interceptez la sortie de commandes
        <command>insert</command>. Si vous avez configuré le cache pour que ce
        dernier soit actif, et que vous avez des commandes <command>insert</command>
        supposées s'exécuter dans un contenu en cache, ne tentez pas de capturer
        ce contenu.
       </para>
      </caution>
      <para>
       <example>
        <title>Capturer le contenu d'un template.</title>
        <programlisting>
{* nous ne voulons afficher une ligne que si cette dernière est activé. *}
{capture name=banner}
{include file="get_banner.tpl"}
{/capture}
{if $smarty.capture.banner ne ""}
	&lt;tr&gt;
		&lt;td&gt;
			{$smarty.capture.banner}
		&lt;/td&gt;
	&lt;/tr&gt;
{/if}</programlisting>
       </example>
      </para>
     </sect1>
		<sect1 id="language.function.config.load">
			<title>config_load</title>
            <informaltable frame="all">
                <tgroup cols="5">
                <colspec colname="param" align="center" />
                <colspec colname="type" align="center" />
                <colspec colname="required" align="center" />
                <colspec colname="default" align="center" />
                <colspec colname="desc" />
                <thead>
                    <row>
                        <entry>Nom attribut</entry>
                        <entry>Type</entry>
                        <entry>Requis</entry>
                        <entry>Defaut</entry>
                        <entry>Description</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>file</entry>
                        <entry>chaîne de caractère</entry>
                        <entry>Oui</entry>
                        <entry><emphasis>n/a</emphasis></entry>
                        <entry>Le nom du fichier de configuration à inclure</entry>
                    </row>
                    <row>
                        <entry>section</entry>
                        <entry>chaîne de caractère</entry>
                        <entry>Non</entry>
                        <entry><emphasis>n/a</emphasis></entry>
                        <entry>Le nom de la section à charger</entry>
                    </row>
                    <row>
                        <entry>scope</entry>
                        <entry>chaîne de caractère</entry>
                        <entry>non</entry>
                        <entry><emphasis>local</emphasis></entry>
                        <entry>
                        La façon dont la portée des variables est définie, soit
                        local, parent ou global. local signifie que la variable est
                        chargée dans le contexte du template. parent indique que
                        la variable est disponible tant dans le template qui
                        l'a inclus que dans le template parent, ayant réalisé
                        l'inclusion du sous template. global signifie que la variable
                        est diponible dans tous les templates.
						</entry>
                    </row>
                    <row>
                        <entry>global</entry>
                        <entry>booléen</entry>
                        <entry>Non</entry>
                        <entry><emphasis>No</emphasis></entry>
                        <entry>
                        Si oui ou non les variables sont disponibles pour les
                        templates parents, identique à scope=parent.
                        Note: Cet attribut est obsolète depuis l'apparition
                        de l'attribut scope, il est toutefois toujours supporté.
                        Si scope est défini, global est ignoré.
						</entry>
                    </row>
                </tbody>
                </tgroup>
            </informaltable>
			<para>
			Cette fonction est utiliseé pour charger des variables de fichier
         de configuration dans un template. Voir <link linkend="config.files">
         Fichiers de configuration</link> pour de plus amples informations.
			</para>
<example>
<title>fonction config_load</title>

<programlisting>
{config_load file="colors.conf"}

&lt;html&gt;
&lt;title&gt;{#pageTitle#}&lt;/title&gt;
&lt;body bgcolor="{#bodyBgColor#}"&gt;
&lt;table border="{#tableBorderSize#}" bgcolor="{#tableBgColor#}"&gt;
	&lt;tr bgcolor="{#rowBgColor#}"&gt;
		&lt;td&gt;First&lt;/td&gt;
		&lt;td&gt;Last&lt;/td&gt;
		&lt;td&gt;Address&lt;/td&gt;
	&lt;/tr&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;</programlisting>
</example>
			<para>
            Les fichiers de configuration peuvent contenir des sections.
            Vous pouvez charger des variables d'une section donnée avec le
            nouvel attribut <emphasis>section</emphasis>.
			</para>
            <para>
            NOTE: Les <emphasis>sections des fichiers de configuration</emphasis>
            et la fonction native <emphasis>section</emphasis> n'ont rien en
            commun, il s'avère simplement qu'elles portent le même nom.
            </para>
<example>
<title>fonction config_load et section</title>
<programlisting>
{config_load file="colors.conf" section="client"}

&lt;html&gt;
&lt;title&gt;{#pageTitle#}&lt;/title&gt;
&lt;body bgcolor="{#bodyBgColor#}"&gt;
&lt;table border="{#tableBorderSize#}" bgcolor="{#tableBgColor#}"&gt;
	&lt;tr bgcolor="{#rowBgColor#}"&gt;
		&lt;td&gt;First&lt;/td&gt;
		&lt;td&gt;Last&lt;/td&gt;
		&lt;td&gt;Address&lt;/td&gt;
	&lt;/tr&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;</programlisting>
</example>
		</sect1>
		<sect1 id="language.function.foreach">
			<title>foreach,foreachelse</title>
            <informaltable frame="all">
                <tgroup cols="5">
                <colspec colname="param" align="center" />
                <colspec colname="type" align="center" />
                <colspec colname="required" align="center" />
                <colspec colname="default" align="center" />
                <colspec colname="desc" />
                <thead>
                    <row>
                        <entry>Nom attribut</entry>
                        <entry>Type</entry>
                        <entry>Requis</entry>
                        <entry>Defaut</entry>
                        <entry>Description</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>from</entry>
                        <entry>chaîne de caractère</entry>
                        <entry>oui</entry>
                        <entry><emphasis>n/a</emphasis></entry>
                        <entry>Le nom du tableau à parcourir</entry>
                    </row>
                    <row>
                        <entry>item</entry>
                        <entry>chaîne de caractère</entry>
                        <entry>Oui</entry>
                        <entry><emphasis>n/a</emphasis></entry>
                        <entry>Le nom de la variable "élément courant"</entry>
                    </row>
                    <row>
                        <entry>key</entry>
                        <entry>chaîne de caractère</entry>
                        <entry>Non</entry>
						<entry><emphasis>n/a</emphasis></entry>
						<entry>Le nom de la variable représentant la clef courante.</entry>
                    </row>
                    <row>
                        <entry>name</entry>
                        <entry>chaîne de caractère</entry>
                        <entry>Non</entry>
                        <entry><emphasis>n/a</emphasis></entry>
						<entry>Le nom de la boucle foreach, qui nous permettra
                         d'accéder à ses propriétés.</entry>
                    </row>
                </tbody>
                </tgroup>
            </informaltable>
			<para>
			Les boucles <emphasis>foreach</emphasis> sont une alternative aux boucles
			<emphasis>section</emphasis>. Les boucles <emphasis>foreach</emphasis>
			sont utilisées pour parcourir des tableaux associatifs simples.
         La syntaxe des boucles <emphasis>foreach</emphasis> est bien plus simple
         que celle des boucles <emphasis>section</emphasis>, mais en contrepartie,
         elles ne peuvent être utilisées que pour des tableaux associatifs simples.
         La balise <emphasis>foreach</emphasis> doit toujours être accompagnée
         de la balise <emphasis>/foreach</emphasis>. Les paramètres requis sont
         <emphasis>from</emphasis> et <emphasis>item</emphasis>. Le nom des boucles
         foreach doit être composés exclusivement de lettres,
         chiffres et underscores, selon vos préférences. Les boucles
         <emphasis>foreach</emphasis> peuvent être imbriquées.
         La variable <emphasis>from</emphasis> (généralement le tableau à
         parcourir) détermine le nombre de fois que <emphasis>foreach</emphasis>
         sera exécuté. <emphasis>foreachelse</emphasis> est exécuté si aucune
         valeur n'est présente dans la variable donnée à l'attribut
         <emphasis>from</emphasis>.
			</para>
<example>
<title>foreach</title>
<programlisting>

{* Cet exemple affiche toutes les valeurs du tableau $custid *}
{foreach from=$custid item=curr_id}
	id: {$curr_id}&lt;br&gt;
{/foreach}

SORTIE:

id: 1000&lt;br&gt;
id: 1001&lt;br&gt;
id: 1002&lt;br&gt;</programlisting>
</example>

<example>
<title>foreach key</title>
<programlisting>
{* key contient la clef de chaque élément parcouru

l'attribution des élément est de la forme:

$smarty->assign("contacts", array(array("tel" =&gt; "1", "fax" =&gt; "2", "portable" =&gt; "3"),
      array("tel" =&gt; "555-4444", "fax" =&gt; "555-3333", "portable" =&gt; "760-1234")));

*}

{foreach name=outer item=contact from=$contacts}
  {foreach key=key item=item from=$contact}
    {$key}: {$item}&lt;br&gt;
  {/foreach}
{/foreach}

SORTIE:

tel: 1&lt;br&gt;
fax: 2&lt;br&gt;
portable: 3&lt;br&gt;
tel: 555-4444&lt;br&gt;
fax: 555-3333&lt;br&gt;
portable: 760-1234&lt;br&gt;</programlisting>
</example>
		</sect1>
		<sect1 id="language.function.include">
			<title>include</title>
            <informaltable frame="all">
                <tgroup cols="5">
                <colspec colname="param" align="center" />
                <colspec colname="type" align="center" />
                <colspec colname="required" align="center" />
                <colspec colname="default" align="center" />
                <colspec colname="desc" />
                <thead>
                    <row>
                        <entry>Nom attribut</entry>
                        <entry>Type</entry>
                        <entry>Requis</entry>
                        <entry>Defaut</entry>
                        <entry>Description</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>file</entry>
                        <entry>chaîne de caractères</entry>
                        <entry>Oui</entry>
                        <entry><emphasis>n/a</emphasis></entry>
                        <entry>Le nom du template à inclure</entry>
                    </row>
                    <row>
                        <entry>assign</entry>
                        <entry>chaîne de caractères</entry>
                        <entry>Non</entry>
                        <entry><emphasis>n/a</emphasis></entry>
                        <entry>Le nom de la variable dans laquelle sera assignée
                        la sortie de include</entry>
                    </row>
                    <row>
                        <entry>[var ...]</entry>
                        <entry>[type de variable]</entry>
                        <entry>Non</entry>
                        <entry><emphasis>n/a</emphasis></entry>
                        <entry>Variables à passer au template</entry>
                    </row>
                </tbody>
                </tgroup>
            </informaltable>
			<para>
            Les balises "include" sont utilisées pour inclure des templates à
            l'intérieur d'autres templates. Toutes les variables disponibles
            dans le template réalisant l'inclusion sont disponibles dans le
            template inclus. La balise include doit disposer de l'attribut
            "file", qui contient le chemin de la ressource template.
			</para>
			<para>
			Vous pouvez spécifier un attribut optionnel <emphasis>assign</emphasis>
			qui définit une variable de template dans laquelle la sortie de
         <emphasis>include</emphasis> sera stockée plutôt qu'affichée.
			</para>
<example>
<title>fonction include</title>
<programlisting>
{include file="header.tpl"}

{* Le corp du template va ici *}

{include file="footer.tpl"}</programlisting>
</example>
			<para>
          Vous pouvez également passer des variables au template inclus
          sous forme d'attributs. Les variables passées au template par ce moyen
          ne sont accessibles que dans la portée de ce dernier. Les variables
          passées en tant qu'attribut remplacent les variables déjà définies,
          qui auraient le même nom.
			</para>
<example>
<title>fonction include, passage de variables</title>
<programlisting>
{include file="header.tpl" title="Menu principal" table_bgcolor="#c0c0c0"}

{* Le corps du template vient ici *}

{include file="footer.tpl" logo="http://mon.domaine.com/logo.gif"}</programlisting>
</example>
			<para>
			Utilisez la syntaxe <link
			linkend="template.resources">ressource template</link> pour inclure
         des fichiers situés en dehors du répertoire $template_dir.
			</para>
<example>
<title>fonction include, exemple de ressource template</title>
<programlisting>
{* chemin absolu *}
{include file="/usr/local/include/templates/header.tpl"}

{* chemin absolu (même chose) *}
{include file="file:/usr/local/include/templates/header.tpl"}

{* chemin absolu windows (DOIT utiliser le préfixe "file:") *}
{include file="file:C:/www/pub/templates/header.tpl"}

{* inclusion d'une ressource template "db" *}
{include file="db:header.tpl"}</programlisting>
</example>
		</sect1>
		<sect1 id="language.function.include.php">
			<title>include_php</title>
            <informaltable frame="all">
                <tgroup cols="5">
                <colspec colname="param" align="center" />
                <colspec colname="type" align="center" />
                <colspec colname="required" align="center" />
                <colspec colname="default" align="center" />
                <colspec colname="desc" />
                <thead>
                    <row>
                        <entry>Nom attribut</entry>
                        <entry>Type</entry>
                        <entry>Requis</entry>
                        <entry>Defaut</entry>
                        <entry>Description</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>file</entry>
                        <entry>chaîne de caractère</entry>
                        <entry>oui</entry>
                        <entry><emphasis>n/a</emphasis></entry>
                        <entry>Le nom du fichier PHP à inclure</entry>
                    </row>
                    <row>
                        <entry>once</entry>
                        <entry>boléen</entry>
                        <entry>Non</entry>
                        <entry><emphasis>true</emphasis></entry>
                        <entry>Inclure plusieurs fois ou non le fichier PHP si
                        plusieurs demandes d'inclusions sont faites.</entry>
                    </row>
                    <row>
                        <entry>assign</entry>
                        <entry>chaîne de caractère</entry>
                        <entry>Non</entry>
                        <entry><emphasis>n/a</emphasis></entry>
                        <entry>le nom de la variable PHP dans laquelle la sortie
                        sera assignée plutôt que directement affichée.</entry>
                    </row>
                </tbody>
                </tgroup>
            </informaltable>
			<para>
			les balises include_php sont utilisées pour inclure directement
         un script PHP dans vos templates. Si "security" est activé, alors le script
         à exécuter doit être placé dans le chemin $trusted_dir. La balise
         include_php attends l'attribut "file", qui contient le chemin du
         fichier PHP à inclure, relatif à $trusted_dir, ou absolu.
			</para>
			<para>
			include_php est un moyen agréable pour gérer des "composants templates",
			tout en conservant le code PHP en dehors du template lui même.
			Supposons que vous ayez un template reprenant la navigation de votre
         site, elle même récupérée depuis une base de données. Vous pouvez
         conserver la logique du code PHP récupérant le contenu de la base dans
         un emplacement séparé, et l'inclure depuis votre template. Maintenant,
         vous pouvez utiliser ce template n'importe ou, sans vous inquiéter de
         savoir si les informations nécessaires ont bien étés assignées
         par l'application, avant la demande d'affichage.
			</para>
			<para>
			Par défaut, les fichiers PHP ne sont inclus qu'une seule fois, même si
         la demande d'inclusion survient plusieurs fois dans le template.
         Vous pouvez demander à ce que ce fichier soit inclus à chaque demande
         grâce à l'attribut <emphasis>once</emphasis>. Mettre l'attribut once à
         false aura pour effet d'inclure le script PHP à chaque fois que demandé
         dans le template.
			</para>
			<para>
			Vous pouvez donner une valeur à l'attribut optionnel
			<emphasis>assign</emphasis>, pour demander à la fonction
         <emphasis>include_php</emphasis> d'assigner la sortie du script PHP
         à la variable spécifiée plutôt que d'en afficher directement le résultat.
			</para>
			<para>
			L'objet Smarty est disponible en tant que $this dans le script PHP inclus.
			</para>
<example>
<title>fonction include_php</title>
<programlisting>
load_nav.php
-------------

&lt;?php

	// charge des variables depuis une base de données mysql et les assigne au template.
	require_once("MySQL.class.php");
	$sql = new MySQL;
	$sql->query("select * from site_nav_sections order by name",SQL_ALL);
	$this->assign('sections',$sql->record);

?&gt;


index.tpl
---------

{* chemin absolu, ou relatif à $trusted_dir *}
{include_php file="/path/to/load_nav.php"}

{foreach item="curr_section" from=$sections}
	&lt;a href="{$curr_section.url}"&gt;{$curr_section.name}&lt;/a&gt;&lt;br&gt;
{/foreach}</programlisting>
</example>
		</sect1>
		<sect1 id="language.function.insert">
			<title>insert</title>
            <informaltable frame="all">
                <tgroup cols="5">
                <colspec colname="param" align="center" />
                <colspec colname="type" align="center" />
                <colspec colname="required" align="center" />
                <colspec colname="default" align="center" />
                <colspec colname="desc" />
                <thead>
                    <row>
                        <entry>Nom attribut</entry>
                        <entry>Type</entry>
                        <entry>Requis</entry>
                        <entry>Defaut</entry>
                        <entry>Description</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>name</entry>
                        <entry>chaîne de caractères</entry>
                        <entry>Oui</entry>
                        <entry><emphasis>n/a</emphasis></entry>
                        <entry>le nom de la fonction insert (insert_name)</entry>
                    </row>
                    <row>
                        <entry>assign</entry>
                        <entry>chaîne de caractère</entry>
                        <entry>Non</entry>
                        <entry><emphasis>n/a</emphasis></entry>
                        <entry>Le nom de la variable qui recevra la sortie</entry>
                    </row>
                    <row>
                        <entry>script</entry>
                        <entry>chaîne de caractères</entry>
                        <entry>Non</entry>
                        <entry><emphasis>n/a</emphasis></entry>
                        <entry>Le nom du script PHP inclus avant que la fonction
                        insert ne soit appelée.</entry>
                    </row>
                    <row>
                        <entry>[var ...]</entry>
                        <entry>[var type]</entry>
                        <entry>Non</entry>
                        <entry><emphasis>n/a</emphasis></entry>
                        <entry>Variable à passer à la fonction insert</entry>
                    </row>
                </tbody>
                </tgroup>
            </informaltable>
			<para>
			Les balises insert fonctionnent à peu près comme les balises include,
         à l'exception que leur sortie n'est pas placée en cache lorsque
        <link linkend="caching">le cache [caching]</link> est activé.
         Les balises insert seront exécutées à chaque appel du template.
			</para>
            <para>
             Supposons que vous avez un template avec un emplacement
             pour un bandeau publicitaire en haut de page.
             Ce bandeau publicitaire peut contenir toutes sortes de contenus
             HTML, images, flash, etc. Nous ne pouvons pas placer du contenu
             statique à cet endroit. Nous ne voulons pas non plus que ce
             contenu fasse partie du cache. Arrive alors la balise insert.
             Le template connais #emplacement_bandeau# et #id_site# (récupérés
             depuis un fichier de configuration), et à besoin d'un appel de
             fonction pour récupérer le contenu du bandeau.
			</para>
<example>
<title>function insert</title>
<programlisting>
{* exemple de récupération d'un bandeau publicitaire *}
{insert name="getBanner" lid=#emplacement_bandeau# sid=#id_site#}</programlisting>
</example>
			<para>
			Dans cet exemple, nous utilisons le nom getBanner et lui passons les
         paramètres #emplacement_bandeau# et #id_site#. Smarty va rechercher une
         fonction appelée insert_getBanner () dans votre application PHP, et lui
         passer les valeurs #banner_location_id# et #site_id# comme premier
         paramètre, dans un tableau associatif. Tous les noms des fonctions insert
         de votre application doivent être prefixées de "insert_" pour remédier
         à d'éventuels conflits de nommage. Votre fonction insert_getBanner ()
         est supposée traiter les valeurs passées et retourner
         un résultat. Ces résultats sont affichés dans le template en lieu et
         place de la balise. Dans cet exemple, Smarty appellera cette fonction
         insert_getBanner(array("lid" => "12345","sid" => "67890")); et affichera
         le résultat retourné à la place de la balise insert.
			</para>
			<para>
			Si vous donnez une valeur à l'attribut "assign", la sortie de la balise
			insert sera assigné à une variable de template de ce nom au lieu d'être
         affichée	directement. NOTE: assigner la sortie à une variable n'est pas
         très utile lorsque le cache est activé.
			</para>
			<para>
			Si vous donnez une valeur à l'attribut "script", ce script PHP sera
         inclus (une seule fois) avant l'exécution de la fonction insert.
         Le cas peut survenir lorsque la fonction insert n'existe pas encore,
         et que le script PHP chargé de sa définission doit être inclus. Le
         chemin doit être absolu ou relatif à $trusted_dir.
         Lorsque "security" est actif, le script doit être situé
         dans $trusted_dir.
			</para>
			<para>
			L'objet Smarty est passé comme second argument. De cette façon, vous
         pouvez utiliser ou modifier des informations sur l'objet Smarty,
         directement depuis votre fonction d'insertion.
			</para>
			<note>
			<title>Note technique</title>
			<para>
            Il est possible d'avoir des portions de template qui ne soient pas
            gérables par le cache. Même si vous avez activé l'option
            <link linkend="caching">caching</link>, les balises insert
            ne feront pas partie du cache. Elles retourneront un contenu dynamique
            à chaque invocation de la page. Cette méthode est très pratique pour
            des éléments tels que les bandeaux publicitaires, les enquêtes,
            la météo, les résultats de recherche, retours utilisateurs, etc.
			</para>
			</note>
		</sect1>
		<sect1 id="language.function.if">
			<title>if,elseif,else</title>
			<para>
         l'instruction if dans Smarty dispose de la même flexibilité que l'instruction
         PHP du même nom, avec quelques fonctionnalités supplémentaires pour le
         moteur de template. Tous les <emphasis>if</emphasis> doivent être
         utilisés de pair avec un <emphasis>/if</emphasis>.
         <emphasis>else</emphasis> et <emphasis>elseif</emphasis> sont également
         des balises autorisées. "eq", "ne","neq", "gt", "lt", "lte", "le",
         "gte" "ge","is even","is odd", "is not	even","is not odd","not","mod",
         "div by","even by","odd	by","==","!=","&gt;", "&lt;","&lt;=","&gt;=" sont tous
         des opérateurs conditionnels valides, et doivent obligatoirement être
         séparés des autres éléments par des espaces.
			</para>
<example>
<title>Instruction if</title>
<programlisting>
{if $name eq "Fred"}
	Bienvenue, Monsieur.
{elseif $name eq "Wilma"}
	Bienvenue m'dame.
{else}
	Bienvenue, qui que vous soyez.
{/if}

{* Un exemple avec l'opérateur or *}
{if $name eq "Fred" or $name eq "Wilma"}
	...
{/if}

{* même chose que ci-dessus *}
{if $name == "Fred" || $name == "Wilma"}
	...
{/if}

{* l'exemple suivant NE fonctionne PAS, les opérateurs
   doivent être entourés d'espaces. *}
{if $name=="Fred" || $name=="Wilma"}
	...
{/if}


{* les parenthèses sont autorisées *}
{if ( $amount &lt; 0 or $amount &gt; 1000 ) and $volume &gt;= #minVolAmt#}
	...
{/if}

{* vous pouvez également faire appel aux fonctions PHP *}
{if count($var) gt 0}
	...
{/if}

{* teste si les valeurs sont paires(even) ou impaires(odd) *}
{if $var is even}
	...
{/if}
{if $var is odd}
	...
{/if}
{if $var is not odd}
	...
{/if}

{* teste si la variable est divisble par 4 *}
{if $var is div by 4}
	...
{/if}

{* teste si la variable est paire, par groupe de deux i.e.,
0=paire, 1=paire, 2=impaire, 3=impaire, 4=paire, 5=paire, etc. *}
{if $var is even by 2}
	...
{/if}

{* 0=paire, 1=paire, 2=paire, 3=impaire, 4=impaire, 5=impaire, etc. *}
{if $var is even by 3}
	...
{/if}</programlisting>
</example>
		</sect1>
		<sect1 id="language.function.ldelim">
			<title>ldelim,rdelim</title>
			<para>
			ldelim et rdelim sont utilisés pour afficher les délimiteurs en tant
         que tels, dans notre cas "{" ou "}". Le moteur de template tentera
         toujours d'interpréter le contenu entre les délimiteurs, c'est donc
         une façon d'afficher ces derniers sans interférer avec Smarty.
			</para>
<example>
<title>ldelim, rdelim</title>
<programlisting>
{* Affiche les délimiteurs de template *}

{ldelim}nomFonction{rdelim} est la façon dont sont appelées les fonctions dans Smarty !


SORTIE:

{nomFonction}  est la façon dont sont appelées les fonctions dans Smarty !</programlisting>
</example>
		</sect1>
		<sect1 id="language.function.literal">
			<title>literal</title>
			<para>
			Les balises "literal" permettent à un bloc de données d'être pris tel
			quel, sans qu'il ne soit interprété par Smarty. Très pratique lors
			de l'emplois d'éléments tels que javascript, acolades et autres
         qui peuvent confondre le moteur de template. Tout le contenu situé
         entre les balises {literal}{/literal} ne sera pas interprété, et
         affiché comme du contenu statique.
			</para>
<example>
<title>balises literal</title>
<programlisting>
{literal}
	&lt;script language=javascript&gt;

        	&lt;!--
                	function isblank(field) {
                	if (field.value == '') 
                        	{ return false; }
                	else
                        	{
                        	document.loginform.submit();
                        	return true;
                        	}
                	}
        	// --&gt;

	&lt;/script&gt;
{/literal}</programlisting>
</example>
		</sect1>
		<sect1 id="language.function.php">
			<title>php</title>
			<para>
			Les balises PHP permettent de rajouter du code PHP directement dans le
         template. Ils ne seront pas ignorés, quelle que soit la valeur de <link
			linkend="variable.php.handling">$php_handling</link>. Pour les
         utilisateurs avancés seulement, son utilisation n'est normalement pas
         nécessaire.
			</para>
<example>
<title>balises php</title>
<programlisting>
{php}
		// inclusion directe d'un script PHP
		// depuis le template.
		include("/path/to/display_weather.php");
{/php}</programlisting>
</example>
		</sect1>
		<sect1 id="language.function.section">
			<title>section,sectionelse</title>
            <informaltable frame="all">
                <tgroup cols="5">
                <colspec colname="param" align="center" />
                <colspec colname="type" align="center" />
                <colspec colname="required" align="center" />
                <colspec colname="default" align="center" />
                <colspec colname="desc" />
                <thead>
                    <row>
                        <entry>Nom attribut</entry>
                        <entry>Type</entry>
                        <entry>Requis</entry>
                        <entry>Defaut</entry>
                        <entry>Description</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>name</entry>
                        <entry>chaîne de caractère</entry>
                        <entry>Oui</entry>
                        <entry><emphasis>n/a</emphasis></entry>
                        <entry>Le nom de la section</entry>
                    </row>
                    <row>
                        <entry>loop</entry>
                        <entry>[$nom_variable]</entry>
                        <entry>Oui</entry>
                        <entry><emphasis>n/a</emphasis></entry>
                        <entry>le nom de la variable qui détermine le nombre de
                        fois que la boucle sera exécutée.
                        </entry>
                    </row>
                    <row>
                        <entry>start</entry>
                        <entry>entier</entry>
                        <entry>Non</entry>
						<entry><emphasis>0</emphasis></entry>
                  <entry>La position de l'index ou la section commencera son
                  parcours. Si la valeur donnée est négative, la position de
                  départ est calculée depuis la fin du tableau. Par exemple,
                  s'il existe 7 valeurs dans le tableau à parcourir et que start
                  est à -2, l'index de départ sera 5. Les valeurs incorrectes
                  (en dehors de la portée du tableau) sont automatiquements
                  tronquées à la valeur correcte la plus proche.</entry>
                    </row>
                    <row>
                        <entry>step</entry>
                        <entry>entier</entry>
                        <entry>Non</entry>
                        <entry><emphasis>1</emphasis></entry>
						<entry>La valeur du pas qui sera utilisé pour parcourir le
                  tableau.Par exemple, step=2 parcourera les indices
						0,2,4, etc. Si step est négatif, le tableau sera parcouru en sens
                  inverse.</entry>
                    </row>
                    <row>
                        <entry>max</entry>
                        <entry>entier</entry>
                        <entry>Non</entry>
                        <entry><emphasis>1</emphasis></entry>
						<entry>Définit le nombre maximum de fois que le tableau sera
                  parcouru.</entry>
                    </row>
                    <row>
                        <entry>show</entry>
                        <entry>booléen</entry>
                        <entry>Non</entry>
                        <entry><emphasis>true</emphasis></entry>
                        <entry>Détermine s'il est nécessaire d'afficher la
                        section ou non.</entry>
                    </row>
                </tbody>
                </tgroup>
            </informaltable>
			<para>
            Les balises <emphasis>section</emphasis> sont utilisées pour
            parcourir un tableau de données. Toutes les balises
            <emphasis>section</emphasis> doivent être utilisées de paire avec
            les balises <emphasis>/section</emphasis>. Les paramètres requis
            sont <emphasis>name</emphasis> et <emphasis>loop</emphasis>.
            Le nom de la section est, selon votre choix, composé de lettres,
            chiffres et underscores. Les sections peuvent être imbriquées,
            mais leurs noms doivent être uniques. La variable de parcours
            (généralement un tableau de données) détermine le nombre de fois
            que la section sera parcourue. Lorsque l'on affiche une variable
            dans une section, le nom de la section doit précéder
            la variable entre crochets. <emphasis>sectionelse</emphasis>
            est exécuté lorsqu'aucune valeur n'est trouvée dans la variable à
            parcourir.
			</para>
<example>
<title>section</title>
<programlisting>

{* Cet exemple va afficher toutes les valeurs du tableau $custid *}
{section name=client loop=$custid}
	id: {$custid[client]}&lt;br&gt;
{/section}

SORTIE:

id: 1000&lt;br&gt;
id: 1001&lt;br&gt;
id: 1002&lt;br&gt;</programlisting>
</example>

<example>
<title>section, variable de parcours</title>
<programlisting>
{* La variable de parcours détermine uniquement le nombre de fois que nous allons
   rentrer dans la boucle. Vous pouvez accéder à toutes les variables du template
   lorsque vous êtes dans une section. Cet exemple part du principe que
   $idClient, $noms et $adresses sont tous des tableaux qui contiennent
   autant de valeurs les uns que les autres.*}
{section name=client loop=$custid}
	id: {$idClient[client]}&lt;br&gt;
	nom: {$noms[client]}&lt;br&gt;
	addresse: {$addresses[client]}&lt;br&gt;
	&lt;p&gt;
{/section}


SORTIE:

id: 1000&lt;br&gt;
nom: John Smith&lt;br&gt;
addresse: 253 N 45th&lt;br&gt;
&lt;p&gt;
id: 1001&lt;br&gt;
nom: Jack Jones&lt;br&gt;
addresse: 417 Mulberry ln&lt;br&gt;
&lt;p&gt;
id: 1002&lt;br&gt;
nom: Jane Munson&lt;br&gt;
addresse: 5605 apple st&lt;br&gt;
&lt;p&gt;</programlisting>
</example>

<example>
<title>nom de section</title>
<programlisting>
{* Le nom de la section peut être ce que vous voulez,
   et est utilisé pour référencer les données depuis la section. *}
{section name=monTableau loop=$idClient}
	id: {$idCLient[monTableau]}&lt;br&gt;
	name: {$noms[monTableau]}&lt;br&gt;
	address: {$addresses[monTableau]}&lt;br&gt;
	&lt;p&gt;
{/section}</programlisting>
</example>

<example>
<title>sections imbriquées</title>
<programlisting>
{* Les sections peuvent être imbriquées à un nombre de niveaux illimité.
   Grâce aux sections imbriquées, vous pouvez accéder à des structures de données
   complexes, comme des tableaux multi-dimentionnels. Dans cet exemple,
   $type_contact[client] est un tableau de type de contact pour le client
   courant. *}
{section name=client loop=$custid}
	id: {$idClient[client]}&lt;br&gt;
	nom: {$nom[client]}&lt;br&gt;
	addresse: {$addresse[client]}&lt;br&gt;
	{section name=contact loop=$type_contact[client]}
		{$type_contact[client][contact]}: {$info_contact[client][contact]}&lt;br&gt;
	{/section}
	&lt;p&gt;
{/section}


SORTIE:

id: 1000&lt;br&gt;
nom: John Smith&lt;br&gt;
addresse: 253 N 45th&lt;br&gt;
telephone: 555-555-5555&lt;br&gt;
telephone portable: 555-555-5555&lt;br&gt;
e-mail: john@mydomain.com&lt;br&gt;
&lt;p&gt;
id: 1001&lt;br&gt;
nom: Jack Jones&lt;br&gt;
addresse: 417 Mulberry ln&lt;br&gt;
telephone: 555-555-5555&lt;br&gt;
telephone portable: 555-555-5555&lt;br&gt;
e-mail: jack@mydomain.com&lt;br&gt;
&lt;p&gt;
id: 1002&lt;br&gt;
nom: Jane Munson&lt;br&gt;
addresse: 5605 apple st&lt;br&gt;
telephone: 555-555-5555&lt;br&gt;
telephone portable: 555-555-5555&lt;br&gt;
e-mail: jane@mydomain.com&lt;br&gt;
&lt;p&gt;</programlisting>
</example>

<example>
<title>Sections et tableaux associatifs</title>
<programlisting>
{* Exemple d'affichage d'un tableau associatif dans une section *}
{section name=client loop=$contacts}
	nom: {$contacts[client].name}&lt;br&gt;
	telephone: {$contacts[client].home}&lt;br&gt;
	portable: {$contacts[client].cell}&lt;br&gt;
	e-mail: {$contacts[client].email}&lt;p&gt;
{/section}


SORTIE:

nom: John Smith&lt;br&gt;
telephone: 555-555-5555&lt;br&gt;
portable: 555-555-5555&lt;br&gt;
e-mail: john@mydomain.com&lt;p&gt;
nom: Jack Jones&lt;br&gt;
telephone: 555-555-5555&lt;br&gt;
portable: 555-555-5555&lt;br&gt;
e-mail: jack@mydomain.com&lt;p&gt;
nom: Jane Munson&lt;br&gt;
telephone: 555-555-5555&lt;br&gt;
portable: 555-555-5555&lt;br&gt;
e-mail: jane@mydomain.com&lt;p&gt;</programlisting>
</example>



<example>
<title>sectionelse</title>
<programlisting>
{* sectionelse est exécuté s'il n'existe aucune valeur dans idClient *}
{section name=client loop=$idClient}
	id: {$idClient[client]}&lt;br&gt;
{sectionelse}
	Aucune valeur dans $idClient.
{/section}</programlisting>
</example>
		<para>
		Les sections ont leur propre variable de gestion des propriétés.
		Elles sont de la forme: {$smarty.section.nomSection.nomVariable}
		</para>
		<para>
		NOTE: Depuis Smarty 1.5.0, la syntaxe pour les propiétés des sections
      a été changée de {%sectionname.varname%} à
      {$smarty.section.nomSection.nomVariable}. L'ancienne syntaxe est toujours
      supportée, mais vous ne verrez que des exemples avec la nouvelle syntaxe
      dans le manuel.
		</para>
			<sect2 id="section.property.index">	
			<title>index</title>
			<para>
			Index est utilisé pour afficher l'index de parcours courant, commence par
			0 (ou l'attribut start), et s'incrémente de 1 (ou de la valeur
         de l'attribut step).
			</para>
			<note>
				<title>Note technique</title>
				<para>
				Si les attributs step et start ne sont pas modifiés, alors index
            fonctionne de la même façon que iteration, à l'exception qu'il commence
            par 0 plutôt que par 1.
				</para>
			</note>
	<example>
	<title>propriété de section index</title>
	<programlisting>
	{section name=client loop=$idClient}
	{$smarty.section.client.index} id: {$idClient[client]}&lt;br&gt;
	{/section}


	SORTIE:

	0 id: 1000&lt;br&gt;
	1 id: 1001&lt;br&gt;
	2 id: 1002&lt;br&gt;
</programlisting>
	</example>
			</sect2>
			<sect2 id="section.property.index.prev">	
			<title>index_prev</title>
			<para>
			index_prev est utilisé pour afficher l'index de parcours
         précédent de la boucle. Au premier passage, il vaut -1.
			</para>
	<example>
	<title>propriété de section index_prev</title>
	<programlisting>
	{section name=client loop=$custid}
	{$smarty.section.client.index} id: {$idClient[client]}&lt;br&gt;
	{* Pour votre information, $idClient[client.index] and $idClient[client] sont identiques *}
	{if $idClient[client.index_prev] ne $idClient[client.index]}
    	L'id du client à été modifié&lt;br&gt;
	{/if}
	{/section}


	SORTIE:

	0 id: 1000&lt;br&gt;
    	L'id du client à été modifié&lt;br&gt;
	1 id: 1001&lt;br&gt;
    	L'id du client à été modifié&lt;br&gt;
	2 id: 1002&lt;br&gt;
    	L'id du client à été modifié&lt;br&gt;
</programlisting>
	</example>
			</sect2>
			<sect2 id="section.property.index.next">
			<title>index_next</title>
			<para>
			index_next est utilisé pour afficher la valeur théorique suivante de
			index. Dans la dernière boucle, cela reste la valeur incrémentée,
			qui respecte l'attribut step si donné.
			</para>
	<example>
	<title>propriété de section index_next</title>
	<programlisting>
	{section name=client loop=$idClient}
	{$smarty.section.client.index} id: {$idClient[client]}&lt;br&gt;
	{* Pour votre information, $idClient[client.index] and $idClient[client] sont identiques *}
	{if $idClient[client.index_next] ne $idClient[client.index]}
    	L'id du client va changer&lt;br&gt;
	{/if}
	{/section}


	SORTIE:

	0 id: 1000&lt;br&gt;
    	L'id du client va changer&lt;br&gt;
	1 id: 1001&lt;br&gt;
    	L'id du client va changer&lt;br&gt;
	2 id: 1002&lt;br&gt;
    	L'id du client va changer&lt;br&gt;
</programlisting>
	</example>
			</sect2>
			<sect2 id="section.property.iteration">
			<title>iteration</title>
			<para>
			iteration est utilisé pour afficher la valeur courante de l'iteration.
			</para>
			<para>
			NOTE: Cette valeur n'est pas affectée par les attributs start, step et
			max, à l'inverse de la propriété index. L'itération commence par
			1 et non par 0 (comme le fait index). rownum est un alias de iteration,
			ils fonctionnent de la même façon.
			</para>
	<example>
	<title>propriété iteration de section</title>
	<programlisting>
	{section name=client loop=$idClient start=5 step=2}
	Iteration courante: {$smarty.section.client.iteration}&lt;br&gt;
	{$smarty.section.client.index} id: {$idClient[client]}&lt;br&gt;
	{* Pour votre information, $idClient[client.index] and $idClient[client] sont identiques *}
	{if $idCLient[client.index_next] ne $idClient[client.index]}
    	L'id du client va changer&lt;br&gt;
	{/if}
	{/section}


	SORTIE:

	Iteration courante: 1
	5 id: 1000&lt;br&gt;
    	L'id du client va changer&lt;br&gt;
	Iteration courante: 2
	7 id: 1001&lt;br&gt;
    	L'id du client va changer&lt;br&gt;
	Iteration courante: 3
	9 id: 1002&lt;br&gt;
    	L'id du client va changer&lt;br&gt;
</programlisting>
	</example>
			</sect2>
			<sect2 id="section.property.first">
			<title>first</title>
			<para>
			first est à true lorsque la section est parcouru pour la première fois.
			</para>
	<example>
	<title>propriété first de la section</title>
	<programlisting>
	{section name=client loop=$idClient}
	{if $smarty.section.client.first}
    	&lt;table&gt;
	{/if}

	&lt;tr&gt;&lt;td&gt;{$smarty.section.client.index} id:
        	{$idClient[client]}&lt;/td&gt;&lt;/tr&gt;

	{if $smarty.section.client.last}
    	&lt;/table&gt;
	{/if}
	{/section}


	SORTIE:

	&lt;table&gt;
	&lt;tr&gt;&lt;td&gt;0 id: 1000&lt;/td&gt;&lt;/tr&gt;
	&lt;tr&gt;&lt;td&gt;1 id: 1001&lt;/td&gt;&lt;/tr&gt;
	&lt;tr&gt;&lt;td&gt;2 id: 1002&lt;/td&gt;&lt;/tr&gt;
	&lt;/table&gt;
</programlisting>
	</example>
			</sect2>
			<sect2 id="section.property.last">
			<title>last</title>
			<para>
			last est à true lorsque la section est parcourue pour la dernière fois.
			</para>
	<example>
	<title>Propriété last de section</title>
	<programlisting>
	{section name=client loop=$idClient}
	{if $smarty.section.client.first}
    	&lt;table&gt;
	{/if}

	&lt;tr&gt;&lt;td&gt;{$smarty.section.client.index} id:
        	{$idClient[client]}&lt;/td&gt;&lt;/tr&gt;

	{if $smarty.section.client.last}
    	&lt;/table&gt;
	{/if}
	{/section}


	SORTIE:

	&lt;table&gt;
	&lt;tr&gt;&lt;td&gt;0 id: 1000&lt;/td&gt;&lt;/tr&gt;
	&lt;tr&gt;&lt;td&gt;1 id: 1001&lt;/td&gt;&lt;/tr&gt;
	&lt;tr&gt;&lt;td&gt;2 id: 1002&lt;/td&gt;&lt;/tr&gt;
	&lt;/table&gt;
</programlisting>
	</example>
			</sect2>
			<sect2 id="section.property.rownum">	
			<title>rownum</title>
			<para>
			rownum, utilisé pour afficher la valeur courante de l'itération,
			commence par 1. C'est un alias de iteration, ils fonctionnent de façon
			identique.
			</para>
	<example>
	<title>propriété rownum de section</title>
	<programlisting>
	{section name=client loop=$idClient}
	{$smarty.section.client.rownum} id: {$idClient[client]}&lt;br&gt;
	{/section}


	SORTIE:

	1 id: 1000&lt;br&gt;
	2 id: 1001&lt;br&gt;
	3 id: 1002&lt;br&gt;
</programlisting>
	</example>
			</sect2>
			<sect2 id="section.property.loop">	
			<title>loop</title>
			<para>
			loop est utilisé pour afficher la dernière valeur de index que cette
         section a utilisé. Peut être utilisé dans ou en dehors de la section.
			</para>
	<example>
	<title>Propriété de section index</title>
	<programlisting>
	{section name=client loop=$idClient}
	{$smarty.section.client.index} id: {$idClient[client]}&lt;br&gt;
	{/section}

	Il y eu {$smarty.section.client.loop} clients d'affichés.

	SORTIE:

	0 id: 1000&lt;br&gt;
	1 id: 1001&lt;br&gt;
	2 id: 1002&lt;br&gt;

	il y eu 3 clients d'affichés.
</programlisting>
	</example>
			</sect2>
			<sect2 id="section.property.show">	
			<title>show</title>
			<para>
        	<emphasis>show</emphasis> est utilisé comme paramètre de section.
        	<emphasis>show</emphasis> est une valeur booléenne, true ou false.
          Si show est à "false", la section ne sera pas affichée. Si un
          sectionelse est présent, elle sera affiché.
			</para>
	<example>
	<title>section, attribut show</title>
	<programlisting>
	{* $show_client_info a pu être passé par le script PHP,
	 pour déterminer si oui ou non on souhaite afficher la section *}
	{section name=client loop=$idClient show=$show_client_info}
	{$smarty.section.client.rownum} id: {$idClient[client]}&lt;br&gt;
	{/section}

	{if $smarty.section.client.show}
	la section à été affichée.
	{else}
	la section n'a pas été affichée.
	{/if}


	SORTIE:

	1 id: 1000&lt;br&gt;
	2 id: 1001&lt;br&gt;
	3 id: 1002&lt;br&gt;

	la section à été affichée.
</programlisting>
	</example>
			</sect2>
			<sect2 id="section.property.total">	
			<title>total</title>
			<para>
			total est utilisé pour afficher le nombre d'itération que la section
			va exécuter. Peut être utilisé dans ou en dehors de la section.
			</para>
	<example>
	<title>section, propriété total</title>
	<programlisting>
	{section name=client loop=$idClient step=2}
	{$smarty.section.client.index} id: {$idClient[client]}&lt;br&gt;
	{/section}

	Il y eu {$smarty.section.client.total} clients affichés.

	SORTIE:

	0 id: 1000&lt;br&gt;
	2 id: 1001&lt;br&gt;
	4 id: 1002&lt;br&gt;

	Il y eu 3 clients affichés.
</programlisting>
	</example>
			</sect2>
		</sect1>
		<sect1 id="language.function.strip">
			<title>strip</title>
			<para>
			Il est fréquent que les designers web rencontrent des problèmes
			dus aux espaces et retours chariots, qui affectent le rendu HTML
			("fonctionnalités" des navigateurs), les obligeant à coller les
			balises les unes aux autres. Cette solution rend généralement le
         code illisible et impossible à maintenir.
			</para>
			<para>
			Tout contenu situé entre les balises {strip}{/strip} se verra
         allégé des espaces superflus et des retours chariots en début ou en fin
         de ligne, avant qu'il ne soit affichés. De la sorte, vous pouvez
         conserver vos templates lisibles, sans vous soucier des effets
         indésirables que peuvent apporter les espaces superflus.
			</para>
			<note>
			<title>Note technique</title>
			<para>
			{strip}{/strip} n'affecte en aucun cas le contenu des variables de
         template. Voir le  <link linkend="language.modifier.strip">modificateur
         strip</link> pour un rendu identique pour les variables.
			</para>
			</note>
<example>
<title>balises strip</title>
<programlisting>
{* la suite sera affichée sur une seule ligne *}
{strip}
&lt;table border=0&gt;
	&lt;tr&gt;
		&lt;td&gt;
			&lt;A HREF="{$url}"&gt;
			&lt;font color="red"&gt;Un test&lt;/font&gt;
			&lt;/A&gt;
		&lt;/td&gt;
	&lt;/tr&gt;
&lt;/table&gt;
{/strip}


SORTIE:

&lt;table border=0&gt;&lt;tr&gt;&lt;td&gt;&lt;A HREF="http://mon.domaine.com"&gt;&lt;font color="red"&gt;Un test&lt;/font&gt;&lt;/A&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</programlisting>
</example>
		<para>
		Notez que dans l'exemple ci-dessus, toutes les lignes commencent et
      se terminent par des	balises HTML. Sachez que si vous avez du texte
      en début ou en fin de ligne dans des balises strip, ce dernier sera collé
      au suivant/précédent et risque de ne pas être affiché selon
      l'effet désiré.
		</para>
		</sect1>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->