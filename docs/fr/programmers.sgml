  <part id="smarty.for.programmers">
   <title>Smarty pour les programmeurs</title>


	<chapter id="smarty.constants">
	 <title>Constantes</title>
	 <para></para>

	 <sect1 id="constant.smarty.dir">
      <title>SMARTY_DIR</title>
      <para>
      Il doit s'agir du chemin complet du rTpertoire oú
      se trouvent les fichiers classes de Smarty.
      S'il n'est pas dTfini, Smarty essaiera alors d'en
      dTterminer automatiquement la valeur.
      S'il est dTfini, le chemin doit se terminer par un slash.
      </para>

      <example>
       <title>SMARTY_DIR</title>
       <programlisting>
// dTfinit le chemin du rTpertoire de Smarty
define("SMARTY_DIR","/usr/local/lib/php/Smarty/");

require_once(SMARTY_DIR."Smarty.class.php");</programlisting>
      </example>
	 </sect1>
	</chapter>

    <chapter id="api.variables">
     <title>Variables</title>

     <sect1 id="variable.template.dir">
      <title>$template_dir</title>
      <para>
      C'est le nom par dTfaut du rTpertoire des templates.
      Si vous ne spTcifiez aucun chemin lors de l'utilisation de templates, Smarty
      les cherchera a cet emplacement.
      Par dTfaut, il s'agit de "./templates", ce qui signifie
      qu'il va chercher le rTpertoire templates
      dans le rTpertoire oú se trouve le script PHP en cours d'exTcution.
      </para>

	   <note>
		   <title>Note technique</title>
         <para>
         Il n'est pas conseillT de mettre ce rTpertoire
         dans l'arborescence Web.
         </para>
	  </note>
     </sect1>		
     <sect1 id="variable.compile.dir">
      <title>$compile_dir</title>
      <para>
      C'est le nom du rTpertoire oú se trouvent les templates
      compilTs. Par dTfaut, il s'agit de "./templates_c",
      ce qui signifie que Smarty va chercher ce rTpertoire
      dans le mOme rTpertoire que le script PHP en cours d'exTcution.
      </para>
	 <note>
	 <title>Note technique</title>
	 <para>
	 Ce rTglage doit Otre soit un chemin absolu, soit un chemin
	 relatif. include_path n'est pas utilisT pour Tcrire des fichiers.
	 </para>
	 </note>
	 <note>
	 <title>Note technique</title>
	 <para>
	 Il n'est pas conseillT de mettre ce rTpertoire
    sous la racine de l'arborescence Web.
	 </para>
	 </note>
     </sect1>
     <sect1 id="variable.config.dir">
      <title>$config_dir</title>
      <para>
      Il s'agit du rTpertoire utilisT pour stocker les
      fichiers de configuration utilisTs dans les templates.
      La valeur par dTfaut est "./configs", ce qui signifie
      que Smarty va chercher ce rTpertoire
      dans le mOme rTpertoire que le script PHP qui s'exTcute.
      </para>
	 <note>
	 <title>Note technique</title>
	 <para>
       Il n'est pas conseillT de mettre ce rTpertoire
      sous la racine de l'arborescence Web.
    </para>
	 </note>
     </sect1>
     <sect1 id="variable.plugins.dir">
      <title>$plugins_dir</title>
      <para>
      Ce sont les rTpertoire dans lesquels Smarty ira chercher les plugins
      dont il a besoin. La valeur par dTfaut est "plugins" sous le
      rTpertoire SMARTY_DIR. Si vous donnez un chemin relatif, Smarty
      regardera d'abord relativement au SMARTY_DIR, puis relativement au rtc (rTpertoire
      de travail courant), puis relativement a chaque entrTe de votre rTpertoire
      d'inclusion PHP.
      </para>
	  <note>
	  <title>Note technique</title>
	  <para>
	  Pour des raisons de performances, ne rTglez pas votre plugins_dir
	  pour qu'il utilise votre include_path PHP. Utilisez un
	  chemin absolu ou un chemin relatif a SMARTY_DIR ou au rtc.
	  </para>
	  </note>
     </sect1>
     <sect1 id="variable.debugging">
      <title>$debugging</title>
      <para>
      Cela active la
      <link
        linkend="chapter.debugging.console">console de dTbogage</link>.
      La console est une fenOtre javascript qui vous informe des templates
      inclus et des variables assignTes dans la page courante.
      </para>
     </sect1>
     <sect1 id="variable.debug.tpl">
      <title>$debug_tpl</title>
      <para>
      C'est le nom du fichier template utilisT pour la
      console de dTbuggage. Par dTfaut debug.tpl, il se situe dans <link
	   linkend="constant.smarty.dir">SMARTY_DIR</link>
      </para>
     </sect1>
     <sect1 id="variable.debugging.ctrl">
      <title>$debugging_ctrl</title>
      <para>
      Cela permet d'avoir diffTrents moyens pour activer
      le dTbogage. URL signifie que si SMARTY_DEBUG se
      trouve dans QUERY_STRING, le dTbuggage
      est activT a l'invocation du script. Si $debugging
      est a vrai, cette valeur est sans effet.
      </para>
     </sect1>
     <sect1 id="variable.global.assign">
      <title>$global_assign</title>
      <para>
      C'est une liste de variable qui sont toujours
      implicitement assignTes au moteur de templates.
      Ceci est commode pour rendre des variables globales
      ou des variables du serveur accessibles a tous les templates
      plut(t que de devoir les assigner a la main. Chaque TlTment
      de $global_assign doit Otre soit le nom de la variable
      globale, soit une paire clef/valeur, oú clef est le
      nom du tableau global et valeur le tableau de variable
      assignTes depuis ce tableau global.
      $SCRIPT_NAME est globalement assignT par dTfaut depuis
      $HTTP_SERVER_VARS.
      </para>
	 <note>
	 <title>Note technique</title>
	 <para>
	 On peut accTder aux variables du serveur avec la variable
	 $smarty, par exemple {$smarty.server.SCRIPT_NAME}.
	 Se reporter a la section sur la variable
	 <link linkend="language.variables.smarty">$smarty</link>.
	 </para>
	 </note>
     </sect1>
     <sect1 id="variable.undefined">
      <title>$undefined</title>
      <para>
      Cela rFgle la valeur de $undefined, null par dTfaut.
      N'est actuellement utilisT que pour initialiser
      des variables non-dTfinies dans $global_assign a des
      valeurs par dTfaut.
      </para>
     </sect1>
     <sect1 id="variable.autoload.filters">
      <title>$autoload_filters</title>
      <para>
      Si vous dTsirez charger des filtres a chaque invocation
      de templates, vous pouvez le spTcifier en utilisant cette
      variable. Les types de filtres et les valeurs sont des
      tableaux comportant le nom des filtres.
       <informalexample>
        <programlisting>
$smarty-&gt;autoload_filters = array('pre' =&gt; array('trim', 'stamp'),
                                  'output' => array('convert')); 
        </programlisting>
       </informalexample> 
      </para>
     </sect1>
     <sect1 id="variable.compile.check">
      <title>$compile_check</title>
      <para>
      A chaque invocation de l'application PHP, Smarty fait
      un test pour voir si le template courant a TtT modifiT
      (date de derniFre modification diffTrente) depuis sa
      derniFre compilation. S'il a changT, le template est recompilT.
      Si le template n'a pas encore TtT compilT, il le sera
      quelle que soit la valeur ce rTglage.
      Par dTfaut cette valeur est a vrai. Quand
      une application est mise en production (les templates
      ne changent plus), cette vTrification n'est pas nTcessaire.
      Assurez-vous de mettre $compile_check a "false" pour des performances
      maximales. Notez que si vous mettez ce paramFtre a "false" et qu'un
      template est modifiT, vous ne verrez *pas* le changement
      car le template ne sera *pas* recompilT. Si le processus de cache
      est activT et que $compile_check l'est aussi, alors les fichiers
      du cache seront regTnTrTs si un template concernT ou un fichier de
      configuration concernT est modifiT. Voir aussi <link
	   linkend="variable.force.compile">$force_compile</link> ou <link
	   linkend="api.clear.compiled.tpl">clear_compiled_tpl</link>.
      </para>

     </sect1>
     <sect1 id="variable.force.compile">
      <title>$force_compile</title>
      <para>
      Cela oblige Smarty a (re)compiler les templates a chaque
      invocation. Ce rTglage supplante $compile_check. Par dTfaut, il
      est dTsactivT. Ceci est commode pour le dTveloppement et le
      dTbogage mais ne devrait jamais Otre utilisT dans un environnment
      de production. Si le systFme de cache est actif, les
      fichiers du cache seront regTnTrTs a chaque appel.
      </para>
     </sect1>
     <sect1 id="variable.caching">
      <title>$caching</title>
      <para>
      Ce paramFtre demande a Smarty de mettre ou non en cache la sortie des
      templates.
      Par dTfaut ce rTglage est a 0 (dTsactivT). Si vos templates
      gTnFrent du contenu redondant, il est conseillT d'activer le
      cache. Cela permettra un gain de performance consTquent.
      Vous pouvez aussi avoir de nombreux fichiers de cache pour un mOme template.
      Une valeur de 1 ou 2 active le cache. 1 indique a Smarty d'utiliser
      la variable $cache_lifetime pour dTterminer si le fichier de cache a expirT.
      Une valeur de 2 indique a Smarty d'utiliser la valeur
      $cache_lifetime spTcifiTe a la gTnTration du cache. Ainsi vous pouvez rTgler
      la durTe de vie d'un fichier de cache avant de rTcupTrer le template pour avoir
      un certain contr(le quand ce fichier en particulier expire. Voir
      aussi <link linkend="api.is.cached">is_cached</link>.
      </para>
      <para>
      Si $compile_check est actif, le contenu du cache sera regTnTrT
      si un des templates ou un des fichiers de configuration qui fait partie
      de ce fichier de cache a TtT modifiT. Si $force_compile est actif, le contenu
      du cache est toujours regTnTrT.
      </para>
     </sect1>
     <sect1 id="variable.cache.dir">
      <title>$cache_dir</title>
      <para>
      Il s'agit du nom du rTpertoire oú les caches des templates
      sont stockTs. Par dTfaut il s'agit de "./cache", ce qui signifie
      que Smarty va chercher ce rTpertoire
      dans le mOme rTpertoire que le script PHP en cours d'exTcution.
      </para>
	 <note>
	 <title>Note technique</title>
	 <para>
       Ce rTglage doit Otre soit un chemin absolu, soit un chemin
	 relatif. include_path n'a aucune influence lors de l'Tcriture des fichiers.
      </para>
	  </note>
	  <note>
		  <title>Technical Note</title>
		  <para>
         Il n'est pas conseillT de mettre ce rTpertoire
         dans l'arborescence Web.
    	  </para>
	  </note>
     </sect1>
     <sect1 id="variable.cache.lifetime">
      <title>$cache_lifetime</title>
      <para>
      Il s'agit de la durTe en secondes pendant laquelle un cache de template
      est valide. Une fois cette durTe dTpassTe, le cache est regTnTrT.
      $caching doit Otre a "true" pour que $cache_lifetime ait une
      quelconque utilitT. Avec une valeur de -1, le cache n'expire jamais.
      Avec une valeur de 0, le cache est toujours regTnTrT (utile
      a des fins de tests seulement. Une meilleure faton de dTsactiver
      le cache est de mettre <link
	   linkend="variable.caching">$caching</link> a "false").
      </para>
      <para>
      Si <link linkend="variable.force.compile">$force_compile</link> est
      activT, les fichiers du cache seront regTnTrTs a chaque fois,
      dTsactivant ainsi le cache. Vous pouvez effacer tous les fichiers du cache
      avec la function
      <link linkend="api.clear.all.cache">clear_all_cache()</link>
      ou de faton individuelle (ou groupTe)
      avec la fonction <link
	   linkend="api.clear.cache">clear_cache()</link>.
      </para>
	  <note>
	  <title>Note technique</title>
	  <para>
	  Si vous souhaitez donner a certains templates leur propre durTe de vie
	  en cache, vous pouvez le faire en rTglant
	  <link linkend="variable.caching">$caching</link> a 2,
	  puis $cache_lifetime a une unique valeur juste avant d'appeler
	  display ou fetch().
	  </para>
	  </note>
     </sect1>
     <sect1 id="variable.cache.handler.func">
      <title>$cache_handler_func</title>
      <para>
      Vous pouvez utiliser votre propre fonction de gestion du cache plut(t que
      d'utiliser celle livrTe avec Smarty.
      RTfTrez-vous a la section sur la fonction de gestion de cache
      personnalisTe pour plus de dTtails.
      </para>
     </sect1>
     <sect1 id="variable.cache.modified.check">
      <title>$cache_modified_check</title>
      <para>
      Si cette variable est a vrai, Smarty respectera l'en-tOte
      If-Modified-Since envoyT par le client. Si la date de derniFre
      modification du fichier de cache n'a pas changT depuis la derniFre
      visite, alors un en-tOte "304 Not Modified" sera envoyT a la place
      du contenu. Cela ne fonctionne qu'avec du contenu mis en cache hors de la
      balise <command>insert</command>.
      </para>
     </sect1>
     <sect1 id="variable.config.overwrite">
      <title>$config_overwrite</title>
      <para>
      Si cette variable est a vrai, les variables lues dans les fichiers
      de configuration peuvent s'Tcraser entre elles. Sinon les variables
      seront mises dans un tableau. TrFs utile si vous voulez stocker
      des tableaux de donnTes dans des fichiers de configuration, listez
      simplement chaque TlTment plusieurs fois. Mise a faux par dTfaut.
      </para>
     </sect1>
     <sect1 id="variable.config.booleanize">
      <title>$config_booleanize</title>
      <para>
      Si cette variable est a vrai, les valeurs on/true/yes et off/false/no
      dans les fichiers de configuration sont automitiquement converties
      en boolTen. De cette faton vous pouvez utiliser ces valeurs dans le
      template de la faton suivante : {if #foobar#} ... {/if}. Si foobar
      est a on, true ou yes, l'instruction {if} sera exTcutTe. vrai
      par dTfaut.
      </para>
     </sect1>
     <sect1 id="variable.config.read.hidden">
      <title>$config_read_hidden</title>
      <para>
      Si cette variable est a vrai, les sections cachTs (dont les noms
      commencent par un point) dans les fichiers de configuration peuvent
      Otre lues depuis les templates. On laisse habituellement cela a faux, de
      cette faton vous pouvez stocker des donnTes sensibles dans les fichiers
      de configuration, comme par exemple des paramFtres de base de donnTes,
      sans vous soucier de la faton dont les templates les chargent.
      Mise a faux par dTfaut.
      </para>
     </sect1>
     <sect1 id="variable.config.fix.newlines">
      <title>$config_fix_newlines</title>
      <para>
      Si cette variable est mise a vrai, les caractFres de nouvelles lignes mac et dos
      (\r et \r\n) sont convertis en \n quand ils sont analysTs. vrai par dTfaut.
      </para>
     </sect1>
     <sect1 id="variable.default.template.handler.func">
      <title>$default_template_handler_func</title>
      <para>
      Cette fonction est appelTe quand un template ne peut pas Otre
      obtenu avec sa ressource.
      </para>
     </sect1>
     <sect1 id="variable.php.handling">
      <title>$php_handling</title>
      <para>
      Indique a Smarty comment interprTter le code PHP
      intTgrT dans les templates. Il y a quatre valeurs possibles, par
      dTfaut SMARTY_PHP_PASSTHRU. Notez que cela n'affecte PAS le code
      PHP entourT des balises
      <link linkend="language.function.php">{php}{/php}</link>
      dans le template.
      </para>
      <itemizedlist>
       <listitem><para>SMARTY_PHP_PASSTHRU - Smarty Tcrit les balises
       telles quelles.</para></listitem>
       <listitem><para>SMARTY_PHP_QUOTE - Smarty transforme les balises
       en entitTs HTML.</para></listitem>
       <listitem><para>SMARTY_PHP_REMOVE - Smarty supprime les balises
       des templates.</para></listitem>
       <listitem><para>SMARTY_PHP_ALLOW - Smarty exTcute les balises
       comme du code PHP.</para></listitem>
      </itemizedlist>
      <para>
      NOTE : IntTgrer du code PHP dans les templates est vivement
      dTconseillT. PrTfTrez les
      <link linkend="language.custom.functions">fonctions utilisateurs</link>
      ou les <link linkend="language.modifiers">modificateurs de variables</link>.
      </para>
     </sect1>
     <sect1 id="variable.security">
      <title>$security</title>
      <para>
      Cette variable est a faux par dTfaut. $security est de rigueur
      quand vous n'Otes pas complFtement svr des personnes qui Tditent les templates
      (par ftp par exemple) et que vous voulez rTduire le risque que
      la sTcuritT du systFme soit compromise par le language de template.
      Activer cette option de sTcuritT applique les rFgles suivantes
      au langage de template, a moins que $security_settings ne spTcifie
      le contraire :
      </para>
      <itemizedlist>
       <listitem><para>Si $php_handling est rTglTe a SMARTY_PHP_ALLOW,
         cela est implicitement changT a SMARTY_PHP_PASSTHRU.</para></listitem>
       <listitem><para>Les fonctions PHP ne sont pas autorisTes dans les
         instructions IF, a part celles dTclarTes dans
         $security_settings.</para></listitem>
       <listitem><para>Les templates ne peuvent Otre inclus que depuis
         des rTpertoires listTs dans le tableau $security_dir.</para></listitem>
       <listitem><para>Les fichiers locaux ne peuvent Otre rTcupTrTs que depuis
         les rTpertoires listTs dans le tableau $security_dir en
         utilisant {fetch}.</para></listitem>
       <listitem><para>Les balises {php}{/php} ne sont pas autorisTes.</para></listitem>
       <listitem><para>Les fonctions PHP ne sont pas autorisTes en tant
         modificateurs, a part celles spTcifiTes dans $security_settings.</para></listitem>
      </itemizedlist>
     </sect1>
     <sect1 id="variable.secure.dir">
      <title>$secure_dir</title>
      <para>
      Il s'agit d'un tableau contenant tous les rTpertoires locaux qui sont
      considTrTs comme sTcurisTs. {include} et {fetch} l'utilisent quand
      la sTcuritT est activTe.
      </para>
     </sect1>
     <sect1 id="variable.security.settings">
      <title>$security_settings</title>
      <para>
      Ces rTglages servent a Tcraser ou spTcifier les paramFtres de sTcuritT
      quand celle-ci est activTe. Les rTglages possibles sont les suivants :
      </para>
      <itemizedlist>
       <listitem><para>PHP_HANDLING - true/false. Si vrai, le
       rTglage $php_handling n'est pas vTrifiT.</para></listitem>
       <listitem><para>IF_FUNCS - Le tableau des noms de fonctions
       PHP autorisTes dans les intructions IF.</para></listitem>
       <listitem><para>INCLUDE_ANY - true/false. Si vrai,
       les templates peuvent Otre inclus de n'importe oú, quelque soit
       le contenu de $secure_dir.</para></listitem>
       <listitem><para>PHP_TAGS - true/false. Si vrai,
       les balises {php}{/php} sont autorisTes dans les templates.</para></listitem>
       <listitem><para>MODIFIER_FUNCS - Le tableau des noms de fonctions
       autorisTes a Otre utilisTes comme modificateurs de variables.</para></listitem>
      </itemizedlist>
     </sect1>
     <sect1 id="variable.trusted.dir">
      <title>$trusted_dir</title>
      <para>
      $trusted_dir n'est utilisTe lorsque $security est activTe. C'est un
      tableau de tous les rTpertoires qui peuvent Otre considTrTs comme svrs.
      Les rTpertoires svrs sont ceux qui contiennent des scripts PHP qui
      sont exTcutTs directement depuis les templates avec
      <link linkend="language.function.include.php">{include_php}</link>.
      </para>
     </sect1>
     <sect1 id="variable.left.delimiter">
      <title>$left_delimiter</title>
      <para>
      Il s'agit du dTlimiteur gauche utilisT par le moteur de templates. La
      valeur par dTfaut est "{".
      </para>
     </sect1>
     <sect1 id="variable.right.delimiter">
      <title>$right_delimiter</title>
      <para>
      Il s'agit du dTlimiteur droit utilisT par le moteur de templates.
      La valeur par dTfaut est "}".
      </para>
     </sect1>
     <sect1 id="variable.compiler.class">
      <title>$compiler_class</title>
      <para>
      SpTcifie le nom de la classe du compilateur qui va Otre utilisTe pour
      compiler les templates. Le compilateur par dTfaut est
      'Smarty_Compiler'. RTservT aux utilisateurs avancTs.
      </para>
     </sect1>
     <sect1 id="variable.request.vars.order">
      <title>$request_vars_order</title>
      <para>
      L'ordre dans lequel les variables de requOtes sont enregistrTes,
      identique a variables_order dans php.ini.
      </para>
     </sect1>
     <sect1 id="variable.compile.id">
      <title>$compile_id</title>
      <para>
      Identifiant persistant du compilateur. On peut passer le mOme compile_id
      a chaque appel de fonction mais une alternative consiste a rTgler ce
      compile_id, qui sera utilisT implicitement.
      </para>
     </sect1>
     <sect1 id="variable.use.sub.dirs">
      <title>$use_sub_dirs</title>
      <para>
      RTgler cela a faux si votre environnement PHP n'autorise pas Smarty a crTer
      des sous-rTpertoires. Les sous-rTpertoires sont efficaces, utilisez-les quand
      vous le pouvez.
      </para>
     </sect1>
     <sect1 id="variable.default.modifiers">
      <title>$default_modifiers</title>
      <para>
      Il s'agit d'un tableau de modificateurs utilisT pour assigner
      une valeur par dTfaut a chaque variable dans un template.
      Par exemple, pour par dTfaut Tchapper les caractFres HTML de chaque variable,
      utilisez array('escape:"htmlall"'); Pour rendre une variable indTpendante
      des modificateurs par dTfaut, passez-lui en paramFtre le modificateur
      "nodefaults" : {$var|nodefaults}.
      </para>
     </sect1>
    </chapter>

   <chapter id="api.functions">
     <title>MTthodes</title>
        <sect1 id="api.append">
         <title>append</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>append</function></funcdef>
           <paramdef>mixed <parameter>var</parameter></paramdef>
          </funcprototype>
          <funcprototype>
           <funcdef>void <function>append</function></funcdef>
           <paramdef>string <parameter>varname</parameter></paramdef>
           <paramdef>mixed <parameter>var</parameter></paramdef>
          </funcprototype>
          <funcprototype>
           <funcdef>void <function>append</function></funcdef>
           <paramdef>string <parameter>varname</parameter></paramdef>
           <paramdef>mixed <parameter>var</parameter></paramdef>
           <paramdef>boolean <parameter>merge</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
         UtilisTe pour ajouter un TlTment a un tableau assignT. Si vous utilisez
         cette fonction avec une chaene de caractFre, elle est convertie en
         tableau auquel on ajoute ensuite l'TlTment. Vous pouvez explicitement passer
         des paires nom/valeur. Si vous passez le troisiFme paramFtre
         (optionel) a vrai, la valeur sera fusionnTe avec le tableau plut(t que
         d'Otre ajoutTe.
         </para>
		 <note>
		 <title>Note technique</title>
		 <para>
		 Le paramFtre de fusion respecte les clTs des tableaux, ainsi si vous
		 fusionnez deux tableaux indexTs numTriquement, ils pourront s'Tcraser
		 l'un l'autre ou donner des clTs qui ne se suivent pas. Cela diffFre
		 donc de la fonction PHP array_merge() qui supprime les clTs numTriques
		 et les renumTrote.
		 </para>
		 </note>
         <example>
          <title>append</title>
          <programlisting>
// passe des paires nom/valeur
$smarty->append("Name","Fred");
$smarty->append("Address",$address);

// passe un tableau associatif
$smarty->append(array("city" => "Lincoln","state" => "Nebraska"));</programlisting>
</example>
		</sect1>
     <sect1 id="api.append.by.ref">
      <title>append_by_ref</title>
      <funcsynopsis>
       <funcprototype>
        <funcdef>void <function>append_by_ref</function></funcdef>
        <paramdef>string <parameter>varname</parameter></paramdef>
        <paramdef>mixed <parameter>var</parameter></paramdef>
       </funcprototype>
       <funcprototype>
        <funcdef>void <function>append_by_ref</function></funcdef>
        <paramdef>string <parameter>varname</parameter></paramdef>
        <paramdef>mixed <parameter>var</parameter></paramdef>
        <paramdef>boolean <parameter>merge</parameter></paramdef>
       </funcprototype>
      </funcsynopsis>
      <para>
      UtilisTe pour ajouter des valeurs a un template par rTfTrence plut(t que
      par copie. Si vous ajoutez une variable par rTfTrence puis changez sa
      valeur, le changement est aussi rTpercutT sur la valeur assignTe.
      Pour les objets, append_by_ref ne fait pas de copie en mTmoire de l'objet
      assignT. Voir la documentation PHP pour plus d'informations sur les
      rTfTrences de variable.
      Si vous passez le troisiFme paramFtre a vrai, la valeur sera fusionnTe
      avec le tableau courant plut(t que d'Otre ajoutTe.
      </para>
	  <note>
	  <title>Note technique</title>
     <para>
       Le paramFtre de fusion respecte les clTs des tableaux, ainsi si vous
      fusionnez deux tableaux indexTs numTriquement, ils pourront s'Tcraser
      l'un l'autre ou donner des clTs qui ne se suivent pas. Cela diffFre
      donc de la fonction PHP array_merge() qui supprime les clTs numTriques
      et les renumTrote.
     </para>
	  </note>
      <example>
       <title>append_by_ref</title>
       <programlisting>
// ajoute des paires nom/valeur
$smarty->append_by_ref("Name",$myname);
$smarty->append_by_ref("Address",$address);</programlisting>
</example>
		</sect1>
     <sect1 id="api.assign">
      <title>assign</title>
      <funcsynopsis>
       <funcprototype>
        <funcdef>void <function>assign</function></funcdef>
        <paramdef>mixed <parameter>var</parameter></paramdef>
       </funcprototype>
       <funcprototype>
        <funcdef>void <function>assign</function></funcdef>
        <paramdef>string <parameter>varname</parameter></paramdef>
        <paramdef>mixed <parameter>var</parameter></paramdef>
       </funcprototype>
      </funcsynopsis>
      <para>
      UtilisTe pour assigner des valeurs aux templates. Vous pouvez
      explicitement passer des paires nom/valeur, ou des tableaux
      associatifs contenant des paires nom/valeur.
      </para>
      <example>
       <title>assign</title>
       <programlisting>
// passe des paires nom/valeur
$smarty->assign("Name","Fred");
$smarty->assign("Address",$address);

// passe un tableau associatif
$smarty->assign(array("city" => "Lincoln","state" => "Nebraska"));</programlisting>
</example>
		</sect1>
     <sect1 id="api.assign.by.ref">
      <title>assign_by_ref</title>
      <funcsynopsis>
       <funcprototype>
        <funcdef>void <function>assign_by_ref</function></funcdef>
        <paramdef>string <parameter>varname</parameter></paramdef>
        <paramdef>mixed <parameter>var</parameter></paramdef>
       </funcprototype>
      </funcsynopsis>
      <para>
      UtilisTe pour assigner des valeurs aux templates par rTfTrence plut(t
      que par copie. RTfTrez-vous au manuel PHP pour une explication plus prTcise
      sur les rTfTrences des variables.
      </para>
	  <note>
	  <title>Note technique</title>
	  <para>
	    Si vous assignez une variable par rTfTrence puis changez sa
      valeur, le changement est aussi rTpercutT sur la valeur assignTe.
      Pour les objets, assign_by_ref ne fait pas de copie en mTmoire de l'objet
      assignT. RTfTrez-vous au manuel PHP pour une explication plus prTcise sur
      les rTfTrences de variable.
	  </para>
	  </note>
      <example>
       <title>assign_by_ref</title>
       <programlisting>
// passe des paires noms/valeurs
$smarty->assign_by_ref("Name",$myname);
$smarty->assign_by_ref("Address",$address);</programlisting>
</example>
		</sect1>
		<sect1 id="api.clear.all.assign">
			<title>clear_all_assign</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>clear_all_assign</function></funcdef>
				<paramdef><parameter></parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			UtilisTe pour effacer les valeurs de toutes les variables assignTes.
			</para>
<example>
<title>clear_all_assign</title>
<programlisting>
// efface toutes les variables assignTes
$smarty->clear_all_assign();</programlisting>
</example>
		</sect1>
		<sect1 id="api.clear.all.cache">
			<title>clear_all_cache</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>clear_all_cache</function></funcdef>
				<paramdef>int <parameter>expire time</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
         UtilisTe pour effacer les fichiers de cache des templates. Vous pouvez passer un
         paramFtre optionnel afin d'indiquer l'Gge minimun que doivent avoir
         les fichiers  de cache pour qu'ils soient effacTs.
			</para>
<example>
<title>clear_all_cache</title>
<programlisting>
// efface le cache
$smarty->clear_all_cache();</programlisting>
</example>
		</sect1>
		<sect1 id="api.clear.assign">
			<title>clear_assign</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>clear_assign</function></funcdef>
				<paramdef>string <parameter>var</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
         <para>
         Efface la valeur d'une variable assignTe. Il peut s'agir
         d'une simple valeur ou d'un tableau de valeur.
         </para>
<example>
<title>clear_assign</title>
<programlisting>
// efface une variable
$smarty->clear_assign("Name");

// efface plusieurs variables
$smarty->clear_assign(array("Name","Address","Zip"));</programlisting>
</example>
		</sect1>
		<sect1 id="api.clear.cache">
			<title>clear_cache</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>clear_cache</function></funcdef>
				<paramdef>string <parameter>template</parameter></paramdef>
				<paramdef>string <parameter><optional>cache id</optional></parameter></paramdef>
				<paramdef>string <parameter><optional>compile id</optional></parameter></paramdef>
				<paramdef>int <parameter><optional>expire time</optional></parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			UtilisTe pour nettoyer le(s) fichier(s) de cache d'un template en particulier.
			Si vous avez plusieurs fichiers de cache pour ce template vous
			pouvez en spTcifier un en  particulier en passant son identifiant
			en deuxiFme paramFtre. Vous pouvez aussi passer un identifiant
			de compilation en troisiFme paramFtre. Vous pouvez grouper des
			templates ensemble afin qu'ils puissent Otre supprimTs en groupe.
			RTfTrez-vous a la section sur le
			<link linkend="caching">cache</link>
			pour plus d'informations. Vous pouvez passer un quatriFme paramFtre
			pour indiquer un Gge minimum en secondes que le fichier en cache doit
			avoir avant d'Otre effacT.
			</para>
<example>
<title>clear_cache</title>
<programlisting>
// efface le fichier de cache de ce template
$smarty->clear_cache("index.tpl");

// efface un fichier de cache grGce a son identifiant de cache
$smarty->clear_cache("index.tpl","CACHEID");</programlisting>
</example>
		</sect1>
		<sect1 id="api.clear.compiled.tpl">
			<title>clear_compiled_tpl</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>clear_compiled_tpl</function></funcdef>
				<paramdef>string <parameter>tpl_file</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			UtilisTe pour effacer la version compilTe du template spTcifiT ou
			de tous les templates si aucun n'est spTcifiT. Cette fonction
			est destinTe a un usage avancT et n'est pas habituellement utilisTe.
			</para>
<example>
<title>clear_compiled_tpl</title>
<programlisting>
// efface la version compilTe du template spTcifiT
$smarty->clear_compiled_tpl("index.tpl");

// efface tout le contenu du rTpertoire des templates compilTs
$smarty->clear_compiled_tpl();</programlisting>
</example>
		</sect1>
		<sect1 id="api.clear.config">
			<title>clear_config</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>clear_config</function></funcdef>
				<paramdef>string <parameter><optional>var</optional></parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
         UtilisTe pour effacer toutes les variables de configuration s'Ttant
         vues assigner une valeur. Si une variable est spTcifiTe, seule cette
         variable est effacTe.
			</para>
<example>
<title>clear_config</title>
<programlisting>
// efface toutes les variables de configuration assignTes
$smarty->clear_config();

// efface une seule variable
$smarty->clear_config('foobar');</programlisting>
</example>
		</sect1>
		<sect1 id="api.config.load">
			<title>config_load</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>config_load</function></funcdef>
				<paramdef>string <parameter>file</parameter></paramdef>
				<paramdef>string <parameter><optional>section</optional></parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			UtilisTe pour charger des donnTes d'un fichier de config et les
			assigner a un template. Cette fonction fonctionne exactement comme
			la fonction de template <link
			linkend="language.function.config.load">config_load</link>.
			</para>
		  <note>
		  <title>Note technique</title>
		  <para>
		  Comme pour Smarty 2.4.0, les variables de templates assignTes
        sont conservTes entre chaque appel a fetch et display.
		  Les variables de configuration chargTes avec config_load sont
        globales. Les fichiers de config sont aussi compilTs pour une
        exTcution plus rapide et respecte les rTglages de <link
		   linkend="variable.force.compile">force_compile</link> et de <link
		   linkend="variable.compile.check">compile_check</link>.
		  </para>
		  </note>
<example>
<title>config_load</title>
<programlisting>
// charge les variables de configuration et les assigne
$smarty->config_load('my.conf');

// charge une section
$smarty->config_load('my.conf','foobar');</programlisting>
</example>
		</sect1>
		<sect1 id="api.display">
			<title>display</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>display</function></funcdef>
				<paramdef>string <parameter>template</parameter></paramdef>
				<paramdef>string <parameter><optional>cache_id</optional></parameter></paramdef>
				<paramdef>string <parameter><optional>compile_id</optional></parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
         UtilisTe pour afficher un template. Il faut fournir un type et un
         chemin de <link
                linkend="template.resources">ressource template</link>
         valides. Vous pouvez passer en second paramFtre un identifiant
         de fichier de cache. Reportez-vous a la section
         <link linkend="caching">cache</link> pour plus de renseignements.
			</para>
			<para>
			Le troisiFme paramFtre optionnel est un identifiant de compilation.
         Cela s'avFre utile quand vous voulez compiler diffTrentes versions
         d'un mOme template, pour par exemple avoir des templates
         compilTs sTparTs pour diffTrents langages. Une autre utilitT de ce
         paramFtre est le cas oú vous utilisez plus d'un $template_dir mais un seul
         $compile_dir, car certains templates avec le mOme nom s'Tcraseraient
         entre eux. Vous pouvez aussi rTgler la variable <link
			linkend="variable.compile.id">$compile_id</link> une seule
			fois au lieu de la passer a chaque appel.
			</para>
<example>
<title>affichage</title>
<programlisting>
include("Smarty.class.php");
$smarty = new Smarty;
$smarty->caching = true;

// ne fait un appel a la base de donnTes que si le fichier
// de cache n'existe pas
if(!$smarty->is_cached("index.tpl"))
{

    // quelques donnTes
    $address = "245 N 50th";
    $db_data = array(
	    "City" => "Lincoln",
	    "State" => "Nebraska",
	    "Zip" = > "68502"
	    );

    $smarty->assign("Name","Fred");
    $smarty->assign("Address",$address);
    $smarty->assign($db_data);

}

// display the output
$smarty->display("index.tpl");</programlisting>
</example>
         <para>
         Utilisez la syntaxe des <link
			linkend="template.resources">ressources templates</link>
         pour afficher des fichiers en-dehors du rTpertoire
         $template_dir
         </para>

<example>
<title>exemples de fonction d'affichage de ressources templates</title>
<programlisting>
// chemin absolu
$smarty->display("/usr/local/include/templates/header.tpl");

// chemin absolu (pareil)
$smarty->display("file:/usr/local/include/templates/header.tpl");

// chemin absolu Windows (on DOIT utiliser le prTfixe "file:")
$smarty->display("file:C:/www/pub/templates/header.tpl");

// inclue a partir de la ressource template "db"
$smarty->display("db:header.tpl");</programlisting>
</example>

		</sect1>
		<sect1 id="api.fetch">
			<title>fetch</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>string <function>fetch</function></funcdef>
				<paramdef>string <parameter>template</parameter></paramdef>
				<paramdef>string <parameter><optional>cache_id</optional></parameter></paramdef>
				<paramdef>string <parameter><optional>compile_id</optional></parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			UtilisTe pour renvoyer le rTsultat du template plut(t que de l'afficher.
         Il faut passer un type et un chemin de <link
         linkend="template.resources">ressource template</link>
         valides. Vous pouvez passer un identifiant de cache en deuxiFme
         paramFtre. Reportez-vous a la section <link linkend="caching">cache
         </link> pour plus de renseignements.
			</para>
			<para>
         Un troisiFme paramFtre optionnel est un identifiant de compilation.
         Cela s'avFre utile quand vous voulez compiler diffTrentes versions
         d'un mOme template, pour par exemple avoir des templates
         compilTs sTparTs pour diffTrents langages. Une autre utilitT de ce
         paramFtre est le cas oú vous utilisez plus d'un $template_dir
         mais un seul $compile_dir, car certains templates avec le mOme nom
         s'Tcraseraient entre eux. Vous pouvez aussi rTgler la variable <link
			linkend="variable.compile.id">$compile_id</link> une seule
			fois plut(t que de la passer a chaque appel.
			</para>
<example>
<title>fetch</title>
<programlisting>
include("Smarty.class.php");
$smarty = new Smarty;

$smarty->caching = true;

// ne fait un appel a la base de donnTes que si le fichier
// de cache n'existe pas
if(!$smarty->is_cached("index.tpl"))
{

    // quelques donnTes
    $address = "245 N 50th";
    $db_data = array(
	    "City" => "Lincoln",
	    "State" => "Nebraska",
	    "Zip" = > "68502"
	    );

    $smarty->assign("Name","Fred");
    $smarty->assign("Address",$address);
    $smarty->assign($db_data);

}

// rTcupFre le rTsultat
$output = $smarty->fetch("index.tpl");

// fait quelque chose avec $output

echo $output;</programlisting>
</example>
		</sect1>
		<sect1 id="api.get.config.vars">
			<title>get_config_vars</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>array <function>get_config_vars</function></funcdef>
				<paramdef>string <parameter><optional>varname</optional></parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			Retourne la valeur de la variable de configuration passTe en paramFtre.
			Si aucun paramFtre n'est donnT, un tableau de toutes les variables de
			configuration chargTes est renvoyT.
			</para>
<example>
<title>get_config_vars</title>
<programlisting>
// rTcupFre la variable de configuration chargTe 'foo'
$foo = $smarty->get_config_vars('foo');

// rTcupFre toutes les variables de configuration chargTes
$config_vars = $smarty->get_config_vars();

// les affiche a l'Tcran
print_r($config_vars);</programlisting>
</example>
		</sect1>
		<sect1 id="api.get.registered.object">
			<title>get_registered_object</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>array <function>get_registered_object</function></funcdef>
				<paramdef>string <parameter>object_name</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			Retourne la rTfTrence d'un objet enregistrT. Utile quand vous
			voulez accTder directement a un objet enregistrT avec une
			fonction utilisateur.
			</para>
<example>
<title>get_registered_object</title>
<programlisting>
function smarty_block_foo($params, &amp;$smarty) {
	if (isset[$params['object']]) {
      // rTcupFre la rTfTrence de l'objet enregistrT
   		$obj_ref =&amp; $smarty->get_registered_object($params['object']);
   	// $obj_ref est maintenant une rTfTrence vers l'objet
	}
}</programlisting>
</example>
		</sect1>
		<sect1 id="api.get.template.vars">
			<title>get_template_vars</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>array <function>get_template_vars</function></funcdef>
				<paramdef>string <parameter><optional>varname</optional></parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			Retourne la valeur assignTe passTe en paramFtre. Si aucun paramFtre
			n'est donnT, un tableau de toutes les variables assignTes est
			renvoyT.
			</para>
<example>
<title>get_template_vars</title>
<programlisting>
// rTcupFre la variable 'foo' assignTe au template
// get assigned template var 'foo'
$foo = $smarty->get_template_vars('foo');

// rTcupFre toutes les variables assignTes a ce template
$tpl_vars = $smarty->get_template_vars();

// les affiche a l'Tcran
print_r($tpl_vars);</programlisting>
</example>
		</sect1>
		<sect1 id="api.is.cached">
			<title>is_cached</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>is_cached</function></funcdef>
				<paramdef>string <parameter>template</parameter></paramdef>
				<paramdef>[string <parameter>cache_id</parameter>]</paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			Retourne vrai s'il y a un fichier de cache valide pour ce template.
			Cela fonctionne seulement si <link
         linkend="variable.caching">caching</link> est a vrai.
			</para>
<example>
<title>is_cached</title>
<programlisting>
$smarty->caching = true;

if(!$smarty->is_cached("index.tpl")) {
    // faire des requOtes base de donnTes et assigner
    // des variables ici.
}

$smarty->display("index.tpl");</programlisting>
</example>
            <para>
            Vous pouvez aussi passer en second paramFtre un identifiant
            de cache au cas oú vous voudriez plusieurs fichiers de cache
            pour ce template.
            </para>
<example>
<title>is_cached with multiple-cache template</title>
<programlisting>
$smarty->caching = true;

if(!$smarty->is_cached("index.tpl","FrontPage")) {
    // faire des requOtes base de donnTes et assigner
    // des variables ici.
}

$smarty->display("index.tpl","FrontPage");</programlisting>
</example>
		</sect1>
        <sect1 id="api.load.filter">
         <title>load_filter</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>load_filter</function></funcdef>
           <paramdef>string <parameter>type</parameter></paramdef>
           <paramdef>string <parameter>name</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
         Cette fonction peut Otre utilisTe pour charger un plugin
         de filtrage. Le premier argument spTcifie le type du filtre
         et peut prendre l'une des valeurs suivantes : 'pre', 'post'
         ou 'output'. Le second argument spTcifie le nom du plugin
         de filtrage, par exemple 'trim'.
         </para>
<example>
<title>Chargement de plugins de filtrage</title>
<programlisting>
$smarty->load_filter('pre', 'trim'); // charge le filtre 'trim' de type 'pre'
$smarty->load_filter('pre', 'datefooter'); // charge un autre filtre de type 'pre' appelT 'datefooter'
$smarty->load_filter('output', 'compress'); // charge le filtre 'compress' de type 'output'</programlisting>
</example>
        </sect1>
		<sect1 id="api.register.block">
			<title>register_block</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>register_block</function></funcdef>
				<paramdef>string <parameter>name</parameter></paramdef>
				<paramdef>string <parameter>impl</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
         UtilisTe pour dTclarrer dynamiquement des plugins de fonction
         de blocs. Il faut passer en paramFtre le nom de la fonction
         de blocs, suivi du nom de la fonction PHP qui l'implTmente.
         </para>
<example>
<title>register_block</title>
<programlisting>
/* PHP */
$smarty->register_block("translate", "do_translation");

function do_translation ($params, $content, &amp;$smarty) {
    if ($content) {
        $lang = $params['lang'];
        // fait de la traduction avec la variable $content
        echo $translation;
    }
}

{* template *}
{translate lang="br"}
   Hello, world!
{/translate}</programlisting>
</example>
		</sect1>
		<sect1 id="api.register.compiler.function">
			<title>register_compiler_function</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>register_compiler_function</function></funcdef>
				<paramdef>string <parameter>name</parameter></paramdef>
				<paramdef>string <parameter>impl</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			UtilisTe pour dTclarer dynamiquement un plugin de fonction
			de compilation. Il faut passer en paramFtres le nom de la fonction
			de compilation, suivi par la fonction PHP qui
			l'implTmente.
			</para>
		</sect1>
		<sect1 id="api.register.function">
			<title>register_function</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>register_function</function></funcdef>
				<paramdef>string <parameter>name</parameter></paramdef>
				<paramdef>string <parameter>impl</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			UtilisTe pour dTclarer dynamiquement des plugins de fonction
			de templates. Il faut passer en paramFtres le nom de la fonction
			de templates, suivi par le nom de la fonction PHP qui l'implTmente.
			</para>
<example>
<title>register_function</title>
<programlisting>
$smarty->register_function("date_now", "print_current_date");

function print_current_date ($params) {
    extract($params);
    if(empty($format))
        $format="%b %e, %Y";
    echo strftime($format,time());
}

// vous pouvez maintenant utiliser ceci dans Smarty pour afficher
// la date actuelle : {date_now} ou {date_now format="%Y/%m/%d"}
// pour la formater</programlisting>
</example>
		</sect1>
		<sect1 id="api.register.modifier">
         <title>register_modifier</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>register_modifier</function></funcdef>
           <paramdef>string <parameter>name</parameter></paramdef>
           <paramdef>string <parameter>impl</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
         UtilisTe pour dTclarer dynamiquement un plugin de modificateur.
         Il faut passer en paramFtre le nom du modificateur de variables,
         suivi de la fonction PHP qui l'implTmente.
         </para>
<example>
<title>register_modifier</title>
<programlisting>
// associons la fonction PHP stripslashes a un modificateur Smarty.

$smarty->register_modifier("sslash","stripslashes");

// vous pouvez maintenant utiliser {$var|sslash} pour supprimer les slash des variables</programlisting>
</example>
		</sect1>
		<sect1 id="api.register.object">
			<title>register_object</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>register_object</function></funcdef>
				<paramdef>string <parameter>object_name</parameter></paramdef>
				<paramdef>object <parameter>$object</parameter></paramdef>
				<paramdef>array <parameter>allowed methods/properties</parameter></paramdef>
				<paramdef>boolean <parameter>format</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			UtilisTe pour enregistrer un objet a utiliser dans un template.
			Reportez-vous a la section
         <link linkend="advanced.features.objects">objet</link> de
         ce manuel pour des exemples.
         </para>
		</sect1>
		<sect1 id="api.register.outputfilter">
			<title>register_outputfilter</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>register_outputfilter</function></funcdef>
				<paramdef>string <parameter>function_name</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			UtilisTe pour dTclarer dynamiquement des filtres de sortie, pour
			agir sur la sortie d'un template avant qu'elle ne soit affichTe.
			Reportez-vous a la section <link linkend="advanced.features.outputfilters">
         filtres de sortie</link> pour plus d'information sur le sujet.
			</para>
		</sect1>
		<sect1 id="api.register.postfilter">
			<title>register_postfilter</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>register_postfilter</function></funcdef>
				<paramdef>string <parameter>function_name</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
         UtilisTe pour dTclarer dynamiquement des filtres de post-compilation pour y faire
         passer des templates une fois qu'ils ont TtT compilTs. Reportez-vous
         a la section
          <link linkend="advanced.features.postfilters">filtres de post-compilation de templates</link>
         pour avoir plus de renseignements sur la faton de paramTtrer les fonctions
         de post-compilation.
			</para>
		</sect1>
		<sect1 id="api.register.prefilter">
			<title>register_prefilter</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>register_prefilter</function></funcdef>
				<paramdef>string <parameter>function_name</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			UtilisTe pour dTclarer dynamiquement des filtres de prT-compilation pour y faire
         passer des templates avant qu'ils ne soient compilTs. Reportez-vous
         a la section
          <link linkend="advanced.features.postfilters">filtres de prT-compilation de templates</link>
         pour avoir plus de renseignements sur la faton de paramTtrer les fonctions
         de prT-compilation.
			</para>
		</sect1>
        <sect1 id="api.register.resource">
         <title>register_resource</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>register_resource</function></funcdef>
           <paramdef>string <parameter>name</parameter></paramdef>
           <paramdef>array <parameter>resource_funcs</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
         UtilisTe pour dTclarer dynamiquement une ressource plugin
         dans Smarty. Il faut passer en paramFtre le nom de la ressource
         et le tableau des fonctions PHP qui l'implTmentent. Reportez-vous
         a la section <link linkend="template.resources">ressources templates</link>
         pour avoir plus d'informations sur la faton de paramTtrer une fonction
         rTcupTrant des templates.
         </para>
<example>
<title>register_resource</title>
<programlisting>
$smarty->register_resource("db", array("db_get_template",
                                       "db_get_timestamp",
                                       "db_get_secure",
                                       "db_get_trusted"));</programlisting>
</example>
		</sect1>
        <sect1 id="api.trigger.error">
         <title>trigger_error</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>trigger_error</function></funcdef>
           <paramdef>string <parameter>error_msg</parameter></paramdef>
           <paramdef>[int <parameter>level</parameter>]</paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
         Cette fonction peut-Otre utilisTe pour afficher un message d'erreur
         en utilisant Smarty. Le paramFtre <parameter>level</parameter>
         peut prendre l'une des valeures utilisTes par la fonction PHP
         trigger_error, i.e. E_USER_NOTICE, E_USER_WARNING, etc. Par dTfaut
         il s'agit de E_USER_WARNING.
         </para>
        </sect1>

        <sect1 id="api.template.exists">
         <title>template_exists</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>bool <function>template_exists</function></funcdef>
           <paramdef>string <parameter>template</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
         Cette fonction vTrifie si le template spTcifiT existe. Elle accepte
         soit un chemin vers le template, soit une ressource de type
         chaene de caractFres prTcisant le nom du template.
         </para>
        </sect1>
        <sect1 id="api.unregister.block">
         <title>unregister_block</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>unregister_block</function></funcdef>
           <paramdef>string <parameter>name</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
         UtilisTe pour dTsallouer dynamiquement un plugin de fonction
         de blocs. Passez en paramFtre le nom du bloc.
         </para>
		</sect1>
        <sect1 id="api.unregister.compiler.function">
         <title>unregister_compiler_function</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>unregister_compiler_function</function></funcdef>
           <paramdef>string <parameter>name</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
         UtilisTe pour dTsallouer dynamiquement un fonction de compilation.
         Passez en paramFtre le nom de la fonction de compilation.
         </para>
        </sect1>
		<sect1 id="api.unregister.function">
         <title>unregister_function</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>unregister_function</function></funcdef>
           <paramdef>string <parameter>name</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
         UtilisTe pour dTsallouer dynamiquement un plugin de fonction
         de templates. Passez en paramFtres le nom de la fonction de templates.
         </para>
<example>
<title>unregister_function</title>
<programlisting>
// nous ne voulons pas que les designers de templates aient accFs
// au systFme de fichiers.

$smarty->unregister_function("fetch");</programlisting>
</example>
		</sect1>
		<sect1 id="api.unregister.modifier">
         <title>unregister_modifier</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>unregister_modifier</function></funcdef>
           <paramdef>string <parameter>name</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
         UtilisTe pour dTsallouer dynamiquement un plugin modificateur de variable.
         Passez en paramFtre le nom du modificateur de templates.
         </para>
<example>
<title>unregister_modifier</title>
<programlisting>
// nous ne voulons pas que les designers de templates
// suppriment les balises des Tlements

$smarty->unregister_modifier("strip_tags");</programlisting>
</example>
		</sect1>
		<sect1 id="api.unregister.object">
			<title>unregister_object</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>unregister_object</function></funcdef>
				<paramdef>string <parameter>object_name</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			UtilisTe pour dTsallouer un objet.
         </para>
		</sect1>
		<sect1 id="api.unregister.outputfilter">
			<title>unregister_outputfilter</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>unregister_outputfilter</function></funcdef>
				<paramdef>string <parameter>function_name</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			UtilisTe pour dTsallouer dynamiquement un filtre de sortie.
			</para>
		</sect1>
		<sect1 id="api.unregister.postfilter">
			<title>unregister_postfilter</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>unregister_postfilter</function></funcdef>
				<paramdef>string <parameter>function_name</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			UtilisTe pour dTsallouer dynamiquement un filtre de post-compilation.
			</para>
		</sect1>
		<sect1 id="api.unregister.prefilter">
			<title>unregister_prefilter</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>unregister_prefilter</function></funcdef>
				<paramdef>string <parameter>function_name</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
			UtilisTe pour dTsallouer dynamiquement un filtre de prT-compilation.
			</para>
		</sect1>
        <sect1 id="api.unregister.resource">
         <title>unregister_resource</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>unregister_resource</function></funcdef>
           <paramdef>string <parameter>name</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
         UtilisTe pour dTsallouer dynamiquement un plugin ressource.
         Passez en paramFtre le nom de la ressource.
         </para>
<example>
<title>unregister_resource</title>
<programlisting>
$smarty->unregister_resource("db");</programlisting>
</example>
		</sect1>
       </chapter>

  <chapter id="caching">
   <title>Cache</title>
   <para>
   Le cache est utilisTe pour accTlTrer l'appel de <link
   linkend="api.display">display()</link> ou de <link
   linkend="api.fetch">fetch()</link> en sauvegardant leur rTsultat
   dans un fichier. Si un fichier de cache est disponible lors d'un appel,
   il sera affichT sans qu'il ne soit nTcessaire de regTnTrer le rTsultat.
   Le systFme de cache
   peut accTlTrer les traitements de faton impressionnante, en particulier les
   templates dont la compilation est trFs longue. Comme le rTsultat de
   display() ou de fetch() est dans le cache, un fichier de cache peut
   Otre composT de plusieurs fichiers de templates, plusieurs fichiers
   de configuration, etc.
   </para>
   <para>
   Comme les templates sont dynamiques, il est important de faire attention
   a la faton dont les fichiers de cache sont gTnTrTs, et pour combien de temps.
   Si par exemple vous affichez la page d'accueil de votre site Web dont le
   contenu ne change pas souvent, il peut Otre intTressant de mettre cette page
   dans le cache pour une heure ou plus. A l'inverse, si vous affichez une page
   de mTtTo mises a jour toutes les minutes, mettre cette page en cache
   n'a aucun sens.
   </para>
   <sect1 id="caching.setting.up">
   <title>ParamTtrer le cache</title>
   <para>
   La premiFre chose a faire est d'activer le cache. Cela est fait en
   mettant <link linkend="variable.caching">$caching</link> = true
   (ou 1).
   </para>
    <example>
     <title>activation du cache</title>
     <programlisting>
require('Smarty.class.php');
$smarty = new Smarty;

$smarty->caching = true;

$smarty->display('index.tpl');</programlisting>
    </example>
    <para>
    Avec le cache activT, la fonction display('index.tpl') va afficher
    le template mais sauvegardera par la mOme occasion une copie du rTsultat
    dans un fichier (de cache) du rTpertoire
    <link linkend="variable.cache.dir">$cache_dir</link>. Au prochain appel de
    display('index.tpl'), le fichier de cache sera prTfTrT a la rTutilisation
    du template.
    </para>
	<note>
	<title>Note technique</title>
	<para>
	Les fichiers situTs dans $cache_dir sont nommTs de la mOme faton que les templates.
	Bien qu'ils aient une extension ".php", ils ne sont pas vraiment exTcutable.
	N'Tditez surtout pas ces fichiers !
	</para>
	</note>
	<para>
	Tout fichier de cache a une durTe de vie limitTe dTterminTe par <link
	linkend="variable.cache.lifetime">$cache_lifetime</link>. La valeur par
	dTfaut est 3600 secondes, i.e. 1 heure. Une fois que cette durTe est
	dTpassTe, le cache est regTnTrT. Il est possible de donner
   une durTe d'expiration propre a chaque fichier de cache en rTglant
   $caching = 2.
   Se reporter a la documentation de <link
	linkend="variable.cache.lifetime">$cache_lifetime</link> pour plus de
	dTtails.
	</para>
    <example>
     <title>rTglage individuel de cache_lifetime</title>
     <programlisting>
require('Smarty.class.php');
$smarty = new Smarty;

$smarty->caching = 2; // rTgler la durTe de vie individuellement

// rTgle la durTe de vie du cache a 15 minutes pour index.tpl
$smarty->cache_lifetime = 300;
$smarty->display('index.tpl');

// rTgle la durTe de vie du cache a 1 heure pour home.tpl
$smarty->cache_lifetime = 3600;
$smarty->display('home.tpl');

// NOTE : le rTglage suivant ne fonctionne pas quand $caching = 2. La durTe de vie
// du fichier de cache de home.tpl a dTja TtT rTglTe a 1 heure et ne respectera
// plus la valeur de $cache_lifetime. Le cache de home.tpl expirera toujours
// dans 1 heure.
$smarty->cache_lifetime = 30; // 30 secondes
$smarty->display('home.tpl');</programlisting>
    </example>
  <para>
  Si <link linkend="variable.compile.check">$compile_check</link> est actif,
  chaque fichier de template et de configuration qui a un rapport
  avec le fichier de cache sera vTrifiT pour dTtecter une Tventuelle
  modification. Si l'un de ces fichiers a TtT modifiT depuis que le fichier de cache a TtT
  gTnTrT, le cache est immTdiatement regTnTrT. Ce processus est covteux, donc,
  pour des raisons de performances, mettez ce paramFtre a false pour une application
  en production.
  </para>
    <example>
     <title>activation de $compile_check</title>
     <programlisting>
require('Smarty.class.php');
$smarty = new Smarty;

$smarty->caching = true;
$smarty->compile_check = true;

$smarty->display('index.tpl');</programlisting>
	</example>
   <para>
   Si <link linkend="variable.force.compile">$force_compile</link> est actif,
   les fichiers de cache sont toujours regTnTrTs. Ceci revient finalement a
   dTsactiver le cache. $force_compile est utilisT a des fins de dTbogage,
   un moyen plus efficace de dTsactiver le cache est de rTgler
   <link	linkend="variable.caching">$caching</link> = false (ou 0).
   </para>
   <para>
   La fonction <link linkend="api.is.cached">is_cached()</link> permet
   de tester si un template a ou non un fichier de cache valide.
   Si vous disposez d'un template en cache qui requiert une requOte
   a une base de donnTes, vous pouvez utiliser cette mTthode plut(t
   que $compile_check.
   </para>
    <example>
     <title>utilisation de is_cached()</title>
     <programlisting>
require('Smarty.class.php');
$smarty = new Smarty;

$smarty->caching = true;

if(!$smarty->is_cached('index.tpl')) {
   // pas de cache disponible, on assigne
	$contents = get_database_contents();
	$smarty->assign($contents);
}

$smarty->display('index.tpl');</programlisting>
    </example>
    <para>
    Vous pouvez rendre dynamiques seulement certaines parties d'une
    page avec la fonction de templates <link
    linkend="language.function.insert">insert</link>.
    Imaginons que toute une page doit Otre mise en cache a part
    une banniFre en bas a droite. En utilisant une fonction insert pour la
    banniFre, vous pouvez garder cet TlTment dynamique dans le contenu qui
    est en cache. Reportez-vous a la documentation
    <link linkend="language.function.insert">insert</link> pour plus de dTtails
    et des exemples.
    </para>
    <para>
    Vous pouvez effacer tous les fichiers du cache avec la fonction <link
	 linkend="api.clear.all.cache">clear_all_cache(),</link> ou de faton
	 individuelle (ou par groupe) avec la fonction <link
	 linkend="api.clear.cache">clear_cache()</link>.
    </para>
    <example>
     <title>nettoyage du cache</title>
     <programlisting>
require('Smarty.class.php');
$smarty = new Smarty;

$smarty->caching = true;

// efface tous les fichiers du cache
$smarty->clear_all_cache();

// efface le fichier de cache du template 'index.tpl'
$smarty->clear_cache('index.tpl');

$smarty->display('index.tpl');</programlisting>
    </example>
   </sect1>
   <sect1 id="caching.multiple.caches">
   <title>Caches multiples pour une seule page</title>
   <para>
   Vous pouvez avoir plusieurs fichiers de caches pour un mOme appel
   aux fonctions display() ou fetch(). Imaginons qu'un appel a display('index.tpl')
   puisse avoir plusieurs rTsultats, en fonction de certaines conditions, et que
   vous vouliez des fichiers de cache sTparTs pour chacun d'eux. Vous
   pouvez faire cela en passant un identifiant de cache (cache_id) en
   deuxiFme paramFtre a l'appel de fonction.
   </para>
    <example>
     <title>Passage d'un cache_id a display()</title>
     <programlisting>
require('Smarty.class.php');
$smarty = new Smarty;

$smarty->caching = true;

$my_cache_id = $_GET['article_id'];

$smarty->display('index.tpl',$my_cache_id);</programlisting>
    </example>
    <para>
    Nous passons ci-dessus la variable $my_cache_id a display() comme
    identifiant de cache. Pour chaque valeur distincte de $my_cache_id,
    un fichier de cache distinct va Otre crTT. Dans cet exemple,
    "article_id" a TtT passT dans l'URL et est utilisT en tant qu'identifiant
    de cache.
    </para>
 	<note>
	<title>Note technique</title>
	<para>
	Soyez prudent en passant des valeurs depuis un client (navigateur Web)
	vers Smarty (ou vers n'importe quelle application PHP). Bien que l'exemple
	ci-dessus consistant a utiliser article_id depuis l'URL puisse paraetre
	commode, le rTsultat peut s'avTrer mauvais. L'identifiant
	de cache est utilisT pour crTer un rTpertoire sur le systFme de fichiers,
	donc si l'utilisateur dTcide de donner une trFs grande valeur a article_id
	ou d'Tcrire un script qui envoie des article_id de faton alTatoire,
	cela pourra causer des problFmes cotT serveur. Assurez-vous de bien
	tester toute donnTe passTe en paramFtre avant de l'utiliser. Dans cet
	exemple, peut-Otre savez-vous que article_id a une longueur de 10
   caractFres, est exclusivement composT de caractFres alph-numTriques et
   doit avoir une valeur contenue dans la base de donnTes. VTrifiez-le bien !
	</para>
	</note>
	<para>
	Assurez-vous de bien passer le mOme identifiant aux fonctions
   <link linkend="api.is.cached">is_cached()</link> et
	<link linkend="api.clear.cache">clear_cache()</link>.
	</para>
	<example>
     <title>passer un  cache_id a is_cached()</title>
     <programlisting>
require('Smarty.class.php');
$smarty = new Smarty;

$smarty->caching = true;

$my_cache_id = $_GET['article_id'];

if(!$smarty->is_cached('index.tpl',$my_cache_id)) {
	// pas de fichier de cache dispo, on assigne donc les variables
	$contents = get_database_contents();
	$smarty->assign($contents);
}

$smarty->display('index.tpl',$my_cache_id);</programlisting>
    </example>
    <para>
    Vous pouvez effacer tous les fichiers de cache pour un identifiant
    de cache particulier en passant null en tant que premier paramFtre
    a clear_cache().
    </para>
	<example>
     <title>effacement de tous les fichiers de cache pour un identifiant de cache particulier</title>
     <programlisting>
require('Smarty.class.php');
$smarty = new Smarty;

$smarty->caching = true;

// efface tous les fichiers de cache avec "sports" comme identifiant
$smarty->clear_cache(null,"sports");

$smarty->display('index.tpl',"sports");</programlisting>
    </example>
    <para>
    De cette maniFre vous pouvez "grouper" vos fichiers de cache en leur
    donnant le mOme identifiant.
    </para>
   </sect1>
   <sect1 id="caching.groups">
    <title>groupes de fichiers de cache</title>
    <para>
    Vous pouvez faire des groupements plus TlaborTs en paramTtrant les
    groupes d'identifiant de cache. Il suffit de sTparer chaque sous-groupes
    avec une barre verticale "|" dans la valeur de l'identifiant de cache.
    Vous pouvez faire autant de sous-groupes que vous le dTsirez.
    </para>
	<example>
     <title>groupes d'identifiants de cache</title>
     <programlisting>
require('Smarty.class.php');
$smarty = new Smarty;

$smarty->caching = true;

// efface tous les fichiers de cache avec "sports|basketball" comme premiers
// groupes d'identifiants de cache
$smarty->clear_cache(null,"sports|basketball");

// efface tous les fichiers de cache "sports" comme premier groupe d'identifiants.
// Inclue donc "sports|basketball" ou "sports|nimportequoi|nimportequoi|..."
$smarty->clear_cache(null,"sports");

$smarty->display('index.tpl',"sports|basketball");</programlisting>
    </example>
   <note>
   <title>Note technique</title>
   <para>
   Le systFme de cache n'utilise PAS le chemin vers le template en quoi
   que ce soit pour l'identifiant de cache.  Si par exemple vous
   faites display('themes/blue/index.tpl'), vous ne pouvez pas effacer tous
   les fichiers de cache dans le rTpertoire "theme/blue". Si vous voulez
   faire cela, vous devez les grouper avec un mOme identifiant de cache,
   display('themes/blue/index.tpl','themes|blue'). Vous pouvez ensuite effacer les
   fichiers de cache pour blue et theme avec clear_cache(null,'theme|blue').
   </para>
   </note>
   </sect1>
  </chapter>

  <chapter id="advanced.features">
   <title>FonctionnalitTs avancTes</title>
   <sect1 id="advanced.features.objects">
    <title>Objets</title>
    <para>
    Smarty donne l'accFs aux objets PHP a travers les templates. Il y
    a 2 moyens d'y avoir accFs. Le premier consiste a allouer les objets
    au template puis de les utiliser avec une syntaxe similaire a celles
    des fonctions personnalisTes. Le deuxiFme moyen consiste a allouer
    des objets aux templates et de les utiliser comme n'importe quelle
    variable. La premiFre mTthode a une syntaxe beaucoup plus sympathique.
    Elle est aussi plus sTcurisTe, puisqu'un objet allouT ne peut avoir accFs
    qu'a certaines mTthodes et propriTtTs. NTanmoins, un objet allouT
    ne peut pas avoir de lien sur lui-mOme ou Otre mis dans un tableau
    d'objet, etc. Vous devez choisir la mTthode qui correspond a vos
    besoins, mais tGchez d'utiliser la premiFre mTthode autant que possible
    afin de rTduire la syntaxe des templates au minimum.
    </para>
    <para>
    Si l'option de sTcuritT est activTe, aucune mTthode ou fonctions privTes
    n'est accessible (commentant par "_"). S'il existe une mTthode et une
    propriTtT du mOme nom, c'est la mTthode qui sera utilisTe.
    </para>
    <para>
    Vous pouvez restreindre l'accFs aux mTthodes et aux propriTtTs en
    les listant dans un tableau en tant que troisiFme paramFtre
    d'allocation.
    </para>
	<para>
	Par dTfaut, les paramFtres passTs aux objets depuis le templates le sont de la
  mOme faton que les fonctions utilisateurs les rTcupFrent.
  Le premier paramFtre correspond a un tableau associatif, le second a l'objet
  Smarty. Si vous souhaitez que les paramFtres soient passTes un a un, comme
  dans un appel traditionnel, dTfinissez registration, quatriFme paramFtre optionnel,
  a false.
	</para>
    <example>
     <title>utilisation d'un objet allouT ou assignT</title>
     <programlisting>
&lt;?php
// la classe

class My_Object() {
	function meth1($params, &amp;$smarty_obj) {
		return "this is my meth1";
	}
}

$myobj = new My_Object;
// enregistre l'objet
$smarty->register_object("foobar",$myobj);
// on restreint l'accFs a certaines mTthodes et propriTtTs en les listant
$smarty->register_object("foobar",$myobj,array('meth1','meth2','prop1'));
// pour utiliser le format habituel de paramFtre objet, passez le boolTen = false
$smarty->register_object("foobar",$myobj,null,false);

// on peut aussi assigner des objets. Assignez par rTfTrence quand c'est possible
$smarty->assign_by_ref("myobj", $myobj);

$smarty->display("index.tpl");
?&gt;

TEMPLATE:

{* accFs a notre objet enregistrT *}
{foobar->meth1 p1="foo" p2=$bar}

{* on peut aussi assigner la sortie *}
{foobar->meth1 p1="foo" p2=$bar assign="output"}
the output was {$output)

{* access our assigned object *}
{$myobj->meth1("foo",$bar)}</programlisting>
    </example>
  </sect1>
   <sect1 id="advanced.features.prefilters">
    <title>Filtres de prT-compilation</title>
    <para>
    Les filtres de prT-compilation sont des fonctions PHP que vos templates
    exTcutent avant qu'ils ne soient compilTs. Cela peut Otre utile
    pour prT-traiter vos templates afin d'enlever les commentaires
    inutiles, garder un oeil sur ce que les gens mettent dans leurs templates, etc.
    Les filtre de prT-compilations peuvent Otre soit
    <link linkend="api.register.prefilter">dTclarTs</link> soit chargTs
    a partir des rTpertoires de plugins en utilisant la fonction
    <link linkend="api.load.filter">load_filter()</link> ou en rTglant
    la variable
     <link linkend="variable.autoload.filters">$autoload_filters</link>.
     Smarty passera a la fonction le code source en tant que premier argument,
     et attendra en retour le code modifiT.
    </para>
    <example>
     <title>Utilisation un filtre de prT-compilation de template</title>
     <programlisting>
&lt;?php
// mettre ceci dans votre application
function remove_dw_comments($tpl_source, &amp;$smarty)
{
    return preg_replace("/&lt;!--#.*--&gt;/U","",$tpl_source);
}

// enregistrer le filtre de prT-compilation
$smarty->register_prefilter("remove_dw_comments");
$smarty->display("index.tpl");
?&gt;

{* template Smarty index.tpl *}
&lt;!--# cette ligne va Otre supprimTe par le filtre de prT-compilation --&gt;</programlisting>
    </example>
   </sect1>

   <sect1 id="advanced.features.postfilters">
    <title>Filtres de post-compilation</title>
    <para>
    Les filtres de post-compilation sont des fonctions PHP que vos templates
    exTcutent aprFs avoir TtT compilTs. Les filtres de post-compilation peuvent
    Otre soit <link linkend="api.register.postfilter">dTclarTs</link> soit chargTs
    depuis les rTpertoires des plugins en utilisant la fonction
    <link linkend="api.load.filter">load_filter()</link> ou en rTglant
    la variable <link linkend="variable.autoload.filters">$autoload_filters</link>.
    Smarty passera le template compilT en tant que premier paramFtre et attendra
    de la fonction qu'elle retourne le rTsultat de l'exTcution.
    </para>
    <example>
     <title>utilisation d'un filtre de post-compilation de templates</title>
     <programlisting>
&lt;?php
// mettez cela dans votre application
function add_header_comment($tpl_source, &amp;$smarty)
{
    return "&lt;?php echo \"&lt;!-- Created by Smarty! --&gt;\n\" ?&gt;\n".$tpl_source;
}

// enregistre le filtre de post-compilation
$smarty->register_postfilter("add_header_comment");
$smarty->display("index.tpl");
?&gt;

{* template Smarty compilT index.tpl *}
&lt;!-- Created by Smarty! --&gt;
{* reste du contenu du template... *}</programlisting>
    </example>
  </sect1>

  <sect1 id="advanced.features.outputfilters">
   <title>Filtres de sortie</title>
   <para>
   Quand le template est appelT via les fonctions display() ou fetch(),
   sa sortie est envoyTe a travers un ou plusieurs filtres de sorties.
   Ils diffFrent des filtres de post-compilation dans le sens ou ils agissent
   sur la sortie des templates, une fois exTcutTs, et non sur les sources
   des templates.
   </para>
   <para>
   Les filtres de sortie peuvent Otre soit
   <link linkend="api.register.outputfilter">dTclarTs</link> soit
   chargTs depuis les rTpertoires des plugins en utilisant la fonction
   <link linkend="api.load.filter">load_filter()</link>
   ou en rTglant la variable
   <link linkend="variable.autoload.filters">$autoload_filters</link>.
   Smarty passera la sortie du template en premier argument et attendra
   de la fonction qu'elle retourne le rTsultat de l'exTcution.
   </para>
   <example>
    <title>utilisation d'un filtre de sortie</title>
    <programlisting>
&lt;?php
// mettez ceci dans votre application
function protect_email($tpl_output, &amp;$smarty)
{
    $tpl_output =
       preg_replace('!(\S+)@([a-zA-Z0-9\.\-]+\.([a-zA-Z]{2,3}|[0-9]{1,3}))!',
                    '$1%40$2', $tpl_output);
    return $tpl_output;
}

// enregistre le filtre de sortie
$smarty->register_outputfilter("protect_email");
$smarty->display("index.tpl");

// dorTnavant toute occurence d'un adresse email dans le rTsultat du template
// aura un protection simple contre les robots spammers
?&gt;</programlisting>
   </example>
  </sect1>

  <sect1 id="section.template.cache.handler.func">
   <title>Fonction de gestion du cache</title>
   <para>
   Une alternative au mTcanisme de cache par dTfaut (basT sur des fichiers
   de cache) consiste a spTcifier une fonction de gestion de cache utilisateur
   qui sera utilisTe pour lire, Tcrire et effacer les fichiers de cache.
   </para>
   <para>
   Il suffit de crTer dans votre application une fonction que Smarty
   utilisera pour la gestion du cache et d'assigner le nom de cette
   fonction a la variable de classe
   <link linkend="variable.cache.handler.func">$cache_handler_func</link>.
   Smarty utilisera alors cette fonction pour gTrer les donnTes du cache.
   Le premier argument est l'action, qui sera 'read', 'write' ou 'clear'.
   Le second paramFtre est l'objet Smarty. Le troisiFme est le contenu
   du cache. Pour Tcrire, Smarty passe le contenu du cache dans ces paramFtres.
   Pour lire, Smarty s'attend a ce que votre fonction accepte ce paramFtre
   par rTfTrence et que vous le remplissiez avec les donnTes du cache. Pour effacer,
   il suffit de passer une variable fictive car cette derniFre n'est pas utilisTe.
   Le quatriFme paramFtre est le nom du fichier de template (utile pour
   lire/Tcrire), le cinquiFme paramFtre est l'identifiant de cache (optionnel)
   et le sixiFme est l'identifiant de compilation.
   </para>
   <example>
    <title>exemple d'utilisation de MySQL pour la source du cache</title>
    <programlisting>
&lt;?php
/*

exemple d'usage :

include('Smarty.class.php');
include('mysql_cache_handler.php');

$smarty = new Smarty;
$smarty-&gt;cache_handler_func = 'mysql_cache_handler';

$smarty-&gt;display('index.tpl');


la base mysql est attendu dans ce format :
	
create database SMARTY_CACHE;

create table CACHE_PAGES(
CacheID char(32) PRIMARY KEY,
CacheContents MEDIUMTEXT NOT NULL
);

*/

function mysql_cache_handler($action, &amp;$smarty_obj, &amp;$cache_content, $tpl_file=null, $cache_id=null, $compile_id=null)
{
	// l'h(te de la bd, l'utilisateur, et le mot de passe
	$db_host = 'localhost';
	$db_user = 'myuser';
	$db_pass = 'mypass';
	$db_name = 'SMARTY_CACHE';
	$use_gzip = false;
	
	// crTe un identifiant de cache unique
	$CacheID = md5($tpl_file.$cache_id.$compile_id);
	
	if(! $link = mysql_pconnect($db_host, $db_user, $db_pass)) {
		$smarty_obj-&gt;_trigger_error_msg("cache_handler: could not connect to database");
		return false;
	}
	mysql_select_db($db_name);

	switch ($action) {
		case 'read':
			// rTcupFre le cache dans la base de donnTes
			$results = mysql_query("select CacheContents from CACHE_PAGES where CacheID='$CacheID'");
			if(!$results) {
				$smarty_obj-&gt;_trigger_error_msg("cache_handler: query failed.");			
			}
			$row = mysql_fetch_array($results,MYSQL_ASSOC);
			
			if($use_gzip &amp;&amp; function_exists("gzuncompress")) {
				$cache_contents = gzuncompress($row["CacheContents"]);
			} else {
				$cache_contents = $row["CacheContents"];
			}
			$return = $results;
			break;
		case 'write':
			// sauvegarde le cache dans la base de donnTes
			
			if($use_gzip &amp;&amp; function_exists("gzcompress")) {
				// compresse le contenu pour gagner de la place
				$contents = gzcompress($cache_content);
			} else {
				$contents = $cache_content;
			}
			$results = mysql_query("replace into CACHE_PAGES values(
							'$CacheID',
							'".addslashes($contents)."')
						");
			if(!$results) {
				$smarty_obj-&gt;_trigger_error_msg("cache_handler: query failed.");			
			}
			$return = $results;
			break;
		case 'clear':
         // efface les donnTes du cache
			if(empty($cache_id) &amp;&amp; empty($compile_id) &amp;&amp; empty($tpl_file)) {
				// les efface toutes
				$results = mysql_query("delete from CACHE_PAGES");			
			} else {
				$results = mysql_query("delete from CACHE_PAGES where CacheID='$CacheID'");			
			}
			if(!$results) {
				$smarty_obj-&gt;_trigger_error_msg("cache_handler: query failed.");			
			}
			$return = $results;
			break;
		default:
			// erreur, action inconnue
			$smarty_obj-&gt;_trigger_error_msg("cache_handler: unknown action \"$action\"");
			$return = false;
			break;
	}
	mysql_close($link);
   return $return;
	
}

?&gt;</programlisting>
    </example>
  </sect1>

  <sect1 id="template.resources">  
   <title>Ressources</title>
   <para>
   Les templates peuvent provenir d'une grande variTtT de ressources. Quand vous
   affichez ou rTcupTrez un template, ou quand vous incluez un template
   dans un autre template, vous fournissez un type de ressource, suivi
   par le chemin appropriT et le nom du template.
   </para>
      <sect2 id="templates.from.template.dir">
    <title>Templates depuis $template_dir</title>
    <para>
    Les templates du rTpertoire $template_dir n'ont pas
    besoin d'une ressource template, bien que vous puissiez utiliser
    la ressource "file" pour Otre cohTrent. Vous n'avez qu'a fournir
    le chemin vers le template que vous voulez utiliser, relatif
    au rTpertoire racine $template_dir.
    </para>    
    <example>
     <title>Utilisation de templates depuis $template_dir</title>
     <programlisting>
// le script PHP
$smarty->display("index.tpl");
$smarty->display("admin/menu.tpl");
$smarty->display("file:admin/menu.tpl"); // le mOme que celui ci-dessus

{* le template Smarty *}
{include file="index.tpl"}
{include file="file:index.tpl"} {* le mOme que celui ci-dessus *}</programlisting>
    </example>
   </sect2>
   <sect2 id="templates.from.any.dir">
    <title>Templates a partir de n'importe quel rTpertoire</title>
    <para>
    Les templates en-dehors du rTpertoire $template_dir nTcessitent
    le type de ressource template, suivi du chemin absolu et du nom du
    template.
    </para>    
    <example>
     <title>utilisation d'un template depuis n'importe quel rTpertoire</title>
     <programlisting>
// le script PHP
$smarty->display("file:/export/templates/index.tpl");
$smarty->display("file:/path/to/my/templates/menu.tpl");

{* le template Smarty *}
{include file="file:/usr/local/share/templates/navigation.tpl"}</programlisting>
    </example>

    <sect3>
     <title>Chemin de fichiers Windows</title>
     <para>
     Si vous utilisez Windows, les chemins de fichiers sont la plupart
     du temps sur un disque identifiT par une lettre (c:) au dTbut du chemin.
     Assurez-vous de bien mettre "file:" dans le chemin pour Tviter des
     conflits d'espace de nommage et obtenir les rTsultats escomptTs.
     </para>
     <example>
      <title>utilisation de templates avec des chemins de fichiers Windows</title>
      <programlisting>
// le script PHP
$smarty->display("file:C:/export/templates/index.tpl");
$smarty->display("file:F:/path/to/my/templates/menu.tpl");

{* le template Smarty *}
{include file="file:D:/usr/local/share/templates/navigation.tpl"}</programlisting>
     </example>
    </sect3>
   </sect2>

   <sect2 id="templates.from.elsewhere">
    <title>Templates depuis d'autres sources</title>
    <para>
    Vous pouvez rTcupTrer les templates a partir n'importe quelle
    source a laquelle vous avez accFs avec PHP : base de donnTes,
    sockets, LDAP et ainsi de suite. Il suffit d'Tcrire les fonctions
    de ressource plugins et de les enregistrer auprFs de Smarty. 
    </para>
    <para>
    Reportez-vous a la section <link linkend="plugins.resources">ressource plugins</link>
    pour plus d'informations sur les fonctions que vous Otes censT fournir.
    </para>
    <note>
     <para>
     Notez que vous ne pouvez pas Tcraser la ressource <literal>file</literal> native,
     toutefois, vous pouvez fournir une ressource qui rTcupFre un template depuis
     le systFme de fichier par un autre moyen en l'enregistrant sous un autre
     nom de ressource.
     </para>
    </note>
    <example>
     <title>utilisation de ressources utilisateurs</title>
     <programlisting>
// le script PHP

// mettez ces fonctions quelque part dans votre application
function db_get_template ($tpl_name, &amp;$tpl_source, &amp;$smarty_obj)
{
    // requOte BD pour rTcupTrer le template
    // et remplir $tpl_source
    $sql = new SQL;
    $sql->query("select tpl_source
                   from my_table
                  where tpl_name='$tpl_name'");
    if ($sql->num_rows) {
        $tpl_source = $sql->record['tpl_source'];
        return true;
    } else {
        return false;
    }
}

function db_get_timestamp($tpl_name, &amp;$tpl_timestamp, &amp;$smarty_obj)
{
    // requOte BD pour remplir $tpl_timestamp
    $sql = new SQL;
    $sql->query("select tpl_timestamp
                   from my_table
                  where tpl_name='$tpl_name'");
    if ($sql->num_rows) {
        $tpl_timestamp = $sql->record['tpl_timestamp'];
        return true;
    } else {
        return false;
    }
}

function db_get_secure($tpl_name, &amp;$smarty_obj)
{
    // on suppose que tous les templates sont svrs
    return true;
}

function db_get_trusted($tpl_name, &amp;$smarty_obj)
{
    // pas utilisTe pour les templates dans notre cas
}

// enregistre le nom de ressource "db"
$smarty->register_resource("db", array("db_get_template",
                                       "db_get_timestamp",
                                       "db_get_secure",
                                       "db_get_trusted"));

// utilise la ressource depuis le script PHP
$smarty->display("db:index.tpl");

{* utilise la ressource depuis le template Smarty *}
{include file="db:/extras/navigation.tpl"}</programlisting>
    </example>
   </sect2>

   <sect2 id="default.template.handler.function">
    <title>Fonction de gestion de template par dTfaut</title>
    <para>
    Vous pouvez spTcifier une fonction qui sera utilisTe pour
    rTcupTrer le contenu d'un template dans le cas oú le template
    ne peut pas Otre rTcupTrT depuis sa ressource. Une utilisation possible est
    la crTation de templates a la volTe.
    </para>
    <example>
     <title>utilisation de la fonction de gestion de template par dTfaut</title>
     <programlisting>
&lt;?php
// mettez cette fonction quelque part dans votre application

function make_template ($resource_type, $resource_name, &amp;$template_source, &amp;$template_timestamp, &amp;$smarty_obj)
{
	if( $resource_type == 'file' ) {
		if ( ! is_readable ( $resource_name )) {
			// crTe le fichier de template et renvoie le contenu
			$template_source = "This is a new template.";
			$template_timestamp = time();
			$smarty_obj->_write_file($resource_name,$template_source);
			return true;
		}
    } else {
		// pas un fichier
		return false;
    }
}

// rTgle la fonction par dTfaut
$smarty->default_template_handler_func = 'make_template';
?&gt;</programlisting>
    </example>
   </sect2>
  </sect1>
 </chapter>

 <chapter id="plugins">
  <title>Etendre Smarty avec des plugins</title>
  <para>
  La version 2.0 a introduit l'architecture de plugin qui est
  utilisTe pour pratiquement toute les fonctionnalitTs
  personnalisables de Smarty. Ceci comprend : 
  <itemizedlist spacing="compact">
    <listitem><simpara>les fonctions</simpara></listitem>
    <listitem><simpara>les modificateurs</simpara></listitem>
    <listitem><simpara>les fonctions de blocs</simpara></listitem>
    <listitem><simpara>les fonctions de compilation</simpara></listitem>
    <listitem><simpara>les filtres de prT-compilation</simpara></listitem>
    <listitem><simpara>les filtres de post-compilation</simpara></listitem>
    <listitem><simpara>les filtres de sorties</simpara></listitem>
    <listitem><simpara>les ressources</simpara></listitem>
    <listitem><simpara>les insertions</simpara></listitem>
  </itemizedlist>
  A part pour les ressources, la compatibilitT avec les anciennes
  fatons d'enregistrer les fonctions de gestion avec l'API register_
  est conservTe. Si vous n'avez pas utilisT cette API et que vous avez
  a la place directement modifiT les variables de classes 
  <literal>$custom_funcs</literal>, <literal>$custom_mods</literal> et
  d'autres, vous devez alors modifier vos scripts pour utiliser
  l'API ou convertir vos fonctionnalitTs personnalisTes en plugins.
  </para>
     
  <sect1>
   <title>Comment fonctionnent les plugins</title>
   <para>
   Les plugins sont toujours chargTs a la demande. Seuls les modificateurs
   de variables, les ressources, etc invoquTs dans les scripts de templates
   seront chargTs. De plus, chaque plugin n'est chargT qu'une fois, et ce
   mOme si vous avez plusieurs instances de Smarty qui tournent dans
   la mOme requOte.
   </para>
   <para>
   Les filtres de post/prT-compilation et les filtres de sortie sont des cas
   un peu spTciaux.
   Comme ils ne sont pas mentionnTs dans les templates, ils doivent Otre dTclarTs
   ou chargTs explicitement via les fonctions de l'API avant que le template
   ne soit exTcutT. L'ordre dans lequel les filtres multiples d'un mOme type
   sont exTcutTs dTpend de l'ordre dans lequel ils sont enregistrTs ou chargTs.
   </para>
   <para>
   Il n'existe qu'un seul rTpertoire de plugin (pour des raisons de performances).
   Pour installer un plugin, copiez-le simplement dans le rTpertoire et Smarty
   l'utilisera automatiquement.
   </para>   
  </sect1>

   <sect1 id="plugins.naming.conventions">
    <title>Conventions de nommage</title>
    <para>
    Les fichiers et les fonctions de plugins doivent suivre une convention
    de nommage trFs spTcifique pour Otre localisTs par Smarty.
    </para>
    <para>
    Les fichiers de plugins doivent Otre nommTs de la faton suivante :
    <blockquote>
      <para>
       <filename>
        <replaceable>type</replaceable>.<replaceable>nom</replaceable>.php
       </filename>
      </para>
     </blockquote>
    </para>
    <para>
    Oú <literal>type</literal> est l'une des valeurs suivantes :
    <itemizedlist spacing="compact">
      <listitem><simpara>function</simpara></listitem>
      <listitem><simpara>modifier</simpara></listitem>
      <listitem><simpara>block</simpara></listitem>
      <listitem><simpara>compiler</simpara></listitem>
      <listitem><simpara>prefilter</simpara></listitem>
      <listitem><simpara>postfilter</simpara></listitem>
      <listitem><simpara>outputfilter</simpara></listitem>
      <listitem><simpara>resource</simpara></listitem>
      <listitem><simpara>insert</simpara></listitem>
     </itemizedlist>
    </para>
    <para>
    Et <literal>nom</literal> doit Otre un identifiant valide (lettres, nombres
    et underscore seulement).
    </para>
    <para>
    Quelques exemples : <literal>function.html_select_date.php</literal>,
    <literal>resource.db.php</literal>,
    <literal>modifier.spacify.php</literal>.
    </para>
    <para>
    Les fonctions de plugins dans les fichiers de plugins doivent Otre
    nommTes de la faton suivante :
    <blockquote>
      <para>
       <function>smarty_<replaceable>type</replaceable>_<replaceable>nom</replaceable></function>
      </para>
     </blockquote> 
    </para>
    <para>
    Les significations de <literal>type</literal> et de <literal>nom</literal> sont les mOmes
    que prTcTdemment.
    </para>
    <para>
    Smarty donnera des messages d'erreur appropriT si le fichier de plugin
    n'est pas trouvT, ou si le fichier ou la fonction de plugin ne sont
    pas nommTs correctement.
    </para>
    </sect1>

   <sect1 id="plugins.writing">
    <title>Ecrire des plugins</title>
    <para>
    Les plugins peuvent Otre soit chargTs automatiquement par Smarty
    depuis le systFme de fichier, soit Otre dTclarTs
    pendant l'exTcution via une fonction register_* de l'API. Ils peuvent
    aussi Otre dTsallouTs en utilisant une fonction unregister_* de
    l'API.
    </para>
    <para>
    Pour les plugins qui ne sont pas enregistrTs pendant l'exTcution, le nom
    des fonctions n'ont pas a suivre la convention de nommage.
    </para>
    <para>
    Si certaines fonctionnalitTs d'un plugin dTpendent d'un autre plugin
    (comme c'est le cas de certains plugins accompagnant Smarty), alors la maniFre appropriTe
    de charger le plugin est la suivante :
    </para>
    
    <programlisting>
require_once SMARTY_DIR . 'plugins/function.html_options.php';</programlisting>
    <para>
    Une rFgle gTnTrale est que chaque objet Smarty est toujours passT au plugin
    en tant que dernier paramFtre (a part pour les modificateurs).
    </para>    
   </sect1>

   <sect1 id="plugins.functions"><title>Les fonctions de templates</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>void <function>smarty_function_<replaceable>name</replaceable></function></funcdef>
      <paramdef>array <parameter>$params</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
    Tous les attributs passTs aux fonctions de template a partir du template
    sont contenus dans le tableau associatif <parameter>$params</parameter>.
    Vous pouvez accTder a ces valeurs soit directement, par exemple
    <varname>$params['start']</varname>, soit en utilisant
    <varname>extract($params)</varname> pour les importer dans la table
    des symboles.
    </para>
    <para>
    Le retour de la fonction sera substituTe a la balise de fonction
    du template (fonction <function>fetch</function> par exemple). Sinon,
    la fonction peut simplement accomplir une autre tGche sans sortie
    (la fonction <function>assign</function> par exemple)
    </para>
    <para>
    Si la fonction a besoin d'assigner des variables aux templates ou d'utiliser
    d'autres fonctionnalitTs fournies par Smarty, elle peut recevoir un
    objet <parameter>$smarty</parameter> pour cela.
    </para>
    <para>
     RTfTrez-vous aussi a :
     <link linkend="api.register.function">register_function()</link>,
     <link linkend="api.unregister.function">unregister_function()</link>.
    </para>
    <para>
     <example>
      <title>fonction de plugin avec sortie</title>
      <programlisting>
&lt;?php
/*
 * Smarty plugin
 * -------------------------------------------------------------
 * Fichier :  function.eightball.php
 * Type :     fonction
 * Nom :      eightball
 * R(le :     renvoie une phrase magique au hasard
 * -------------------------------------------------------------
 */
function smarty_function_eightball($params, &amp;$smarty)
{
    $answers = array('Yes',
                     'No',
                     'No way',
                     'Outlook not so good',
                     'Ask again soon',
                     'Maybe in your reality');

    $result = array_rand($answers);
    return $answers[$result];
}
?&gt;</programlisting>
     </example>
    </para>
    <para>
     peut Otre utilisTe dans le template de la faton suivante :
    </para>
    <programlisting>
Question: Will we ever have time travel?
Answer: {eightball}.</programlisting>
    <para>
     <example>
      <title>fonction de plugin sans sortie</title>
      <programlisting>
&lt;?php
/*
 * Smarty plugin
 * -------------------------------------------------------------
 * Fichier :  function.assign.php
 * Type :     fonction
 * Nom :      assign
 * Purpose :  assigne une valeur a une variable de template
 * -------------------------------------------------------------
 */
function smarty_function_assign($params, &amp;$smarty)
{
    extract($params);

    if (empty($var)) {
        $smarty->trigger_error("assign: missing 'var' parameter");
        return;
    }

    if (!in_array('value', array_keys($params))) {
        $smarty->trigger_error("assign: missing 'value' parameter");
        return;
    }

    $smarty->assign($var, $value);
}
?&gt;</programlisting>
     </example>
    </para>
   </sect1>

   <sect1 id="plugins.modifiers"><title>Modificateurs</title>
    <para>
    Les modificateurs sont des petites fonctions appliquTes a une variable
    de template avant qu'elle ne soit affichTe ou utilisTe dans un autre contexte.
    Les modificateurs peuvent Otre chaenTs entre eux.
    </para>
    <funcsynopsis>
     <funcprototype>
      <funcdef>mixed <function>smarty_modifier_<replaceable>name</replaceable></function></funcdef>
      <paramdef>mixed <parameter>$value</parameter></paramdef>
      <paramdef>[mixed <parameter>$param1</parameter>, ...]</paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
    Le premier paramFtre passT au modificateur est la valeur
    sur laquelle le modificateur est supposT opTrer. Les autres paramFtres
    peuvent Otre optionnels, dTpendant de quel genre d'opTration doit Otre
    effectuT.
    </para>
    <para>
    Le modificateur doit retourner le rTsultat de son exTcution.
    </para>
    <para>
    Regardez aussi
    <link linkend="api.register.modifier">register_modifier()</link>,
     <link linkend="api.unregister.modifier">unregister_modifier()</link>.
    </para>
    <example>
     <title>plugin modificateur simple</title>
     <para>
     Ce plugin est un alias d'une fonction PHP. Il n'a aucun paramFtre
     supplTmentaires.
     </para>
     <programlisting>
&lt;?php
/*
 * Smarty plugin
 * -------------------------------------------------------------
 * Fichier :  modifier.capitalize.php
 * Type :     modificateur
 * Name :     capitalize
 * R(le :     met une majuscule aux mots d'une phrase
 * -------------------------------------------------------------
 */
function smarty_modifier_capitalize($string)
{
    return ucwords($string);
}
?&gt;</programlisting>
    </example>
    <para></para>
    <example>
     <title>un plugin modificateur un peu plus complexe</title>
     <programlisting>
&lt;?php
/*
 * Smarty plugin
 * -------------------------------------------------------------
 * Fichier :  modifier.truncate.php
 * Type :     modificateur
 * Name :     truncate
 * R(le :     Tronque une chaene a une certaine longueur si
 *            nTcessaire, la coupe optionnellement au milieu
 *            d'un mot et ajoute la chaene $etc 
 * -------------------------------------------------------------
 */
function smarty_modifier_truncate($string, $length = 80, $etc = '...',
                                  $break_words = false)
{
    if ($length == 0)
        return '';

    if (strlen($string) > $length) {
        $length -= strlen($etc);
        $fragment = substr($string, 0, $length+1);
        if ($break_words)
            $fragment = substr($fragment, 0, -1);
        else
            $fragment = preg_replace('/\s+(\S+)?$/', '', $fragment);
        return $fragment.$etc;
    } else
        return $string;
}
?&gt;</programlisting>
    </example>
   </sect1>

   <sect1 id="plugins.block.functions"><title>Fonctions de blocs</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>void <function>smarty_block_<replaceable>name</replaceable></function></funcdef>
      <paramdef>array <parameter>$params</parameter></paramdef>
      <paramdef>mixed <parameter>$content</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
    Les fonctions de blocs sont des fonctions de la forme {func} .. {/func}.
    En d'autres mots, elles englobent des blocs de template et opFrent sur les
    contenus de ces blocs. Les fonctions de blocs ont la prioritT sur les
    fonctions utilisateurs de mOme nom, ce qui signifie que vous ne
    pouvez avoir une fonction utilisateur {func} et une fonction de bloc
    {func} .. {/func}.
    </para>
    <para>
    L'implTmentation de votre fonction est appelTe deux fois par Smarty :
    une fois pour la balise ouvrante et une autre fois pour la balise
    fermante.
    </para>
    <para>
    Seule la balise ouvrante d'une fonction de bloc peut avoir des attributs.
    Tous les attributs passTs par le template aux fonctions de templates sont
    contenues dans le tableau associatif <parameter>$params</parameter>.
    Vous pouvez accTder a ces valeurs soit directement, par exemple
    <varname>$params['start']</varname>, soit en utilisant
    <varname>extract($params)</varname> pour les importer dans la table
    des symboles. Votre fonction a aussi accFs aux attributs de la balise
    ouvrante quand c'est la balise fermante qui est exTcutTe.     
    </para>
    <para>
    La valeur de la variable <parameter>$content</parameter> est diffTrente
    selon si votre fonction est appelTe pour la balise ouvrante ou la
    balise fermante. Si c'est pour la balise ouvrante, elle sera a
    <literal>null</literal> et si c'est la balise fermante elle sera
    Tgale au contenu du bloc de template. Notez que le bloc de template
    aura dTja TtT exTcutT par Smarty, vous recevrez donc la sortie du
    template et non sa source.    
    </para>
    <para>
    Si vous imbriquT des fonctions de bloc, il est possible de connaetre
    la fonction de bloc parente grGce a la variable <varname>$smarty->_tag_stack</varname>.
    Faites un var_dump() dessus et la structure devrait apparaetre.
    </para>    
    <para>
     Regardez aussi :
     <link linkend="api.register.block">register_block()</link>,
     <link linkend="api.unregister.block">unregister_block()</link>.
    </para>
    <example>
     <title>fonction de bloc</title>
     <programlisting>
&lt;?php
/*
 * Smarty plugin
 * -------------------------------------------------------------
 * Fichier :  block.translate.php
 * Type :     bloc
 * Nom :      translate
 * R(le :     traduire un bloc de texte
 * -------------------------------------------------------------
 */
function smarty_block_translate($params, $content, &amp;$smarty)
{
    if ($content) {
        $lang = $params['lang'];
        // fait une traduction de $content
        echo $translation;
    }
}</programlisting>
    </example>
   </sect1>

   <sect1 id="plugins.compiler.functions"><title>Fonctions de compilation</title>
    <para>
    Les fonctions de compilation sont appelTes durant la compilation du template.
    Elles sont utiles pour injecter du code PHP ou du contenu "statique variant
    avec le temps" (bandeau de pub par ex.). Si une fonction de compilation et
    une fonction personnalisTe ont le mOme
    nom, la fonction de compilation a prioritT. 
    </para>
    <funcsynopsis>
     <funcprototype>
      <funcdef>mixed <function>smarty_compiler_<replaceable>name</replaceable></function></funcdef>
      <paramdef>string <parameter>$tag_arg</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
    Les fonctions de compilation ont deux paramFtres : une chaene contenant
    la balise - en gros, tout, depuis le nom de la fonction jusqu'au dTlimiteur de fin - et
    l'objet Smarty. Elles sont censTes retourner le code PHP qui doit Otre
    injectT dans le template compilT.
    </para>
    <para>
     Regardez aussi
     <link linkend="api.register.compiler.function">register_compiler_function()</link>,
     <link linkend="api.unregister.compiler.function">unregister_compiler_function()</link>.
    </para>
    <example>
     <title>fonction de compilation simple</title>
     <programlisting>
&lt;?php
/*
 * Smarty plugin
 * -------------------------------------------------------------
 * Fichier :   compiler.tplheader.php
 * Type :      compilation
 * Nom :       tplheader
 * R(le :      Renvoie l'en-tOte contenant le nom du fichier
 *             source et le temps de compilation.
 * -------------------------------------------------------------
 */
function smarty_compiler_tplheader($tag_arg, &amp;$smarty)
{
    return "\necho '" . $smarty-&gt;_current_file . " compiled at " . date('Y-m-d H:M'). "';";
}
?&gt;</programlisting>
     <para>
     Cette fonction peut-Otre appelT depuis le template comme suivant :
     </para>     
     <programlisting>
{* cette fonction n'est executTe que lors de la compilation *}
{tplheader}</programlisting>
     <para>
     Le code PHP rTsultant dans les templates compilTs ressemblerait a ta :
     </para>
     <programlisting>
&lt;php
echo 'index.tpl compiled at 2002-02-20 20:02';
?&gt;</programlisting>
    </example>
   </sect1>

   <sect1 id="plugins.prefilters.postfilters">
    <title>filtres de prT-compilation/filtres de post-compilation</title>
    <para>
    Les filtres de prT-compilation et les filtres de post-compilation ont des concepts trFs
    proches. Ils diffTrent dans leur exTcution, plus prTcisTment dans le
    moment oú ils sont exTcutTs.
    </para>
    <funcsynopsis>
     <funcprototype>
      <funcdef>string <function>smarty_prefilter_<replaceable>name</replaceable></function></funcdef>
      <paramdef>string <parameter>$source</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
    Les filtres de prT-compilation sont utilisTs pour transformer la source d'un template
    juste avant la compilation. Le premier paramFtre passT a la fonction
    de filtre de prT-compilation est la source du template, Tventuellement modifiTe par
    d'autres filtre de prT-compilations. Le plugin est supposT retourner la source modifiTe.
    Notez que cette source n'est sauvegardTe nulle part, elle est seulement
    utilisT pour la compilation.
    </para>
    <funcsynopsis>
     <funcprototype>
      <funcdef>string <function>smarty_postfilter_<replaceable>name</replaceable></function></funcdef>
      <paramdef>string <parameter>$compiled</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
    Les filtres de post-compilation sont utilisTs pour modifier la sortie du template
    (le code PHP) juste aprFs que la compilation a TtT faite mais juste
    avant que le template ne soit sauvegardT sur le systFme de fichiers.
    Le premier paramFtre passT a la fonction de filtre de post-compilation est le code
    du template compilT, Tventuellement dTja modifiT par d'autres filtre de post-compilations.
    Le plugin est censT retourner la version modifiT du code.
    </para>
    <example>
     <title>plugin de filtre de post-compilation</title>
     <programlisting>
&lt;?php
/*
 * Smarty plugin
 * -------------------------------------------------------------
 * Fichier :  prefilter.pre01.php
 * Type :     filtre de prT-compilation
 * Nom :      pre01
 * R(le :     Passe les balises HTML en minuscules.
 * -------------------------------------------------------------
 */
 function smarty_prefilter_pre01($source, &amp;$smarty)
 {
     return preg_replace('!&lt;(\w+)[^&gt;]+&gt;!e', 'strtolower("$1")', $source);
 }
?&gt;</programlisting>
    </example>
    <para></para>
    <example>
     <title>plugin de filtre de post-compilation</title>
     <programlisting>
&lt;?php
/*
 * Smarty plugin
 * -------------------------------------------------------------
 * Fichier :  postfilter.post01.php
 * Type:      filtre de post-compilation
 * Nom :      post01
 * R(le :     Renvoie du code qui liste toutes les variables
 *            du template.
 * -------------------------------------------------------------
 */
 function smarty_postfilter_post01($compiled, &amp;$smarty)
 {
     $compiled = "&lt;pre&gt;\n&lt;?php print_r(\$this-&gt;get_template_vars()); ?&gt;\n&lt;/pre&gt;" . $compiled;
     return $compiled;
 }
?&gt;</programlisting>
    </example>
   </sect1>

   <sect1 id="plugins.outputfilters"><title>Filtres de sortie</title>
    <para>
    Les plugins de filtres de sortie opFrent sur la sortie du template,
    aprFs que le template a TtT chargT et exTcutT, mais avant que
    la sortie ne soit affichTe.
    </para>    
    <funcsynopsis>
     <funcprototype>
      <funcdef>string <function>smarty_outputfilter_<replaceable>name</replaceable></function></funcdef>
      <paramdef>string <parameter>$template_output</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
    Le premier paramFtre passT a la fonction du filtre de sortie est la
    sortie du template qui doit Otre modifiTe et le second paramFtre
    est l'instance de Smarty appelant le plugin. Le plugin est supposT
    faire un traitement et en retourner le rTsultat.
    </para>
    <example>
     <title>plugin de filtre de sortie</title>
     <programlisting>
/*
 * Smarty plugin
 * -------------------------------------------------------------
 * Fichier :  outputfilter.protect_email.php
 * Type :     filtre de sortie
 * Nom :      protect_email
 * R(le:     Convertie les @ en %40 pour protTger des 
 *           robots spammers.
 * -------------------------------------------------------------
 */
 function smarty_outputfilter_protect_email($output, &amp;$smarty)
 {
     return preg_replace('!(\S+)@([a-zA-Z0-9\.\-]+\.([a-zA-Z]{2,3}|[0-9]{1,3}))!',
                         '$1%40$2', $output);
 }
     </programlisting>
    </example>
   </sect1>

   <sect1 id="plugins.resources"><title>Ressources</title>
    <para>
    Les plugins ressources sont un moyen gTnTrique de fournir des sources
    de templates ou des composants de scripts PHP a Smarty. Quelques exemples
    de ressources : bases de donnTes, LDAP, mTmoire partagTe, sockets, et ainsi
    de suite.
    </para>
    <para>
    Il y au total 4 fonctions qui ont besoin d'Otre enregistrTes pour
    chaque type de ressource. Chaque fonction retoit le nom de la ressource demandTe
    comme premier paramFtre et l'objet Smarty comme dernier paramFtre.
    Les autres paramFtres dTpendent de la fonction.
    </para>
    <funcsynopsis>
     <funcprototype>
      <funcdef>bool <function>smarty_resource_<replaceable>name</replaceable>_source</function></funcdef>
      <paramdef>string <parameter>$rsrc_name</parameter></paramdef>
      <paramdef>string <parameter>&amp;$source</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
     <funcprototype>
      <funcdef>bool <function>smarty_resource_<replaceable>name</replaceable>_timestamp</function></funcdef>
      <paramdef>string <parameter>$rsrc_name</parameter></paramdef>
      <paramdef>int <parameter>&amp;$timestamp</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
     <funcprototype>
      <funcdef>bool <function>smarty_resource_<replaceable>name</replaceable>_secure</function></funcdef>
      <paramdef>string <parameter>$rsrc_name</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
     <funcprototype>
      <funcdef>bool <function>smarty_resource_<replaceable>name</replaceable>_trusted</function></funcdef>
      <paramdef>string <parameter>$rsrc_name</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>

    <para>
    La premiFre fonction est supposTe rTcupTrer la ressource. Son second
    paramFtre est une variable passTe par rTfTrence oú le rTsultat doit Otre
    stockT. La fonction est supposTe retourner <literal>true</literal> si
    elle rTussi a rTcupTrer la ressource et <literal>false</literal> sinon.
    </para>

    <para>
    La seconde fonction est supposTe rTcupTrer la date de derniFre modification 
    de la ressource demandTe (comme un timestamp UNIX). Le second paramFtre
    est une variable passTe par rTfTrence dans laquelle la date doit
    Otre stockTe. La fonction est supposTe renvoyer <literal>true</literal> si elle
    a rTussi a rTcupTrer la date et <literal>false</literal> sinon.
    </para>

    <para>
    La troisiFme fonction est supposTe retourner <literal>true</literal>
    ou <literal>false</literal> selon si la ressource demandTe est svre
    ou non. La fonction est utilisTe seulement pour les ressources templates
    mais doit tout de mOme Otre dTfinie.
    </para>

    <para>
    La quatriFme fonction est supposTe retourner <literal>true</literal>
    ou <literal>false</literal> selon si on peut faire confiance ou
    non a la ressource demandTe. Cette fonction est utilisTe seulement
    pour les composants de scripts PHP demandTs par les balises
    <command>include_php</command> ou <command>insert</command>
    ayant un attribut <structfield>src</structfield>. Quoiqu'il en soit,
    elle doit Otre dTfinie pour les ressources templates.
    </para>

    <para>
     Regardez aussi
     <link linkend="api.register.resource">register_resource()</link>,
     <link linkend="api.unregister.resource">unregister_resource()</link>.
    </para>
    <example>
     <title>resource plugin</title>
     <programlisting>
&lt;?php
/*
 * Smarty plugin
 * ------------------------------------------------------------- 
 * Fichier :  resource.db.php
 * Type :     ressource
 * Nom :      db
 * R(le :     RTcupFre des templates depuis une base de donnTes
 * -------------------------------------------------------------
 */
function smarty_resource_db_source($tpl_name, &amp;$tpl_source, &amp;$smarty)
{
    // fait des requOtes BD pour rTcupTrer votre template
    // et remplir $tpl_source
    $sql = new SQL;
    $sql->query("select tpl_source
                   from my_table
                  where tpl_name='$tpl_name'");
    if ($sql->num_rows) {
        $tpl_source = $sql->record['tpl_source'];
        return true;
    } else {
        return false;
    }
}

function smarty_resource_db_timestamp($tpl_name, &amp;$tpl_timestamp, &amp;$smarty)
{
    // fait des requOtes BD pour remplir $tpl_timestamp
    $sql = new SQL;
    $sql->query("select tpl_timestamp
                   from my_table
                  where tpl_name='$tpl_name'");
    if ($sql->num_rows) {
        $tpl_timestamp = $sql->record['tpl_timestamp'];
        return true;
    } else {
        return false;
    }
}

function smarty_resource_db_secure($tpl_name, &amp;$smarty)
{
    // suppose que tous les templates sont svrs
    return true;
}

function smarty_resource_db_trusted($tpl_name, &amp;$smarty)
{
    // inutilisTe pour les templates
}
?&gt;</programlisting>
    </example>
   </sect1>

   <sect1 id="plugins.inserts"><title>Insertions</title>
    <para>
    Les plugins d'insertion sont utilisTs pour implTmenter les fonctions
    qui sont appelTes par les balises 
    <link linkend="language.function.insert"><command>insert</command></link>
    dans les templates.
    </para>
    <funcsynopsis>
     <funcprototype>
      <funcdef>string <function>smarty_insert_<replaceable>name</replaceable></function></funcdef>
      <paramdef>array <parameter>$params</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
    Le premier paramFtre passT a la fonction est une tableau associatif
    d'attributs. Vous pouvez accTder a ces valeurs soit directement, par exemple
    <varname>$params['start']</varname>, soit en utilisant
    <varname>extract($params)</varname> pour les importer dans la table
    des symboles.
    </para>
    <para>
    La fonction d'insertion est supposTe retourner le rTsultat qui sera
    substituT a la balise <command>insert</command> dans le template.
    </para>    
    <example>
     <title>plugin d'insertion</title>
     <programlisting>
&lt;?php
/*
 * Smarty plugin
 * ------------------------------------------------------------- 
 * Fichier :  insert.time.php
 * Type :     temps
 * Nom :      time
 * R(le :     Insert la date/heure courante conformTment
 *            au format
 * -------------------------------------------------------------
 */
function smarty_insert_time($params, &amp;$smarty)
{
    if (empty($params['format'])) {
        $smarty->trigger_error("insert time: missing 'format' parameter");
        return;
    }

    $datetime = strftime($params['format']);
    return $datetime;
}
?&gt;</programlisting>
    </example>
   </sect1>
  </chapter>
 </part>