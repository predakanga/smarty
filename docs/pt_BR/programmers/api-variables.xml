<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision$ -->
    <chapter id="api.variables">
     <title>Variáveis</title>

     <sect1 id="variable.template.dir">
      <title>$template_dir</title>
      <para>
       Este é o nome padrão do diretório de template. Se você não fornecer
       um tipo de recurso quando incluir arquivos, então ele irá ser encontrado aqui. 
       Por padrão isso é "./templates", significando que isso irá
       olhar para o diretório de templates no mesmo diretório que está executando 
       o script PHP.
      </para>
	   <note>
		   <title>Notas Técnicas</title>
		   <para>
    	   Não é recomendado colocar este diretório sob um diretório 
	   document root do seu webserver.
    	   </para>
	  </note>
     </sect1>		
     <sect1 id="variable.compile.dir">
      <title>$compile_dir</title>
      <para>
       Esse é o nome do diretório onde os template compilados estão localizados
       Por padrão isso é "./templates_c", significando que isso irá
       olhar para o diretório de templates no mesmo diretório que está executando 
       o script PHP.
      </para>
	 <note>
	 <title>Notas Técnicas</title>
	 <para>
       Essa configuração deve ser  um path relativo ou um path absoluto.
       include_path não é usado para escrever em arquivos.
      </para>
	 </note>
	 <note>
	 <title>Notas Técnicas</title>
	 <para>
          Não é recomendado colocar este diretório sob um diretório 
	  document root do seu webserver.
      </para>
	 </note>
     </sect1>
     <sect1 id="variable.config.dir">
      <title>$config_dir</title>
      <para>
       Este é o diretório usado para armazenar arquivos de configuração usados nos
       templates. O padrão é "./configs", significando que isso irá
       olhar para o diretório de templates no mesmo diretório que está executando 
       o script PHP.
      </para>
	 <note>
	 <title>Notas Técnicas</title>
	 <para>
          Não é recomendado colocar este diretório sob um diretório 
	  document root do seu webserver.
      </para>
	 </note>
     </sect1>
     <sect1 id="variable.plugins.dir">
      <title>$plugins_dir</title>
      <para>
	   Esse é o diretório onde Smarty irá procurar por plugins que são necessários.
	   O Padrão é "plugins" sob o SMARTY_DIR. Se vocêes especificar um
	   path relativo, Smarty irá primeiro procurar sob o SMARTY_DIR, então
	   relativo para o cwd (current working directory), então relativo para cada
	   entrada no seu PHP include path.
      </para>
	  <note>
	  <title>Notas técnicas</title>
	  <para>
	  Para uma melhor performance, não configure seu plugins_dir para ter que usar o
	  PHP include path. Use um path absoluto, ou um path relativo para
	  SMARTY_DIR ou o cwd.
	  </para>
	  </note>
     </sect1>
     <sect1 id="variable.debugging">
      <title>$debugging</title>
      <para>
       Isso habilita o <link
        linkend="chapter.debugging.console">debugging console</link>.
       O console é uma janela de javascript que informa à você
       sobre os arquivos de template incluídos e variáveis
       destinadas para a página de template atual.
      </para>
     </sect1>
     <sect1 id="variable.debug.tpl">
      <title>$debug_tpl</title>
      <para>
	   Este é o nome do arquivo de template usado para o console de debug. 
	   Por padrão, é nomeado como debug.tpl e está localizado no <link
	   linkend="constant.smarty.dir">SMARTY_DIR</link>.
      </para>
     </sect1>
     <sect1 id="variable.debugging.ctrl">
      <title>$debugging_ctrl</title>
      <para>
       Isso permite caminhos alternativos de habilitar o debug. NONE não significa
       que métodos alternativos são permitidos. URL significa quando a palavra
       SMARTY_DEBUG foi encontrado na QUERY_STRING, que o debug está habilitado
       para a chamada do script.
       Se $debugging é true, esse valor é ignorado.
      </para>
     </sect1>
     <sect1 id="variable.global.assign">
      <title>$global_assign</title>
      <para>
       Essa é a lista de variáveis que estão sempre implicitamente fixadas
       para o template engine. Isso está acessível para fazer variáveis
       globais ou variáveis do servidor disponíveis para todo o template
       sem ter que fixá-las manualmente. Cada elemento em
       $global_assign deve ser um nome de uma variável global,
       ou um par de chave/valor, onde a chave é o nome do array global
       array e o valor é o array de variáveis fixadas deste array global. $SCRIPT_NAME é 
       globalmente fixado por padrão
       para $HTTP_SERVER_VARS.
      </para>
	 <note>
	 <title>Notas Técnicas</title>
	 <para>
       Variáveis de servidor podem ser acessadas através da variável
       $smarty, como {$smarty.server.SCRIPT_NAME}. Veja a seção
       da variável
       <link linkend="language.variables.smarty">$smarty</link>.
      </para>
	 </note>
     </sect1>
     <sect1 id="variable.undefined">
      <title>$undefined</title>
      <para>
       Isso seta o valor de $undefined para Smarty, o padrão é null.
       Atualmente isso é somente usado para setar variáveis indefinidas em
       $global_assign para o valor padrão.
      </para>
     </sect1>
     <sect1 id="variable.autoload.filters">
      <title>$autoload_filters</title>
      <para>
       Se há algum filtro que você deseja carregar em cada chamada de template,
       você pode especificar-lhes usando essa variável e a Smarty irá
       automaticamente carregá-los para você. A variável é um array associativo
       onde as chaves são tipos de filtro e os valores são arrays de nomes de filtros. 
       Por exemplo:
       <informalexample>
        <programlisting>
$smarty-&gt;autoload_filters = array('pre' =&gt; array('trim', 'stamp'),
                                  'output' => array('convert')); 
        </programlisting>
       </informalexample> 
      </para>
     </sect1>
     <sect1 id="variable.compile.check">
      <title>$compile_check</title>
      <para>
	   Em cima de cada requisição da aplicação PHP , Smarty testa para ver se o
	   template atual foi alterado (diferentes time stamp) desde a última 
	   compilação. Se isso foi alterado, ele irá recompilar o template. Se o template
	   não foi compilado, ele irá compilar de qualquer maneira dessa configuração.
	   Por padrão esta variável é setada como true. Uma vez que a aplicação está
	   em produção (templates não serão alterados), o passo compile_check
	   não é necessário. Tenha certeza de setar $compile_check para "false" para
	   maior performance. Note que se você alterar isso para "false" e o
	   arquivo de template está alterado, você *não* irá ver a alteração desde que
	   o template seja recompilado. Se caching está habilitado e
	   compile_check está habilitado, então os arquivos de cache não serão regerados se
	   um complexo arquivo de ou um arquivo de configuração foi atualizado. Veja <link
	   linkend="variable.force.compile">$force_compile</link> ou <link
	   linkend="api.clear.compiled.tpl">clear_compiled_tpl</link>.
      </para>
     </sect1>
     <sect1 id="variable.force.compile">
      <title>$force_compile</title>
      <para>
       Isso força Smarty para (re)compilar templates a cada requisição.
       Essa configuração sobreescreve $compile_check. Por padrão
       isso está desabilitado. Isso é útil para desenvolvimento e debug.
       Isso nunca deve ser usado em ambiente de produção. Se caching
       está habilitado, os arquivo(s) de cache serão regerados à todo momento.
      </para>
     </sect1>
     <sect1 id="variable.caching">
      <title>$caching</title>
      <para>
	   Isto diz à Smarty se há ou não saída de cache para o template.
	   Por padrão isso está setado para 0, ou desabilitado. Se seu template gerar
	   conteúdo redundante, é necessário ligar o caching. Isso
	   irá resultar num ganho significativo de performance. Você pode também ter múltiplos
	   caches para o mesmo template. Um valor de 1 ou 2 caching habilitados. 1 diz
	   à Smarty para usar a variável atual $cache_lifetime para  determinar se o 
	   cache expirou. Um valor 2 diz à Smarty para usar o valor cache_lifetime
	   então para quando o cache foi gerado. Desta maneira você pode setar o
	   cache_lifetime imediatamente antes de buscar o template para ter controle
	   sobre quando este cache em particular expira. Veja também <link
	   linkend="api.is.cached">is_cached</link>.
      </para>
      <para>
	   Se $compile_check está habilitado, o conteúdo do cache irá ser regerado se
	   algum dos templates ou arquivos de configuração que são parte deste cache estiverem
	   alterados. Se $force_compile está habilitado, o conteúdo do cache irá sempre ser
	   regerado.
      </para>
     </sect1>
     <sect1 id="variable.cache.dir">
      <title>$cache_dir</title>
      <para>
       Isso é o nome do diretório onde os caches do template são 
       armazenados. Por padrão isso é "./cache", significando que isso irá olhar
       para o diretório de cache no mesmo diretório que executar scripts PHP.
       Você pode tambe usar sua própria função customizada de manuseamento de cache
       para manipular arquivos de cache,
       que irão ignorar esta configuração.
      </para>
	  <note>
	  <title>Notas Técnicas</title>
	  <para>
       Essa configuração deve ser ou um relativo 
       ou absoluto path. include_path não é usado para escrever em arquivos.
      </para>
	  </note>
	  <note>
		  <title>Notas Técnicas</title>
		  <para>
    	   Não é recomendado colocar este diretório sob um diretório 
	   document root do seu webserver.
    	  </para>
	  </note>
     </sect1>
     <sect1 id="variable.cache.lifetime">
      <title>$cache_lifetime</title>
      <para>
	   Isso é o comprimento de tempo em segundos que um cache de template é válido.
	   Uma vez que este tempo está expirado, o cache irá ser regerado. $caching deve
	   ser configurado para "true" para $cache_lifetime para ter algum propósito. Um valor de -1
	   irá forçar o cache a nunca expirar. Um valor de 0 irá fazer com que o cache seja sempre regerado 
	   (bom somente para testes, o método mais eficiente de desabilitar caching é setá-lo para
	   <link
	   linkend="variable.caching">$caching</link> = false.)
      </para>
	  <para>
	   Se <link linkend="variable.force.compile">$force_compile</link> está
	   habilitado, os arquivos de cache serão regerados todo o tempo, eficazmente
	   desativando caching. Você pode limpar todos os arquivos de cache com a função <link
	   linkend="api.clear.all.cache">clear_all_cache()</link>, ou
	   arquivos individuais de cache (ou grupos) com a função <link
	   linkend="api.clear.cache">clear_cache()</link>.
	  </para>
	  <note>
	  <title>Notas Técnicas</title>
	  <para>
	  Se você quiser dar para certos templates seu próprio tempo de vida de um cache, 
	  você poderia fazer isso configurando <link linkend="variable.caching">$caching</link> = 2,
	  então configure $cache_lifetime para um único valor somente antes de chamar display()
	  ou fetch().
	  </para>
	  </note>
     </sect1>
     <sect1 id="variable.cache.handler.func">
      <title>$cache_handler_func</title>
      <para>
       Você pode fornecer uma função padrão para manipular arquivos de cache ao invés de
       usar o método built-in usando o $cache_dir. Veja a 
       seção <link linkend="section.template.cache.handler.func">cache
       handler function section</link> para obter detalhes.
      </para>
     </sect1>
     <sect1 id="variable.cache.modified.check">
      <title>$cache_modified_check</title>
      <para>
       Se configurado para true, Smarty irá respeitar o If-Modified-Since
       header enviado para o cliente. Se o timestamp do arquivo de cache
       não foi alterado desde a última visita, então um header "304 Not Modified" 
       irá ser enviado ao invés do conteúdo. Isso funciona somente em arquivos
       de cache sem tags <command>insert</command>.
      </para>
     </sect1>
     <sect1 id="variable.config.overwrite">
      <title>$config_overwrite</title>
      <para>
       Se configurado para true, variáveis lidas no arquivo de configurações irão sobrescrever
       uma a outra. Do contrário, as variáveis serão guardadas em um array. Isso é
	   útil se você quer armazenar arrays de dados em arquivos de configuração, somente lista
	   tempos de cada elemento múltiplo. true por padrão.
      </para>
     </sect1>
     <sect1 id="variable.config.booleanize">
      <title>$config_booleanize</title>
      <para>
	   Se setado para true, os valores do arquivo de configuração de on/true/yes e off/false/no
	   ficará convertido para valores booleanos automaticamente. Desta forma você pode usar os
	   valores em um template como: {if #foobar#} ... {/if}. Se foobar estiver
	   on, true ou yes, a condição {if} irá executar. true por padrão.
      </para>
     </sect1>
     <sect1 id="variable.config.read.hidden">
      <title>$config_read_hidden</title>
      <para>
	   Se configurado para true, esconde seções (nomes de seções começados com um período)
	   no arquivo de configuração podem ser lidos do template. Tipicamente você deixaria
	   isto como false, desta forma você pode armazenar dados sensitivos no arquivo de configuração
	   como um parâmetro de banco de
	   dados e sem preocupar-se sobre o template carregá-los. false é o padrão.
	   </para>
     </sect1>
     <sect1 id="variable.config.fix.newlines">
      <title>$config_fix_newlines</title>
      <para>
	   Se setado para true, mac e dos newlines (\r e \r\n) no arquivo de configuração serão
	   convertidos para \n quando eles forem interpretados. true é o padrão.
	   </para>
     </sect1>
     <sect1 id="variable.default.template.handler.func">
      <title>$default_template_handler_func</title>
      <para>
       Essa função é chamada quando um template não pode ser obtido
       de seu recurso.
      </para>
     </sect1>
     <sect1 id="variable.php.handling">
      <title>$php_handling</title>
      <para>
       Isso diz à Smarty como manipular códigos PHP contido nos
       templates. Há quatro possíveis configurações, padrão sendo
       SMARTY_PHP_PASSTHRU. Note que isso NÃO fará efeito com códigos php
       dentro de tags <link linkend="language.function.php">{php}{/php}</link>
       no template.
      </para>    
      <itemizedlist>
       <listitem><para>SMARTY_PHP_PASSTHRU - Smarty echos tags as-is.</para></listitem>
       <listitem><para>SMARTY_PHP_QUOTE - Smarty quotes the
       tags as html entities.</para></listitem>
       <listitem><para>SMARTY_PHP_REMOVE - Smarty
       irá remover as tags do template.</para></listitem>
       <listitem><para>SMARTY_PHP_ALLOW - Smarty irá executar as 
       tags como códigos PHP.</para></listitem>
      </itemizedlist>
      <para>
       NOTE: Usando códigos PHP code dentro de templates é altamente desencorajado.
       Use <link linkend="language.custom.functions">custom functions</link> ou
       <link linkend="language.modifiers">modifiers</link> ao invés disso.
      </para>
     </sect1>
     <sect1 id="variable.security">
      <title>$security</title>
      <para>
       $security true/false, o padrão é false. Security é bom para situações
       quando você tem partes inconfiáveis editando o template
       (via ftp por exemplo) e você quer reduzir os riscos de comprometimento
       da segurança do sistema através da linguagem de template.
       Habilitando-o faz-se cumprir as regras da linguagem de template,
       a menos que especificamente cancelada com $security_settings:
      </para>
      <itemizedlist>
       <listitem><para>Se $php_handling está setado para SMARTY_PHP_ALLOW, isso é implicitamente
         alterado para SMARTY_PHP_PASSTHRU</para></listitem>
       <listitem><para>Funçõs PHP não são permitidas em blocos IF,
         exceto estes especificados no $security_settings</para></listitem>
       <listitem><para>templates podem ser somente incluidos no diretório
         listado em $secure_dir array</para></listitem>
       <listitem><para>Arquivos locais podem ser somente trazidos do diretório
         listado em $secure_dir usando no array {fetch}</para></listitem>
       <listitem><para>Estas tags {php}{/php} não são permitidas</para></listitem>
       <listitem><para>Funções PHP não são permitidas como modificadores, exceto 
         estes especificados no $security_settings</para></listitem>
      </itemizedlist>
     </sect1>
     <sect1 id="variable.secure.dir">
      <title>$secure_dir</title>
      <para>
       Isso é um array de todos os diretórios locais que são considerados
       seguros. {include} e {fetch} usam estes (diretórios) quando security está habilitado.
      </para>
     </sect1>
     <sect1 id="variable.security.settings">
      <title>$security_settings</title>
      <para>
       Essas configurações são usadas para cancelar ou especificar configurações
       de segurança quando security está habilitado. Estas possuem as seguintes configurações possíveis:
      </para>
      <itemizedlist>
       <listitem><para>PHP_HANDLING - true/false. Se setado para true,
         a configuração de $php_handling não é checada para security.</para></listitem>
       <listitem><para>IF_FUNCS - Isso é um array de nomes de funções PHP permitidas
         nos blocos IF.</para></listitem>
       <listitem><para>INCLUDE_ANY - true/false. Se setado para true, algum
         template pode ser incluído para um arquivo do sistema, apesar de toda a lista de
         $secure_dir.</para></listitem>
       <listitem><para>PHP_TAGS - true/false. Se setado para true, as tags {php}{/php}
         são permitidas nos templates.</para></listitem>
       <listitem><para>MODIFIER_FUNCS - Isso é um array de nomes de funções PHP permitidas
         usadas como modificadores de variável.</para></listitem>
      </itemizedlist>
     </sect1>
     <sect1 id="variable.trusted.dir">
      <title>$trusted_dir</title>
      <para>
	   $trusted_dir  somente usado quando $security está habilitado. Isso é um array
	   de todos os diretórios que são considerados confiáveis. Diretórios confiáveis
	   são onde você irá deixar seus scripts php que são executados diretamente para o
	   template com <link linkend="language.function.include.php">{include_php}</link>.
      </para>
     </sect1>
     <sect1 id="variable.left.delimiter">
      <title>$left_delimiter</title>
      <para>
       Este é o delimitador esquerdo usado para a linguagem de template.
       O padrão é "{".			
      </para>
     </sect1>
     <sect1 id="variable.right.delimiter">
      <title>$right_delimiter</title>
      <para>
       Este é o delimitador direito usado para a linguagem de template.
       O padrão é "}".			
      </para>
     </sect1>
     <sect1 id="variable.compiler.class">
      <title>$compiler_class</title>
      <para>
       Especifica o nome do compilador de classes que
       Smarty irá usar para compilar templates. O padrão é 'Smarty_Compiler'.
       Para usuários avançados somente.
      </para>
     </sect1>
     <sect1 id="variable.request.vars.order">
      <title>$request_vars_order</title>
      <para>
       A ordem na qual as variáveis requeridas serão registradas, similar ao
       variables_order no php.ini
      </para>
     </sect1>
     <sect1 id="variable.request.use.auto.globals">
      <title>$request_use_auto_globals</title>
      <para>
	   Especifica se a Smarty deve usar variáveis globais do php $HTTP_*_VARS[]
	   ($request_use_auto_globals=false que é o valor padrão) ou
	   $_*[] ($request_use_auto_globals=true). Isso afeta templates
	   que fazem uso do {$smarty.request.*}, {$smarty.get.*} etc. .
	   Atenção: Se você setar $request_use_auto_globals para true, <link
	   linkend="variable.request.vars.order">variable.request.vars.order
	   </link> não terão efeito mas valores de configurações do php
	   <literal>gpc_order</literal> são usados.
      </para>
     </sect1>
     <sect1 id="variable.compile.id">
      <title>$compile_id</title>
      <para>
	   Identificador de compilação persistente. Como uma alternativa
	   para passar o mesmo compile_id para cada chamada de função, você
	   pode setar este compile_id e isso irá ser usado implicitamente após isso.
      </para>
     </sect1>
     <sect1 id="variable.use.sub.dirs">
      <title>$use_sub_dirs</title>
      <para>
	  Configure isso para false se seu ambiente de PHP não permite a criação de
	  subdiretórios pela Smarty. Subdiretórios são muito eficientes, então use-os se você
	  conseguir. 
      </para>
     </sect1>
     <sect1 id="variable.default.modifiers">
      <title>$default_modifiers</title>
      <para>
	  Isso é um array de modificadores implicitamente aplicados par cada
	  variável no template. Por Exemplo, para cada variável HTML-escape por padrão,
	  use o array('escape:"htmlall"'); Para fazer a variável isenta para modificadores
	  padrão, passe o modificador especial "smarty" com um valor de parâmetro "nodefaults"
	  modificando isso, como
	  {$var|smarty:nodefaults}.
      </para>
     </sect1>
     <sect1 id="variable.default.resource.type">
      <title>$default_resource_type</title>
      <para>
	  Isso diz à Smarty qual tipo de recurso usar implicitamente.
	  O valor padrão é 'file', significando que $smarty->display('index.tpl'); e
	  $smarty->display('file:index.tpl'); são idênticos no significado.
	  Veja o capítulo  <link linkend="template.resources">resource</link> para detalhes.
      </para>
     </sect1>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->