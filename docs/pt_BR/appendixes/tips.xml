<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision$ -->
<chapter id="tips">
   <title>Dicas &amp; Truques</title>
   <para>
   </para>
   <sect1 id="tips.blank.var.handling">
		<title>Manipulação de Variável Vazia</title>
		<para>
		Quando você quer algumas vezes imprimir um valor que você definir para uma variável vazia 
		ao invés de imprimir nada, tal como imprimindo "&amp;nbsp;" a fim de que plano de fundo de tabelas
		funcionem corretamente. Muitos usariam uma instrução {if} para manipular isto, mas há um 
		macete com o Smarty, usando o modificador de variável 
		<emphasis>default</emphasis>.
		</para>
<example>
<title>Imprimindo &amp;nbsp; quando uma variável está vazia</title>
<programlisting>

{* A forma mais longa *}

{if $title eq ""}
	&amp;nbsp;
{else}
	{$title}
{/if}


{* A forma mais simples *}

{$title|default:"&amp;nbsp;"}</programlisting>
</example>
	</sect1>

    <sect1 id="tips.default.var.handling">
		<title>Manipulação do valor padrão de Variável</title>
		<para>
		Se uma variável é usada freqüentemente em seus templates, aplicando o modificador
		default toda vez que ela é mencionado pode evitar um bit desagradável. Você pode remediar isto
		 pela atribuição de um valor padrão para a variável com a função 
		 <link linkend="language.function.assign">assign</link>.
		</para>
<example>
<title>Atribuindo o valor padrão para uma variável de template</title>
<programlisting>
{* faça isto em algum lugar no topo de seu template *}
{assign var="titulo" value=$titulo|default:"sem título"}

{* Se o $titulo estava vazio, ele agora contém o valor "sem titulo" quando você exibí-lo *}
{$title}</programlisting>
</example>
	</sect1>
    <sect1 id="tips.passing.vars">
		<title>Passando a variável titulo para o template de cabeçalho</title>
		<para>
		Quando a maioria de seus templates usam os mesmos cabeçalhos e mesmos rodapés, é
		comum dividi-los um em cada template e então incluí-los. Mas o que fazer se o 
		cabeçalho precisa ter um titulo diferente, dependendo de que página ele está vindo? 
		Você pode passar o titulo para o 
		cabeçalho quando ele é incluído.
		</para>
<example>
<title>Passando a variável titulo para o template de cabeçalho</title>
<programlisting>

mainpage.tpl
------------

{include file="header.tpl" titulo="Página Principal"}
{* O corpo do template vem aqui *}
{include file="footer.tpl"}


archives.tpl
------------

{config_load file="archive_page.conf"}
{include file="header.tpl" titulo=#archivePageTitle#}
{* O corpo do template vem aqui *}
{include file="footer.tpl"}


header.tpl
----------
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;TITLE&gt;{$titulo|default:"BC News"}&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;


footer.tpl
----------
&lt;/BODY&gt;
&lt;/HTML&gt;</programlisting>
</example>
	<para>
		Quando a página principal é atraída, o título da "Página Principal" é passado para o template
		header.tpl, e será  subseqüencialmente usado com o título. Quando a página de arquivamento é atraída,
		o título será  "Archives". Note no exemplo de archive, nós estamos usando uma variável do arquivo
		archives_page.conf ao invés de uma variável codificada rígida. 
		Também note que "BC news" é exibida se
		a variável $titulo não está definida,
		usando o modificador de variável <emphasis>default</emphasis>.
	</para>
	</sect1>
    <sect1 id="tips.dates">
       <title>Datas</title>
       <para>
	   Como uma regra básica, sempre passe datas para o smarty como timestamps. Isto permite ao
	   desenhista de template utilizar <link linkend="language.modifier.date.format">date_format</link>
	   para controle completo sobre a formatação de data, 
	   e também facilita a comparação de datas se
	   necessário.
       </para>
       <para>
       NOTA: No Smarty 1.4.0, você pode passar datas para o Smarty como timestamps unix,
       mysql, ou qualquer outra data interpretável por strtotime().
       </para>
<example>
<title>Usando date_format</title>
<programlisting>
{$startDate|date_format}

SAÍDA:

Jan 4, 2001


{$startDate|date_format:"%Y/%m/%d"}

SAÍDA:

2001/01/04


{if $date1 &lt; $date2}
	...
{/if}</programlisting>
</example>
		<para>
         Quando usando {html_select_date} em um template, o programador normalmente vai querer converter
         a saída de um formulário de volta para o formato de timestamp. Aqui está uma função para ajudar
         com isso.
		</para>
<example>
<title>Convertendo elementos em forma de data de volta para um timestamp</title>
<programlisting>
// isto assume que a forma de seus elementos são nomeadas como
// startDate_Day, startDate_Month, startDate_Year

$startDate = makeTimeStamp($startDate_Year,$startDate_Month,$startDate_Day);

function makeTimeStamp($year="",$month="",$day="")
{
	if(empty($year))
		$year = strftime("%Y");
	if(empty($month))
		$month = strftime("%m");
	if(empty($day))
		$day = strftime("%d");

	return mktime(0,0,0,$month,$day,$year);
}</programlisting>
</example>
	</sect1>
    <sect1 id="tips.wap">
		<title>WAP/WML</title>
		<para>
        Os templates WAP/WML requerem um cabeçalho de Content-Type de PHP para ser passado junto com
        template. A forma mais fácil de fazer isto seria escrever uma função customizada que imprime
        o cabeçalho. Se você está usando sistema de caching, esse não funcionará, então nós faremos isso
        usando a tag de insert (lembre que tags de insert não são "cached!") Certifique-se que não há saída
        para o navegador antes do template,
        senão o cabeçalho irá falhar.
		</para>
<example>
<title>Usando insert para escrever um cabeçalho WML Content-Type</title>
<programlisting>
// esteja certo que o apache está configurado para as extensões .wml !                                    
// ponha esta função em algum lugar de sua aplicação, ou em Smarty.addons.php
function insert_header() {
    // esta função espera o argumento $content
    extract(func_get_arg(0));
    if(empty($content))
        return;
    header($content);
    return;
}

// seu template Smarty  _deve_ começar com a insert tag, olha o exemplo:

{insert name=header content="Content-Type: text/vnd.wap.wml"}

&lt;?xml version="1.0"?&gt;  
&lt;!DOCTYPE wml PUBLIC "-//WAPFORUM//DTD WML 1.1//EN" "http://www.wapforum.org/DTD/wml_1.1.xml"&gt; 

&lt;!-- begin new wml deck --&gt; 
&lt;wml&gt; 
&lt;!-- begin first card --&gt; 
&lt;card&gt; 
&lt;do type="accept"&gt; 
&lt;go href="#two"/&gt; 
&lt;/do&gt;  
&lt;p&gt; 
Bem-vindo ao WAP com Smarty!
Pressione OK para continuar...  
&lt;/p&gt; 
&lt;/card&gt;  
&lt;!-- begin second card --&gt; 
&lt;card id="two"&gt;  
&lt;p&gt; 
Bem fácil isso, não é?
&lt;/p&gt; 
&lt;/card&gt; 
&lt;/wml&gt;</programlisting>
</example>
	</sect1>
	<sect1 id="tips.componentized.templates">
		<title>Templates componentizados</title>
		<para>
		Esta dica é um pouco de hack, mas ainda é uma idéia limpa.
		Use-a por seu próprio risco. ;-)
		</para>
		<para>
         Tradicionalmente, programar templates em suas aplicações segue esta forma:
         Primeiro, você acumula suas variáveis dentro de sua aplicação PHP, (talvez com requisições
         de banco de dados.) Então, você instancia seu objeto Smarty, atribui valores às variáveis
         e exibe o template. Por exemplo nós temos um registrador de estoque em nosso template.
         Nós coletaríamos os dados estocagem em nossa aplicação, então damos valor a estas variáveis
         no template e o exibimos. Agora isso seria legal 
         se você adicionasse este registrador de 
         armazenamento (stock ticker) para qualquer aplicação simplesmente incluindo o template, e sem
         se preocupar com a busca de dados mais a frente?
		</para>
        <para>
        Você pode embutir o PHP dentro de seus templates com as tags {php}{/php}.
        Com isto, você pode configurar templates independentes, tendo a sua própria
        estrutura de dados para dar valor às suas próprias variáveis. Com a lógica embutida
        dessa forma, você pode manter a lógica do template &amp; junto. Desta maneira não é
        importante de onde o fonte do
        template está vindo, ele está sempre junto como um componente.
        </para>
<example>
<title>Template componentizado</title>
<programlisting>
{* Smarty *}

{php}

	// configurar nossa função para buscar dados armazenados
	function fetch_ticker($symbol,&amp;$ticker_name,&amp;$ticker_price) {
		// ponha a lógica aqui que procura $ticker_name
		// e $ticker_price de algum recurso
	}

	// chama a função
	fetch_ticker("YHOO",$ticker_name,$ticker_price);
	
	// passando valores às variáveis de template
    $this->assign("ticker_name",$ticker_name);
    $this->assign("ticker_price",$ticker_price);

{/php}

Nome do Estoque: {$ticker_name} Preço do Estoque: {$ticker_price}</programlisting>
</example>
        <para>
		No Smarty 1.5.0, há até uma forma mais limpa. Você pode incluir o php em seus templates com
		a tag {include_php ...}. 
		Desta forma você pode manter a lógica do PHP separada da lógica do 
		template. Veja a função <link linkend="language.function.include.php">include_php</link> para
		mais informação.
        </para>
<example>
<title>Template componentizado com include_php</title>
<programlisting>
load_ticker.php
---------------

&lt;?php
	// configura nossa função para buscar os dados armazenados
	function fetch_ticker($symbol,&amp;$ticker_name,&amp;$ticker_price) {
		// ponha aqui a lógica que procura $ticker_name
		// e $ticker_price de algum recurso
	}

	// chama a função
	fetch_ticker("YHOO",$ticker_name,$ticker_price);
	
	// passar valores para as variáveis de template
    $this->assign("ticker_name",$ticker_name);
    $this->assign("ticker_price",$ticker_price);
?&gt;


index.tpl
---------

{* Smarty *}

{include_php file="load_ticker.php"}

Nome do Estoque: {$ticker_name} Preço do Estoque: {$ticker_price}</programlisting>
</example>
	</sect1>
	<sect1 id="tips.obfuscating.email">
		<title>Ofuscando endereços de E-mail</title>
		<para>
		 Você deseja saber como seu endereço de E-mail consegue entrar em tantas listas de email de spam?
		 A única forma de spammers coletar endereços de E-mail é de páginas da web. Para ajudar a combater
		 este problema, você pode fazer o seu endereço de E-mail aparecer em javascript misturado no 
		 código HTML, mesmo assim ele aparecerá e funcionará corretamente no navegador. Isto é feito com
		 o plugin mailto.
		</para>
<example>
<title>Exemplo de ofuscamento de um Endereço de E-mail</title>
<programlisting>

index.tpl
---------

envia inquisição para
{mailto address=$EmailAddress encode="javascript" subject="Olá"}

</programlisting>
</example>
	<note>
	<title>Nota técnica</title>
	<para>
	Este método não é 100% a prova de falha. Um spammer poderia criar um programa
	para coletar o e-mail e para decodificar estes valores, mas não é muito comum.
	</para>
	</note>
	</sect1>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->