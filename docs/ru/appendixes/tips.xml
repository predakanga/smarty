<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision$ -->
<chapter id="tips">
   <title>Уловки</title>
   <para>
   </para>
   <sect1 id="tips.blank.var.handling">
		<title>Обработка пустых переменных</title>
		<para>
		Иногда, например, для того чтобы фон таблицы работал корректно, 
		необходимо вывести вместо пустого значения переменной, значение 
		по умолчанию "&amp;nbsp;". Многие бы использовали конструкцию {if},
		но есть более короткий путь в Smatry используя <emphasis>default</emphasis>
		модификатор переменной.
		</para>
<example>
<title>Вывод &amp;nbsp; когда переменная пуста</title>
<programlisting>

{* длинный путь *}

{if $title eq ""}
	&amp;nbsp;
{else}
	{$title}
{/if}


{* короткий путь *}

{$title|default:"&amp;nbsp;"}</programlisting>
</example>
	</sect1>

    <sect1 id="tips.default.var.handling">
		<title>Обработка переменных по умлочанию</title>
		<para>
		Если переменная встречается часто, то использование модификатора 
		default каждый раз можно избежать, используя функцию
		<link linkend="language.function.assign">assign</link>.
		</para>
<example>
<title>Назначение переменной шаблона значения по умолчанию</title>
<programlisting>
{* вверху шаблона *}
{assign var="title" value=$title|default:"no title"}

{* если переменная $title была пустой, то сейчас она содержит "no title" *}
{$title}</programlisting>
</example>
	</sect1>
    <sect1 id="tips.passing.vars">
		<title>Присвоение переменной заголовка (title) заголовку шаблона.</title>
		<para>
        Rогда большинство ваших шаблонов имеют похожие верхние части 
        и нижние, то имеет смысл вынести их в отдельные файлы. Но если 
        шапка должна иметь различные заголовки на различных страницах? 
        Вы можете передать заголовок в шапку, когда она присоединяеться.
		</para>
<example>
<title>Присвоение переменной заголовка (title) заголовку шаблона.</title>
<programlisting>

mainpage.tpl
------------

{include file="header.tpl" title="Main Page"}
{* тело шаблона *}
{include file="footer.tpl"}


archives.tpl
------------

{config_load file="archive_page.conf"}
{include file="header.tpl" title=#archivePageTitle#}
{* тело шаблонаe *}
{include file="footer.tpl"}


header.tpl
----------
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;TITLE&gt;{$title|default:"BC News"}&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;


footer.tpl
----------
&lt;/BODY&gt;
&lt;/HTML&gt;</programlisting>
</example>
	<para>
		Если выводится главная страница, то заголовок будет "Main Page",
		если архивы, то заголовк берется из файла конфигурации. Если 
		заголовок будет пустой, то выведеться значение по умолчанию "BC News".
	</para>
	</sect1>
    <sect1 id="tips.dates">
       <title>Даты</title>
       <para>
		Обычно даты в Smarty всегда передаются как timestamps, что
		позволяет проектировщикам шаблона использовать <link
		linkend="language.modifier.date.format">date_format</link>
		для полного над форматированием даты, и также делает легким 
		сравнение дат если необходимо.
       </para>
       <para>
       ЗАМЕЧАНИЕ: От Smarty 1.4.0 вы можете передавать даты как unix
       timestamps, mysql timestamps, или любые другие даты, которые 
       обработаются strtotime().
       </para>
<example>
<title>использование date_format</title>
<programlisting>
{$startDate|date_format}

ВЫВОД:

Jan 4, 2001


{$startDate|date_format:"%Y/%m/%d"}

ВЫВОД:

2001/01/04


{if $date1 < $date2}
	...
{/if}</programlisting>
</example>
		<para>
		Когда {html_select_date} используется в шаблоне, программисты обычно 
		хотят получить дату виде timestamp. Фот функция, которая поможет это
		сделать.
		</para>
<example>
<title>Преобразование элементов формы ввода даты назад к timestamp</title>
<programlisting>
// Предполагается, что ваши элементы формы названы
// startDate_Day, startDate_Month, startDate_Year

$startDate = makeTimeStamp($startDate_Year,$startDate_Month,$startDate_Day);

function makeTimeStamp($year="",$month="",$day="")
{
	if(empty($year))
		$year = strftime("%Y");
	if(empty($month))
		$month = strftime("%m");
	if(empty($day))
		$day = strftime("%d");

	return mktime(0,0,0,$month,$day,$year);
}</programlisting>
</example>
	</sect1>
    <sect1 id="tips.wap">
		<title>WAP/WML</title>
		<para>
		WAP/WML шаблоны требуют, чтобы PHP content-type заголовки были
		переданы вместе с шаблоном. Простейший путь - написать 
		пользовательскую функцию, которая будет выводить заголовки. 
		Так как мы будем пользоваться тэгами insert то заголовки не будут 
		кэшироваться. Так же ничего не должно выводиться в браузер до 
		шаблона, иначе заголовки могут быть неправильно восприняты.
		</para>
<example>
<title>Bспользование insert для записи WML Content-Type заголовков</title>
<programlisting>
// Apache должен быть сконфигурирован с .wml расширением!
// поместите эту функцию в приложение, или в  Smarty.addons.php
function insert_header() {
    // this function expects $content argument
    extract(func_get_arg(0));
    if(empty($content))
        return;
    header($content);
    return;
}

// шаблон ДОЛЖЕН начинаться с тэга insert. Пример:
{insert name=header content="Content-Type: text/vnd.wap.wml"}

&lt;?xml version="1.0"?&gt;  
&lt;!DOCTYPE wml PUBLIC "-//WAPFORUM//DTD WML 1.1//EN" "http://www.wapforum.org/DTD/wml_1.1.xml"&gt; 

&lt;!-- begin new wml deck --&gt; 
&lt;wml&gt; 
&lt;!-- begin first card --&gt; 
&lt;card&gt; 
&lt;do type="accept"&gt; 
&lt;go href="#two"/&gt; 
&lt;/do&gt;  
&lt;p&gt; 
Welcome to WAP with Smarty!
Press OK to continue...  
&lt;/p&gt; 
&lt;/card&gt;  
&lt;!-- begin second card --&gt; 
&lt;card id="two"&gt;  
&lt;p&gt; 
Pretty easy isn't it?
&lt;/p&gt; 
&lt;/card&gt; 
&lt;/wml&gt;</programlisting>
</example>
	</sect1>
	<sect1 id="tips.componentized.templates">
		<title>Составные шаблоны</title>
		<para>
		This tip is a bit of a hack, but still a neat idea. Use at your own
		risk. ;-)
		</para>
		<para>
        Traditionally, programming templates into your applications goes as
        follows: First, you accumulate your variables within your PHP
        application, (maybe with database queries.) Then, you instantiate your
        Smarty object, assign the variables and display the template. So lets
        say for example we have a stock ticker on our template. We would
        collect the stock data in our application, then assign these variables
        in the template and display it. Now wouldn't it be nice if you could
        add this stock ticker to any application by merely including the
        template, and not worry about fetching the data up front?
		</para>
        <para>
        You can embed PHP into your templates with the {php}{/php} tags.
        With this, you can setup self contained templates with their own
        data structures for assigning their own variables. With the logic
        embedded like this, you can keep the template & logic together. This
        way no matter where the template source is coming from, it is always
        together as one component.
        </para>
<example>
<title>componentized template</title>
<programlisting>
{* Smarty *}

{php}

	// setup our function for fetching stock data
	function fetch_ticker($symbol,&$ticker_name,&$ticker_price) {
		// put logic here that fetches $ticker_name
		// and $ticker_price from some resource
	}

	// call the function
	fetch_ticker("YHOO",$ticker_name,$ticker_price);
	
	// assign template variables
    $this->assign("ticker_name",$ticker_name);
    $this->assign("ticker_price",$ticker_price);

{/php}

Stock Name: {$ticker_name} Stock Price: {$ticker_price}</programlisting>
</example>
        <para>
		As of Smarty 1.5.0, there is even a cleaner way. You can include php in
		your templates with the {include_php ...} tag. This way you can keep
		your PHP logic separated from the template logic. See the <link
		linkend="language.function.include.php">include_php</link> function for
		more information.
        </para>
<example>
<title>componentized template with include_php</title>
<programlisting>
load_ticker.php
---------------

&lt;?php
	// setup our function for fetching stock data
	function fetch_ticker($symbol,&$ticker_name,&$ticker_price) {
		// put logic here that fetches $ticker_name
		// and $ticker_price from some resource
	}

	// call the function
	fetch_ticker("YHOO",$ticker_name,$ticker_price);
	
	// assign template variables
    $this->assign("ticker_name",$ticker_name);
    $this->assign("ticker_price",$ticker_price);
?&gt;


index.tpl
---------

{* Smarty *}

{include_php file="load_ticker.php"}

Stock Name: {$ticker_name} Stock Price: {$ticker_price}</programlisting>
</example>
	</sect1>
	<sect1 id="tips.obfuscating.email">
		<title>Obfuscating E-mail Addresses</title>
		<para>
		Do you ever wonder how your E-mail address gets on so many spam mailing
		lists? One way spammers collect E-mail addresses is from web pages. To
		help combat this problem, you can make your E-mail address show up in
		scrambled javascript in the HTML source, yet it it will look and work
		correctly in the browser. This is done with the mailto plugin.
		</para>
<example>
<title>Example of Obfuscating an E-mail Address</title>
<programlisting>

index.tpl
---------

Send inquiries to
{mailto address=$EmailAddress encode="javascript" subject="Hello"}

</programlisting>
</example>
	<note>
	<title>Technical Note</title>
	<para>
	This method isn't 100% foolproof. A spammer could conceivably program his
	e-mail collector to decode these values, but not likely.
	</para>
	</note>
	</sect1>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
