<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision$ -->
 <chapter id="api.variables">
  <title>Variablen</title>
  
  <sect1 id="variable.template.dir">
   <title>$template_dir</title>
   <para>
    Definiert das Standard-Template Verzeichnis. Wenn
    sie beim Einbinden von Templates keinen Ressourcen-Typ &uuml;bergeben,
    werden sie in diesem Pfad gesucht. Normalerweise lautet er './templates'.
    Das heisst, Smarty erwartet das Template-Verzeichnis im selben Verzeichnis
    wie das ausgef&uuml;hrte PHP-Skript.
   </para>
   <note>
    <title>Technische Bemerkung</title>
    <para>
     Dieses Verzeichnis sollte ausserhalb der DocumentRoot
     des Webservers liegen.
     	   </para>
   </note>
  </sect1>		
  <sect1 id="variable.compile.dir">
   <title>$compile_dir</title>
   <para>
    Definiert das Verzeichnis, in das die kompilierten Templates geschrieben
    werden. Normalerweise lautet es './templates_c'.
    Das heisst, Smarty erwartet das Kompilier-Verzeichnis im selben Verzeichnis 
    wie das ausgef&uuml;hrte PHP-Skript.
   </para>
   <note>
    <title>Technische Bemerkung</title>
    <para>
     Diese Einstellung kann als relativer oder als absoluter Pfad
     angegeben werden. 'include_path' wird nicht verwendet.
    </para>
   </note>
   <note>
    <title>Technische Bemerkung</title>
    <para>
     Dieses Verzeichnis sollte ausserhalb der DocumentRoot
     des Webservers liegen.
    </para>
   </note>
  </sect1>
  <sect1 id="variable.config.dir">
   <title>$config_dir</title>
   <para>
    Dieses Verzeichnis definiert den Ort, an dem die von den
    Templates verwendeten Konfigurationsdateien abgelegt sind. Normalerweise
    ist dies './configs'. Das bedeutet, Smarty erwartet das
    Konfigurations-Verzeichnis im selben Verzeichnis wie das ausgef&uuml;hrte
    PHP-Skript.
   </para>
   <note>
    <title>Technische Bemerkung</title>
    <para>
     Dieses Verzeichnis sollte ausserhalb der DocumentRoot
     des Webservers liegen.
    </para>
   </note>
  </sect1>
  <sect1 id="variable.plugins.dir">
   <title>$plugins_dir</title>
   <para>
    Definiert das Verzeichnis in welchem Smarty die zu ladenden Plugins sucht.
    Normalerweise ist dies 'plugins' im SMARTY_DIR Pfad. Wenn Sie einen relativen
    Pfad angeben, wird Smarty zuerst versuchen das Plugin von SMARTY_DIR aus zu erreichen,
    danach relativ zum aktuellen Verzeichnis (mit 'cwd' - current working directory)
    und zum Schluss in jedem Eintrag des PHP-'include_path'.
   </para>
   <note>
    <title>Technische Bemerkung</title>
    <para>
     F&uuml;r optimale Performance ist es sinnvoll, 'plugins_dir'
     absolut oder relativ zu SMARTY_DIR bzw. dem aktuellen Verzeichnis zu definieren.
     Von der Definition des Verzeichnisses im PHP-'include_path' wird abgeraten.
    </para>
   </note>
  </sect1>
  <sect1 id="variable.debugging">
   <title>$debugging</title>
   <para>
    Aktiviert die <link linkend="chapter.debugging.console">Debugging Konsole</link>.
    Die Konsole besteht aus einem Javascript-Fenster, welches Informationen zum
    momentan geladenen Template und den zugewiesenen Variablen enth&auml;lt.
   </para>
  </sect1>
  <sect1 id="variable.debug.tpl">
   <title>$debug_tpl</title>
   <para>
    Definiert den Namen des f&uuml;r die Debugging Konsole verwendeten Template. Normalerweise
    lautet er 'debug.tpl' und befindet sich im <link linkend="constant.smarty.dir">SMARTY_DIR</link> Verzeichnis.
   </para>
  </sect1>
  <sect1 id="variable.debugging.ctrl">
   <title>$debugging_ctrl</title>
   <para>
    Definiert Alternativen zur Aktivierung der Debugging Konsole.
    NONE verbietet alternative Methoden. URL aktiviert ds Debugging,
    wenn das Schl&uuml;sselwort 'SMARTY_DEBUG' im QUERY_STRING gefunden wird. 
    Wenn '$debugging' auf 'true' gesetzt ist, wird dieser Wert ignoriert.
   </para>
  </sect1>
  <sect1 id="variable.global.assign">
   <title>$global_assign</title>
   <para>
    Definiert eine Liste von Variablen die jedem Template automatisch
    zugewiesen werden. Dies ist n&uuml;tzlich falls man globale beziehungsweise Server-Variablen,
    zuweisen will, ohne dies von Hand zu tun. Jedes Element in '$global_assign' sollte
    entweder den Namen der zuzuweisenden Variablen enthalten, oder Schl&uuml;ssel/Wert-Paare,
    bei welchen der Schl&uuml;ssel den Namen des globalen Arrays definiert und der
    Wert den Array mit den zuzuweisenden Werten. '$SCRIPT_NAME' wird immer zugewiesen und
    aus '$HTTP_SERVER_VARS' bezogen.
   </para>
   <note>
    <title>Technische Bemerkung</title>
    <para>
     Server-Variablen k&ouml;nnen &uuml;ber die '$smarty'-Variable
     erreicht werden, zum Beispiel: {$smarty.server.SCRIPT_NAME}. 
     Konsultieren sie den Abschnitt zu <link linkend="language.variables.smarty">$smarty</link>
     f&uuml;r weiterf&uuml;hrende Informationen.
    </para>
   </note>
  </sect1>
  <sect1 id="variable.undefined">
   <title>$undefined</title>
   <para>
    Definiert den Wert von '$undefined' f&uuml;r Smarty. Normalerweise ist
    dieser Wert 'null'. Momentan wird er nur verwendet, um nicht definierten
    Elementen aus '$global_assign' einen Standardwert zuzuweisen.
   </para>
  </sect1>
  <sect1 id="variable.autoload.filters">
   <title>$autoload_filters</title>
   <para>
    Filter die Sie zu jedem Template laden m&ouml;chten, k&ouml;nnen Sie mit Hilfe
    dieser Variable festlegen. Smarty wird sie danach automatisch laden. Die Variable
    enth&auml;lt ein assoziatives Array, in dem der Schl&uuml;ssel den Filter-Typ 
    und der Wert den Filter-Namen definiert. Zum Beispiel:
    <informalexample>
     <programlisting>
      $smarty-&gt;autoload_filters = array('pre' =&gt; array('trim', 'stamp'),
      'output' => array('convert')); 
     </programlisting>
    </informalexample> 
   </para>
  </sect1>
  <sect1 id="variable.compile.check">
   <title>$compile_check</title>
   <para>
    Bei jedem Aufruf der PHP-Applikation &uuml;berpr&uuml;ft Smarty,
    ob sich das zugrundeliegende Template seit dem letzten Aufruf
    ge&auml;ndert hat. Falls es eine &Auml;nderung feststellt,
    wird das Template neu kompiliert. Seit Smarty 1.4.0 wird
    das Template - falls es nicht existiert - kompiliert, unabh&auml;ngig
    davon welcher Wert '$compile_check' hat. Normalerweise ist der
    Wert dieser Variable 'true'. Wenn eine Applikation produktiv
    eingesetzt wird (die Templates &auml;ndern sich nicht mehr), kann
    der 'compile_check'-Schritt entfallen. Setzen Sie dann
    '$compile_check' auf 'false', um die Performance zu steigern.
    Achtung: Wenn Sie '$compile_check' auf 'false' setzen und anschliessend
    ein Template &auml;ndern, wird diese &Auml;nderung *nicht* angezeigt.
    Wenn caching und 'compile_check' eingeschaltet sind, werden die
    gecachten Skripts neu kompiliert, sobald eine &Auml;nderung an
    einem der eingebundenen Templates festgestellt wird. 
    Siehe auch <link linkend="variable.force.compile">$force_compile</link>
    und <link linkend="api.clear.compiled.tpl">clear_compiled_tpl</link>.
   </para>
  </sect1>
  <sect1 id="variable.force.compile">
   <title>$force_compile</title>
   <para>
    Veranlasst Smarty dazu die Templates bei jedem Aufruf neu
    zu kompilieren. Diese Einstellung &uuml;berschreibt '$compile_check'.
    Normalerweise ist dies ausgeschaltet, kann jedoch f&uuml;r die Fehlersuche
    n&uuml;tzlich sein. In einem Produktiven-Umfeld sollte auf
    die Verwendung verzichtet werden. Wenn caching eingeschaltet ist,
    werden die gecachten Dateien bei jedem Aufruf neu kompiliert.
   </para>
  </sect1>
  <sect1 id="variable.caching">
   <title>$caching</title>
   <para>
    Definiert ob Smarty die Template-Ausgabe cachen soll. Normalerweise ist dies
    ausgeschaltet (disabled, Wert: 0). Falls Ihre Templates redundante Inhalte erzeugen,
    ist es empfehlenswert caching einzuschalten. Die Performance wird signifikant verbessert.
    Sie k&ouml;nnen auch mehrere Caches f&uuml;r ein Template haben. Die Werte 1 und 2 aktivieren
    caching. Bei 1 verwendet Smarty die Variable '$cache_lifetime', um zu berechnen
    ob ein Template neu kompiliert werden soll. Der Wert 2 weist Smarty an, den Wert von
    'cache_lifetime' zur Zeit der Erzeugung des Cache zu verwenden. Damit k&ouml;nnen Sie 'cache_lifetime'
    setzen, bevor Sie das Template einbinden und haben so eine feine Kontrolle dar&uuml;ber,
    wann ein bestimmter Cache abl&auml;uft. Konsultieren Sie dazu auch: <link linkend="api.is.cached">is_cached</link>.
   </para>
   <para>
    Wenn '$compile_check' aktiviert ist, wird der Cache regeneriert sobald ein Template
    oder eine Konfigurations-Variable ge&auml;ndert wurde. Wenn '$force_compile' aktiviert ist,
    werden die gecachten Inhalte bei jedem Aufruf neu generiert.
   </para>
  </sect1>
  <sect1 id="variable.cache.dir">
   <title>$cache_dir</title>
   <para>
    Definiert den Namen des Verzeichnisses in dem die Template-Caches
    angelegt werden. Normalerweise ist dies './cache', was Smarty veranlasst
    das Cache-Verzeichnis im aktuellen Verzeichnis zu suchen. Sie k&ouml;nnen
    auch einen eigenen Cache-Handler zur Kontrolle der Cache-Dateien
    definieren, der diese Einstellung ignoriert.
   </para>
   <note>
    <title>Technische Bemerkung</title>
    <para>
     Die Angabe muss entweder relativ oder absolut angegeben werden. 'include_path'
     wird nicht verwendet.
    </para>
   </note>
   <note>
    <title>Technische Bemerkung</title>
    <para>
     Es wird empfohlen ein Verzeichnis ausserhalb der DocumentRoot zu verwenden.
     	  </para>
   </note>
  </sect1>
  <sect1 id="variable.cache.lifetime">
   <title>$cache_lifetime</title>
   <para>
    Definiert die Zeitspanne (in Sekunden) die ein Cache g&uuml;ltig
    bleibt. Ist die Zeit abgelaufen, wird der Cache neu generiert. '$caching'
    muss eingeschaltet (true) sein, damit '$cache_lifetime' Sinn macht. Der
    Wert -1 bewirkt, dass der Cache nie abl&auml;uft. Der Wert 0 bewirkt, dass
    der Inhalt immer neu generiert wird (nur sinnvoll f&uuml;r Tests, eine
    effizientere Methode w&auml;re <link linkend="variable.caching">$caching</link>
    auf 'false' zu setzen).
   </para>
   <para>
    Wenn <link linkend="variable.force.compile">$force_compile</link>
    gesetzt ist, wird der Cache immer neu generiert (was einem Ausschalten
    von caching gleichkommt). Mit der <link linkend="api.clear.all.cache">clear_all_cache()</link>
    Funktion k&ouml;nnen Sie alle Cache-Dateien auf einmal entfernen. Mit der
    <link linkend="api.clear.cache">clear_cache()</link> Funktion k&ouml;nnen Sie
     einzelne Cache-Dateien (oder Gruppen) entfernen.
   </para>
   <note>
    <title>Technische Bemerkung</title>
    <para>
     Falls Sie bestimmten Templates eine eigene Cache-Lifetime geben wollen,
     k&ouml;nnen Sie dies tun indem Sie <link linkend="variable.caching">$caching</link>
     auf 2 stellen und '$cache_lifetime' einen einmaligen Wert zuweisen, bevor Sie
     'display()' oder 'fetch()' aufrufen.
    </para>
   </note>
  </sect1>
  <sect1 id="variable.cache.handler.func">
   <title>$cache_handler_func</title>
   <para>
    Sie k&ouml;nnen auch eine eigene Cache-Handler Funktion definieren.
    Siehe Abschnitt zur <link linkend="section.template.cache.handler.func">custom cache handler</link> Funktion.
   </para>
  </sect1>
  <sect1 id="variable.cache.modified.check">
   <title>$cache_modified_check</title>
   <para>
    Wenn auf 1 gesetzt, verwendet Smarty den If-Modified-Since
    Header des Clients. Falls sich der Timestamp der Cache-Datei
    seit dem letzten Besuch nicht ge&auml;ndert hat, wird der
    Header '304 Not Modified' anstatt des Inhalts ausgegeben. Dies
    funktioniert nur mit gecachten Inhalten die keine <command>insert</command>
    Tags enthalten.
   </para>
  </sect1>
  <sect1 id="variable.default.template.handler.func">
   <title>$default_template_handler_func</title>
   <para>
    Diese Funktion wird aufgerufen, wenn ein Template nicht aus der
    vorgegebenen Quelle geladen werden kann.
   </para>
  </sect1>
  <sect1 id="variable.php.handling">
   <title>$php_handling</title>
   <para>
    Definiert wie Smarty mit PHP-Code innerhalb von Templates umgehen soll.
    Es gibt 4 verschiedene Einstellungen. Normalerweise wird
    SMARTY_PHP_PASSTHRU verwendet. Achtung: '$php_handling' wirkt sich NICHT
    auf PHP-Code aus, der zwischen <link linkend="language.function.php">{php}{/php}</link>
    Tags steht.
   </para>    
   <itemizedlist>
    <listitem><para>SMARTY_PHP_PASSTHRU - Smarty gibt die Tags aus.</para></listitem>
    <listitem><para>SMARTY_PHP_QUOTE - Smarty maskiert die Tags als HTML-Entities.</para></listitem>
    <listitem><para>SMARTY_PHP_REMOVE - Smarty entfernt die Tags.</para></listitem>
    <listitem><para>SMARTY_PHP_ALLOW - Smarty f&uuml;hrt den Code als PHP-Code aus.</para></listitem>
   </itemizedlist>
   <para>
    ACHTUNG: Es wird davon abgeraten, PHP-Code in Templates einzubetten.
    Bitte verwenden Sie stattdessen <link linkend="language.custom.functions">custom functions</link>
    oder <link linkend="language.modifiers">Variablen-Modifikatoren</link>.
   </para>
  </sect1>
  <sect1 id="variable.security">
   <title>$security</title>
   <para>
    '$security' ein-/ausschalten. Normalerweise 'false' (ausgeschaltet).
    Die Sicherheitseinstellung ist wertvoll, wenn nicht vertrauensw&uuml;rdigen
    Parteien Zugriff auf die Templates gegeben wird (zum Beispiel via FTP).
    Mit aktivierter '$security' kann verhindert werden, dass diese das System 
    via Template-Engine kompromittieren. Die '$security' einzuschalten halt folgende
    Auswirkungen auf die Template-Language (ausser sie werden mit '$security_settings'
    &uuml;berschrieben):
   </para>
   <itemizedlist>
       <listitem><para>Wenn '$php_handling' auf SMARTY_PHP_ALLOW geschaltet ist, wird der Wert auf SMARTY_PHP_PASSTHRU ge&auml;ndert.</para></listitem>
    <listitem><para>Ausser den in '$security_settings' definierten, sind keine Funktionen in IF-Statements aufrufbar.</para></listitem>
    <listitem><para>Templates k&ouml;nnen nur aus den im '$secure_dir'-Array definierten Verzeichnissen geladen werden.</para></listitem>
    <listitem><para>'fetch()' kann nur verwendet werden um Dateien aus '$secure_dir' zu laden.</para></listitem>
    <listitem><para>{php}{/php}-Tags sind nicht erlaubt.</para></listitem>
    <listitem><para>Ausser den in '$security_settings' definierten, sind keine PHP-Funktionen direkt als Variablen-Modifikatoren aufrufbar.</para></listitem>
   </itemizedlist>
  </sect1>
  <sect1 id="variable.secure.dir">
   <title>$secure_dir</title>
   <para>
    Definiert die als 'sicher' geltenden Verzeichnisse als Array.
    {include} und {fetch} verwenden diese Verzeichnisse, wenn '$security'
    eingeschaltet ist.
   </para>
  </sect1>
  <sect1 id="variable.security.settings">
   <title>$security_settings</title>
   <para>
    Wird verwendet um spezifische Sicherheits-Einstellungen zu
    &auml;ndern, wenn '$security' eingeschaltet ist.
   </para>
   <itemizedlist>
    <listitem><para>PHP_HANDLING - true/false. Wenn auf 'true' gesetzt wird '$php_handling' ignoriert.</para></listitem>
    <listitem><para>IF_FUNCS - Ist ein Array aller erlaubter Funktionen in IF-Statements.</para></listitem>
    <listitem><para>INCLUDE_ANY - true/false. Wenn 'true', kann jedes Template geladen werden, auch ausserhalb der '$secure_dir'-Liste.</para></listitem>
    <listitem><para>PHP_TAGS - true/false. Wenn 'true', sind keine {php}{/php}-Tags erlaubt.</para></listitem>
    <listitem><para>MODIFIER_FUNCS - Ist ein Array aller Funktionen die als Variablen-Modifikatoren verwendet werden d&uuml;rfen.</para></listitem>
   </itemizedlist>
  </sect1>
  <sect1 id="variable.trusted.dir">
   <title>$trusted_dir</title>
   <para>
    '$trusted_dir' wird nur verwendet wenn die Sicherheit eingeschaltet ist. Der Wert
    ist ein Array aller Verzeichnisse, die als vertrauensw&uuml;rdig gelten.
    In diesen Verzeichnissen k&ouml;nnen PHP-Skripte, die man direkt aus einem Template
    mit <link linkend="language.function.include.php">{include_php}</link> aufruft,
    abgelegt werden.
   </para>
  </sect1>
  <sect1 id="variable.left.delimiter">
   <title>$left_delimiter</title>
   <para>
    Das zu verwendende linke Trennzeichen der Template-Sprache.
    Normalerweise '{'.
   </para>
  </sect1>
  <sect1 id="variable.right.delimiter">
   <title>$right_delimiter</title>
   <para>
    Das zu verwendende rechte Trennzeichen der Template-Sprache.
    Normalerweise '}'.
   </para>
  </sect1>
  <sect1 id="variable.show.info.header">
   <title>$show_info_header</title>
   <para>
    Gibt am Anfang der HTML-Seite die Smarty Version und das Kompilier-Datum des Templates
    als Kommentar aus. Normalerweise 'false'.
   </para>
  </sect1>
  <sect1 id="variable.show.info.include">
   <title>$show_info_include</title>
   <para>
    Gibt am Anfang und am Ende jedes eingebundenen Templates einen HTML-Kommentar aus.
    Normalerweise 'false'.
   </para>
  </sect1>
  <sect1 id="variable.compiler.class">
   <title>$compiler_class</title>
   <para>
    Definiert den Namen der Compiler-Klasse, die Smarty zum kompilieren
    der Templates verwenden soll. Normalerweise 'Smarty_Compiler'. Nur
    f&uuml;r fortgeschrittene Anwender.
   </para>
  </sect1>
  <sect1 id="variable.request.vars.order">
   <title>$request_vars_order</title>
   <para>
    Die Reihenfolge in welcher die Request-Variblen zugewiesen werden.
    Verh&auml;lt sich wie 'variables_order' in der php.ini.
   </para>
  </sect1>
  <sect1 id="variable.request.use.auto.globals">
   <title>$request_use_auto_globals</title>
   <para>
   Definiert ob Smarty php's $HTTP_*_VARS[] ($request_use_auto_globals=false welches
   der Standardwert ist) oder $_*[] ($request_use_auto_globals=true) verwenden soll.
   Dies betrifft Templates die {$smarty.request.*}, {$smarty.get.*}, etc... verwenden.
   Achtung: wenn $request_use_auto_globals auf TRUE gesetzt ist, hat <link linkend="variable.request.vars.order">variable.request.vars.order </link>
   keine Auswirkungen, da php's Konfigurationswert <literal>gpc_order</literal> verwendet wird.
   </para>
  </sect1>
  <sect1 id="variable.compile.id">
   <title>$compile_id</title>
   <para>
    Persistenter 'compile-identifier'. Anstatt jedem Funktionsaufruf die selbe 'compile_id'
    zu &uuml;bergeben, kann eine individuelle 'compile_id' gesetzt werden. Das ist z. B. 
    sinnvoll, um in Kombination mit einem 'prefilter' verschiedene Sprach-Versionen eines Template
    kompilieren.
   </para>
  </sect1>
  <sect1 id="variable.use.sub.dirs">
   <title>$use_sub_dirs</title>
   <para>
    Wenn Sie Smarty in einer Umgebung einsetzen, die das Erstellen von Unterverzeichnissen
    nicht erlaubt, k&ouml;nnen Sie diesen Wert auf 'false' setzen. Unterverzeichnisse
    sind jedoch effizienter und sollten deshalb m&ouml;glichst verwendet werden.
   </para>
  </sect1>
  <sect1 id="variable.default.modifiers">
   <title>$default_modifiers</title>
   <para>
    Definiert ein Array von Variablen-Modifikatoren, die auf jeder Variable anzuwenden sind.
    Wenn Sie zum Beispiel alle Variablen standardm&auml;ssig HTML-Maskieren wollen,
    k&ouml;nnen Sie array('escape:"htmlall"'); verwenden. Um eine Variable von dieser
    Behandlung auszuschliessen, k&ouml;nnen Sie ihr den Parameter 'smarty' mit dem Modifikator 'nodefaults'
    &uuml;bergeben. Als Beispiel: {$var|smarty:nodefaults}.
    Zum Beispiel: {$var|nodefaults}.
   </para>
  </sect1>
  <sect1 id="variable.default.resource.type">
   <title>$default_resource_type</title>
   <para>
    Definiert den Ressourcentyp der von Smarty implizitverwendet werden soll. Standartwert
    ist 'file', was dazu f&uuml;hrt dass $smarty->display('index.tpl'); und
    $smarty->display('file:index.tpl'); identisch sind. Konsultieren Sie das
    <link linkend="template.resources">Resource</link> Kapitel f&uuml;r weitere Informationen.
   </para>
  </sect1>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->