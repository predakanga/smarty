<?xml version="1.0" encoding="iso-8859-1"?>
<!-- EN-Revision: 1.4 Maintainer: andreas Status: ready -->
<!-- $Revision$ -->
<chapter id="tips">
   <title>Tips &amp; Tricks</title>
   <para>
   </para>
   <sect1 id="tips.blank.var.handling">
		<title>Handhabung unangewiesener Variablen</title>
		<para>
		Manchmal m&ouml;chten Sie vielleicht, dass anstatt einer Leerstelle ein Standardwert ausgegeben wird - zum
		Beispiel um im Tabellenhintergrund "&amp;nbsp;" auszugeben, damit er korrekt angezeigt wird. Damit daf&uuml;r
		keine {if} Anweisung verwendet werden muss, gibt es in Smarty eine Abk&uuml;rzung: die Verwendung des <emphasis>default</emphasis>
		Variablen-Modifikators.
		</para>
<example>
<title>"&amp;nbsp;" ausgeben wenn eine Variable nicht zugewiesen ist</title>
<programlisting>

{* kompliziert *}

{if $titel eq ""}
	&amp;nbsp;
{else}
	{$titel}
{/if}


{* einfach *}

{$titel|default:"&amp;nbsp;"}</programlisting>
</example>
	</sect1>

    <sect1 id="tips.default.var.handling">
		<title>Handhabung von Standardwerten</title>
		<para>
		Wenn eine Variable in einem Template h&auml;ufig zum Einsatz kommt,
		kann es ein bisschen st&ouml;rend wirken, den 'default'-Modifikator jedes mal anzuwenden.
		Sie k&ouml;nnen dies umgehen, indem Sie der Variable mit der <link linkend="language.function.assign">assign</link> Funktion
		einen Standardwert zuweisen.
		</para>
<example>
<title>Zuweisen des Standardwertes einer Variable</title>
<programlisting>
{* schreiben sie dieses statement an den Anfang des Templates *}
{assign var="titel" value=$titel|default:"kein Titel"}

{* fall 'titel' bei der Anweisung leer war, enth&auml;lt es nun den Wert 'kein Titel' wenn Sie es ausgeben *}
{$titel}
</programlisting>
</example>
	</sect1>
    <sect1 id="tips.passing.vars">
		<title>Variablen an eingebundene Templates weitergeben</title>
		<para>
		Wenn die Mehrzahl Ihrer Templates den gleichen Header und Footer verwenden,
		lagert man diese meist in eigene Templates aus und bindet diese ein. Was
		geschieht aber wenn der Header einen seitenspezifischen Titel haben soll?
		Smarty bietet die M&ouml;glichkeit, dem eingebundenen Template, Variablen
		zu &uuml;bergeben.
		</para>
<example>
<title>Die Titel-Variable dem Header-Template zuweisen</title>
<programlisting>

ersteseite.tpl
------------

{include file="header.tpl" title="Erste Seite"}
{* template body hier *}
{include file="footer.tpl"}


archiv.tpl
------------

{config_load file="archiv.conf"}
{include file="header.tpl" title=#archivSeiteTitel#}
{* template body hier *}
{include file="footer.tpl"}


header.tpl
----------
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;TITLE&gt;{$title|default:"Nachrichten"}&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;


footer.tpl
----------
&lt;/BODY&gt;
&lt;/HTML&gt;</programlisting>
</example>
	<para>
		Sobald die erste Seite geparsed wird, wird der Titel 'Erste Seite'
		dem header.tpl &uuml;bergeben und fortan als Titel verwendet. Wenn
		die Archivseite ausgegeben wird, wird der Titel 'Archive' ausgegeben.
		Wie Sie sehen k&ouml;nnen, wird der Wert daf&uuml;r aus der Datei
		'archiv.conf' geladen und nicht von einem &uuml;bergebenen Wert. Der
		Standardwert 'Nachrichten' wird verwendet, wenn die '$titel' leer ist.
		Erneut wird daf&uuml;r der <emphasis>default</emphasis>-Modifikator angewandt.
	</para>
	</sect1>
    <sect1 id="tips.dates">
       <title>Zeitangaben</title>
       <para>
	   Um dem Template Designer h&ouml;chstm&ouml;gliche Kontrolle &uuml;ber die Ausgabe
	   von Zeitangaben/Daten zu erm&ouml;glichen, ist es empfehlenswert Daten immer
	   als Timestamp zu &uuml;bergeben. Der Designer kann danach die Funktion 
	   <link linkend="language.modifier.date.format">date_format</link> f&uuml;r
	   die Formatierung verwenden.
       </para>
       <para>
       Bemerkung: Seit Smarty 1.4.0 ist es m&ouml;glich jede Timestamp zu
       &uuml;bergeben, welche mit strtotime() ausgewertet werden kann. Dazu
       geh&ouml;ren Unix-Timestamps und MySQL-Timestamps.
       </para>
<example>
<title>Die Verwendung von date_format</title>
<programlisting>
<![CDATA[
{$startDate|date_format}
]]>
</programlisting>
<para>
AUSGABE:
</para>

<screen>
<![CDATA[
Jan 4, 2001
]]>
    </screen>
    <programlisting>
<![CDATA[
{$startDatum|date_format:"%Y/%m/%d"}
]]>
    </programlisting>
    <para>
AUSGABE:
    </para>
    <screen>
<![CDATA[
2001/01/04
]]>
    </screen>
    <programlisting>
<![CDATA[
{if $datum1 < $datum2}
	...
{/if}
]]>
</programlisting>
</example>
		<para>
	Falls {html_select_date} in einem Template verwendet wird, hat der Programmierer
	die M&ouml;glichkeit den Wert wieder in ein Timestamp-Format zu &auml;ndern. Dies
	kann zum Beispiel wie folgt gemacht werden:
		</para>
<example>
<title>Formular Datum-Elemente nach Timestamp konvertieren</title>
<programlisting>
<![CDATA[
<?php
// hierbei wird davon ausgegangen, dass Ihre Formular Elemente wie folgt benannt sind
// startDate_Day, startDate_Month, startDate_Year

$startDate = makeTimeStamp($startDate_Year,$startDate_Month,$startDate_Day);

function makeTimeStamp($year="",$month="",$day="")
{
	if(empty($year))
		$year = strftime("%Y");
	if(empty($month))
		$month = strftime("%m");
	if(empty($day))
		$day = strftime("%d");

	return mktime(0,0,0,$month,$day,$year);
}
]]>
</programlisting>

</example>
	</sect1>
    <sect1 id="tips.wap">
		<title>WAP/WML</title>
		<para>
	WAP/WML Templates verlangen, dass ein Content-Type Header im Template
	angegeben wird. Der einfachste Weg um dies zu tun, w&auml;re, eine Funktion
	zu schreiben, welche den Header ausgibt. Falls sie den Caching Mechanismus
	verwenden, sollten Sie auf das 'insert'-Tag zur&uuml;ckgreifen ('insert'-Tags
	werden nicht gecached), um ein optimales Ergebnis zu erzielen. Achten Sie darauf,
	dass vor der Ausgabe des Headers keine Daten an den Client gesendet werden, da
	die gesendeten Header-Daten ansonsten von Client verworfen werden.
		</para>
<example>
<title>Die verwendung von 'insert' um einen WML Content-Type header zu senden</title>
<programlisting>
<![CDATA[
<?php
// stellen Sie sicher, dass Apache mit .wml Dateien umgehen kann!
// schreiben Sie folgende Funktion in Ihrer Applikation, oder in Smarty.addons.php
function insert_header() {
    // this function expects $content argument
    // folgende Funktion erwartet ein $inhalt argument
    extract(func_get_arg(0));
    if(empty($inhalt))
        return;
    header($inhalt);
    return;
}
?>
]]>
</programlisting>
<para>
// Ihr Template _muss_ danach wie folgt beginnen:
</para>
    <programlisting>
<![CDATA[
{insert name=header inhalt="Content-Type: text/vnd.wap.wml"}

&lt;?xml version="1.0"?&gt;  
&lt;!DOCTYPE wml PUBLIC "-//WAPFORUM//DTD WML 1.1//EN" "http://www.wapforum.org/DTD/wml_1.1.xml"&gt; 

&lt;!-- neues wml deck --&gt; 
&lt;wml&gt; 
&lt;!-- erste karte --&gt; 
&lt;card&gt; 
&lt;do type="accept"&gt; 
&lt;go href="#zwei"/&gt; 
&lt;/do&gt;  
&lt;p&gt; 
Welcome to WAP with Smarty!
Willkommen bei WAP mit Smarty!
OK klicken um weiterzugehen...
&lt;/p&gt; 
&lt;/card&gt;  
&lt;!-- zweite karte --&gt; 
&lt;card id="zwei"&gt;  
&lt;p&gt; 
Einfach, oder?
&lt;/p&gt; 
&lt;/card&gt; 
&lt;/wml&gt;
]]>
</programlisting>
</example>
	</sect1>
	<sect1 id="tips.componentized.templates">
		<title>Template/Script Komponenten</title>
		<para>
		Dieser Tip ist nicht ausgiebig getestet, aber dennoch eine nette Idee. Verwendung auf eigene Gefahr. ;-)
		</para>
		<para>
		Normalerweise werden Variablen dem Template wie folgt zugewiesen:
		In Ihrer PHP-Applikation werden die Variablen zusammengestellt
		(zum Beispiel mit Datenbankabfragen). Danach kreieren Sie eine
		Instanz von Smarty, weisen die Variablen zu und geben das Template aus.
		Wenn wir also zum Beispiel einen B&ouml;rsenticker in unserem
		Template haben, stellen wir die Kursinformationen in unserer Anwendung
		zusammen, weisen Sie dem Template zu und geben es aus. W&auml;re es jedoch nicht
		nett diesen B&ouml;rsenticker einfach in ein Template einer anderen Applikation
		einbinden zu k&ouml;nnen ohne deren Programmcode zu &auml;ndern?
		</para>


        <para>
	Sie k&ouml;nnen PHP-Code mit {php}{/php} in Ihre Templates einbetten.
	So k&ouml;nnen Sie Templates erstellen, welche die Datenstrukturen
	zur Anweisung der eigenen Variablen enthalten. Durch die Bindung von
	Template und Logik entsteht so eine eigenst&auml;ndig lauff&auml;hige Komponente.
        </para>
<example>
<title>Template/Script Komponenten</title>
<programlisting>
<![CDATA[
<?php

// drop file "function.load_ticker.php" in plugin directory

// setup our function for fetching stock data
function fetch_ticker($symbol)
{
   // put logic here that fetches $ticker_info
   // from some ticker resource
   return $ticker_info;
}

function smarty_function_load_ticker($params, &$smarty)
{
   // call the function
   $ticker_info = fetch_ticker($params['symbol']);

   // assign template variable
   $smarty->assign($params['assign'], $ticker_info);
}
?>
]]>
    </programlisting>
    <programlisting>
<![CDATA[
index.tpl
---------

{* Smarty *}

{load_ticker symbol="YHOO" assign="ticker"}

Stock Name: {$ticker.name} Stock Price: {$ticker.price}
]]>
    </programlisting>
</example>
        <para>
		Seit Smarty 1.5.0, gibt es einen noch einfacheren und auch saubereren Weg
		in dem man die Logik mit {include_php ...} einbindet. So kann man weiterhin
		die Logik vom Design getrennt halten. Mehr Informationen gibt es in der <link linkend="language.function.include.php">include_php</link> Dokumentation.
        </para>
<example>
<title>Template/Script Komponenten mit include_php</title>
<programlisting>
load_ticker.php
---------------

&lt;?php
	// unsere funktion um die b&ouml;rsenkurse zu holen
	function fetch_ticker($symbol,&amp;$ticker_name,&amp;$ticker_price) {
		// hier wird $ticker_name und $ticker_price zugewiesen
	}

	// aufruf der funktion
	fetch_ticker("YHOO",$ticker_name,$ticker_price);
	
    	// zuweisung der variablen
	$this->assign("ticker_name",$ticker_name);
	$this->assign("ticker_price",$ticker_price);
?&gt;


index.tpl
---------

{* Smarty *}

{include_php file="load_ticker.php"}

Symbol: {$ticker_name} Preis: {$ticker_price}</programlisting>
</example>
	</sect1>
	<sect1 id="tips.obfuscating.email">
		<title>Verschleierung von E-mail Adressen</title>
		<para>
		Haben Sie sich auch schon gewundert, wie Ihre E-mail Adresse auf so viele
		Spam-Mailinglisten kommt? Ein Weg, wie Spammer E-mail Adressen sammeln, ist
		&uuml;ber Webseiten. Um dieses Problem zu bek&auml;mpfen, k&ouml;nnen sie
		den 'mailto'-Plugin verwenden. Er &auml;ndert die Zeichenfolge mit Javascript
		so, dass sie im HTML Quellcode nicht lesbar ist, jedoch von jedem Browser
		wieder zusammengesetzt werden kann. Den 'mailto'-Plugin gibt es im Smarty-Repository
		auf http://smarty.php.net. Laden sie den Plugin herunter und speichern Sie ihn im
		'plugins' Verzeichnis.
		</para>
<example>
<title>Beispiel von verschleierung von E-mail Adressen</title>
<programlisting>

index.tpl
---------

Fragen bitte an 
{mailto address=$EmailAddress encode="javascript" subject="Hallo"}
senden

</programlisting>
</example>
	<note>
	<title>Technische Details</title>
	<para>
	Die Codierung mit Javascript ist nicht sehr sicher, da ein m&ouml;glicher
	Spammer die Decodierung in sein Sammelprogramm einbauen k&ouml;nnte. Es wird jedoch damit
	gerechnet, dass, da Aufwand und Ertrag sich nicht decken, dies nicht oft der Fall ist.
	</para>
	</note>
	</sect1>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
