<?xml version="1.0" encoding="windows-1251"?>
<!-- $Revision$ -->
<!-- EN-Revision: 1.4 Maintainer: freespace Status: ready -->
<chapter id="tips">
 <title>Советы</title>
  <sect1 id="tips.blank.var.handling">
  <title>Обработка пустых переменных</title>
  <para>
   Иногда, например, для того чтобы фон таблицы работал корректно, 
   необходимо вывести вместо пустого значения переменной, значение 
   по умолчанию "&amp;nbsp;". Многие бы использовали конструкцию {if},
   но есть более короткий путь в Smatry используя <emphasis>default</emphasis>
   модификатор переменной.
  </para>
<example>
<title>Вывод &amp;nbsp;, если переменная пуста</title>
<programlisting>
<![CDATA[
{* длинный путь *}

{if $title eq ""}
 &nbsp;
{else}
	{$title}
{/if}


{* короткий путь *}

{$title|default:"&nbsp;"}
]]>
</programlisting>
</example>
</sect1>
<sect1 id="tips.default.var.handling">
 <title>Обработка переменных по умолчанию</title>
 <para>
  Если переменная встречается часто, то использование модификатора 
  default каждый раз можно избежать, используя функцию
  <link linkend="language.function.assign">assign</link>.
 </para>
<example>
<title>Назначение переменной шаблона значения по умолчанию</title>
<programlisting>
<![CDATA[
{* вверху шаблона *}
{assign var="title" value=$title|default:"no title"}

{* если переменная $title была пустой, то сейчас она содержит "no title" *}
{$title}
]]>
</programlisting>
</example>
</sect1>
<sect1 id="tips.passing.vars">
 <title>Присвоение переменной заголовка (title) заголовку шаблона.</title>
  <para>
   Если большинство ваших шаблонов имеют похожие верхние и нижние 
   части, то имеет смысл вынести их в отдельные файлы. Но если 
   шапка должна иметь различные заголовки на различных страницах? 
   Смотрите пример ниже.
  </para>
<example>
<title>Присвоение переменной заголовка (title) заголовку шаблона.</title>
<programlisting>
<![CDATA[
mainpage.tpl
------------

{include file="header.tpl" title="Main Page"}
{* тело шаблона *}
{include file="footer.tpl"}


archives.tpl
------------

{config_load file="archive_page.conf"}
{include file="header.tpl" title=#archivePageTitle#}
{* тело шаблонаe *}
{include file="footer.tpl"}


header.tpl
----------
<HTML>
 <HEAD>
  <TITLE>{$title|default:"BC News"}</TITLE>
  </HEAD>
  <BODY>


footer.tpl
----------
</BODY>
</HTML>
]]>
</programlisting>
</example>
 <para>
  Если выводится главная страница, то заголовок будет "Main Page",
  если архивы, то заголовк берется из файла конфигурации. Если 
  заголовок будет пустой, то выведется значение по умолчанию "BC News".
 </para>
</sect1>
<sect1 id="tips.dates">
<title>Даты</title>
 <para>
  Обычно даты в Smarty всегда передаются как временные метки, что
  позволяет проектировщикам шаблонов использовать <link
		linkend="language.modifier.date.format">date_format</link>
  для полного контроля над форматированием даты и также делает легким 
		сравнение дат там, где это необходимо.
 </para>
   <note>
    <para>
     Начиная с версии Smarty 1.4.0, вы можете передавать даты в Smarty в виде
     меток времени Unix (unix timestamps), mysql, или в любом другом виде, который принимает strtotime().
    </para>
   </note>
   <example>
    <title>using date_format</title>
    <programlisting>
<![CDATA[
{$startDate|date_format}
]]>
    </programlisting>
    <para>
     Результат работы:
    </para>
    <screen>
<![CDATA[
Jan 4, 2001
]]>
    </screen>
    <programlisting>
<![CDATA[
{$startDate|date_format:"%Y/%m/%d"}
]]>
    </programlisting>
    <para>
     Результат работы:
    </para>
    <screen>
<![CDATA[
2001/01/04
]]>
    </screen>
    <programlisting>
<![CDATA[
{if $date1 < $date2}
   ...
{/if}
]]>
    </programlisting>
   </example>
<para>
 Когда {html_select_date} используется в шаблоне, программистам может
 понадобиться получить дату виде временной метки. Вот функция, которая поможет это
 сделать.
</para>
<example>
<title>Преобразование элементов формы ввода даты назад к временной метке</title>
    <programlisting role="php">
<![CDATA[
<?php

// Предполагается, что ваши элементы формы названы
// startDate_Day, startDate_Month, startDate_Year

$startDate = makeTimeStamp($startDate_Year, $startDate_Month, $startDate_Day);

function makeTimeStamp($year="", $month="", $day="")
{
   if(empty($year)) {
       $year = strftime("%Y");
   }
   if(empty($month)) {
       $month = strftime("%m");
   }
   if(empty($day)) {
       $day = strftime("%d");
   }

   return mktime(0, 0, 0, $month, $day, $year);
}
?>
]]>
    </programlisting>
</example>
</sect1>
<sect1 id="tips.wap">
 <title>WAP/WML</title>
 <para>
  WAP/WML шаблоны требуют, чтобы заголовок Content-type был
  передан вместе с шаблоном. Простейший путь - написать 
  пользовательскую функцию, которая будет выводить заголовки. 
  Так как мы будем пользоваться тэгами insert, то заголовки не будут 
  кэшироваться. Так же ничего не должно выводиться в браузер до 
  шаблона, иначе заголовки могут быть неправильно восприняты.
 </para>
<example>
 <title>Использование insert для записи WML Content-Type заголовков</title>
    <programlisting role="php">
<![CDATA[
<?php

// убедитесь, что apache настроен на обработку расширений .wml!                                    
// добавьте эту функцию в своё приложение или в Smarty.addons.php
function insert_header($params) 
{
   // эта функция ожидает аргумент $content
   if (empty($params['content'])) {
       return;
   }
   header($params['content']);
   return;
}

?>
]]>
    </programlisting>
    <para>
     ваш шаблон Smarty <emphasis>должен</emphasis> начинаться с тэга insert:
    </para>
    <programlisting>
<![CDATA[
{insert name=header content="Content-Type: text/vnd.wap.wml"}

<?xml version="1.0"?>  
<!DOCTYPE wml PUBLIC "-//WAPFORUM//DTD WML 1.1//EN" "http://www.wapforum.org/DTD/wml_1.1.xml"> 

<!-- begin new wml deck --> 
<wml> 
<!-- begin first card --> 
<card> 
<do type="accept"> 
<go href="#two"/> 
</do>  
<p> 
Welcome to WAP with Smarty!
Press OK to continue...  
</p> 
</card>  
<!-- begin second card --> 
<card id="two">  
<p> 
Pretty easy isn't it?
</p> 
</card> 
</wml>
]]>
    </programlisting>
</example>
</sect1>
  <sect1 id="tips.componentized.templates">
   <title>Составные шаблоны</title>
   <para>
    По традиции, программирование шаблонов в вашем приложении идёт следующим
    путём: Сначала вы формируете переменные внутри вашего приложения PHP
    (возможно используя запросы к базе данных). Затем вы создаёте экземпляр
    объекта Smarty, назначаете переменные и отображаете шаблон.
    Давайте представим себе такую ситуацию: К примеру, у нас есть котировщик
    ценных бумаг в нашем шаблоне. Мы собираем данные о котировках ценных бумаг
    в нашем приложении, затем передаём эти переменные в шаблон и отображаем
    его. Правда, было бы здорово, если бы этот котировщик можно было перенести
    в другое приложение, просто подключив к нему шаблон, не беспокоясь об
    источнике данных.
   </para>
   <para>
    Вы можете сделать это, написав собственный плагин для получения данных и
    присваивания их переменной шаблона.
   </para>
   <example>
    <title>составной шаблон</title>
    <programlisting role="php">
<![CDATA[
<?php

// поместите файл "function.load_ticker.php" в директорию плагинов

// настраиваем нашу функцию для получения информации о ценных бумагах
function fetch_ticker($symbol) 
{
   // здесь находится логика формирования $ticker_info
   // из какого-то источника
   return $ticker_info;
}

function smarty_function_load_ticker($params, &$smarty) 
{
   // вызываем функцию
   $ticker_info = fetch_ticker($params['symbol']);
   
   // присваиваем переменную шаблона
   $smarty->assign($params['assign'], $ticker_info);
}
?>
]]>
    </programlisting>
    <programlisting>
<![CDATA[
index.tpl
---------

{* Smarty *}

{load_ticker symbol="YHOO" assign="ticker"}

Название ценной бумаги: {$ticker.name} Цена ценной бумаги: {$ticker.price}
]]>
    </programlisting>
   </example>
  </sect1>
  <sect1 id="tips.obfuscating.email">
   <title>Сокрытие E-mail адреса</title>
   <para>
    Вы когда-нибудь удивлялись, как ваш e-mail адрес попадает в такое
    количество спамерских рассылок? Один из способов сбора e-mail адресов
    заключается в просмотре веб-страниц. Чтобы помочь предотвратить эту
    проблему, вы можете сделать так, чотбы ваш e-mail адрес отображался
    в скрытом за javascript'ом виде в HTML-исходниках, в то же время
    выглядя и работая корректно в браузере. Это можно совершить при помощи
    плагина mailto.
   </para>
   <example>
    <title>Пример сокрытия e-mail адреса</title>
    <programlisting>
<![CDATA[
index.tpl
---------

По вопросам обращайтесь на
{mailto address=$EmailAddress encode="javascript" subject="Hello"}
]]>
    </programlisting>
   </example>
   <note>
    <title>Техническое Замечание</title>
    <para>
     Этот метод не может гарантировать 100% защиты.
     Существует вероятность, что спамер запрограммирует свой
     сборщик e-mail адресов на раскодирование этих значений,
     но это маловероятно.
    </para>
   </note>
  </sect1>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
