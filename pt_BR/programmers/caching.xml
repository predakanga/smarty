<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision$ -->
  <chapter id="caching">
   <title>Caching</title>
   <para>
   Caching é usado para aumentar a velocidade de chamada para <link
   linkend="api.display">display()</link> ou <link
   linkend="api.fetch">fetch()</link> salvando isso num arquivo de saída. Se há uma versão
   de cache disponível para a chamada, isso é mostrado ao invés de regerar a saída de dados.
   Caching pode fazer coisas tremendamente rápidas,
   especialmente templates com longo tempo computacional. Desde a saída de dados do
   display() ou fetch() está em cache, um arquivo de cache poderia ser composto por
   diversos arquivos de templates, arquivos de configuração, etc.
   </para>
   <para>
   Desde que templates sejam dinâmicos, é importante isso ter cuidado com
   o que você está fazendo cache e por quanto tempo. Por exemplo, se você está mostrando
   a página principal do seu website na qual as alterações de conteúdo são muito frequentes,
   isso funciona bem para cache dessa por uma hora ou mais. Um outro modo, se você está
   mostrando uma página com um mapa do tempo contendo novas informações por minuto, não
   faz sentido fazer cache nesta página.
   </para>
   <sect1 id="caching.setting.up">
   <title>Configurando Caching</title>
   <para>
   A primeira coisa a fazer é habilitar o caching. Isso é feito pela configuração <link
   linkend="variable.caching">$caching</link> = true (or 1.)     
   </para>
    <example>
     <title>Habilitando Caching</title>
     <programlisting>
require('Smarty.class.php');
$smarty = new Smarty;

$smarty->caching = true;

$smarty->display('index.tpl');</programlisting>
    </example>
	<para>
	Com caching habilitado, a chamada para a função display('index.tpl') irá trazer
	o template como usual, mas também
	salva uma cópia disso para o arquivo de saída (uma cópia de cache) in the <link linkend="variable.cache.dir">$cache_dir</link>.
	Na próxima chamada de display('index.tpl'), a cópia em cache será usada
	ao invés de trazer novamente o template.
	</para>
	<note>
	<title>Notas Técnicas</title>
	<para>
	Os arquivos no $cache_dir são nomeados com similaridade ao nome do arquivo de template.
	Embora eles terminem com a extensão ".php", eles não são realmente scripts executáveis de php.
	Não edite estes arquivos!
	</para>
	</note>
	<para>
	Cada página em cache tem um período de tempo limitado determinado por <link
	linkend="variable.cache.lifetime">$cache_lifetime</link>. O padrão do valor é
        3600 segundos, ou 1 hora. Após o tempo expirar, o cache é regerado.
	É possível dar tempos individuais para caches com seu próprio tempo
	de expiração pela configuração $caching = 2. Veja a documentação em <link
	linkend="variable.cache.lifetime">$cache_lifetime</link> para detalhes.
	</para>
    <example>
     <title>Configurando cache_lifetime por cache</title>
     <programlisting>
require('Smarty.class.php');
$smarty = new Smarty;

$smarty->caching = 2; // lifetime is per cache

// set the cache_lifetime for index.tpl to 5 minutes
$smarty->cache_lifetime = 300;
$smarty->display('index.tpl');

// set the cache_lifetime for home.tpl to 1 hour
$smarty->cache_lifetime = 3600;
$smarty->display('home.tpl');

// NOTE: the following $cache_lifetime setting will not work when $caching = 2.
// The cache lifetime for home.tpl has already been set
// to 1 hour, and will no longer respect the value of $cache_lifetime.
// The home.tpl cache will still expire after 1 hour.
$smarty->cache_lifetime = 30; // 30 seconds
$smarty->display('home.tpl');</programlisting>
    </example>
	<para>
	Se <link linkend="variable.compile.check">$compile_check</link> está habilitado,
	cada arquivo de template e arquivo de configuração que está envolvido com o arquivo em cache
	é checado por modificações. Se algum destes arquivos foi modificado desde que o último cache
	foi gerado, o cache é imediatamente regerado. 
	Isso é ligeiramente uma forma de optimização de performance de overhead, deixe $compile_check setado para false.
	</para>
    <example>
     <title>Habilitando $compile_check</title>
     <programlisting>
require('Smarty.class.php');
$smarty = new Smarty;

$smarty->caching = true;
$smarty->compile_check = true;

$smarty->display('index.tpl');</programlisting>
	</example>
	<para>
	Se <link linkend="variable.force.compile">$force_compile</link> está habilitado,
	os arquivos de cache irão sempre ser regerados. Isso é efetivamente desativar caching.
        $force_compile é usualmente para propósitos de debug somente, um caminho mais
	eficiente de desativar caching é setar o <link
	linkend="variable.caching">$caching</link> = false (ou 0.)
	</para>
	<para>
	A função <link linkend="api.is.cached">is_cached()</link> 
	pode ser usada para testar se um template tem um cache válido ou não.
	Se você tem um template com cache que requer alguma coisa como um retorno do banco de dados,
	você pode usar isso para pular este processo.
	</para>
    <example>
     <title>Usando is_cached()</title>
     <programlisting>
require('Smarty.class.php');
$smarty = new Smarty;

$smarty->caching = true;

if(!$smarty->is_cached('index.tpl')) {
	// No cache available, do variable assignments here.
	$contents = get_database_contents();
	$smarty->assign($contents);
}

$smarty->display('index.tpl');</programlisting>
    </example>
	<para>
	Você pode deixar partes da sua página dinâmica com a função de template <link
	linkend="language.function.insert">insert</link>.
	Vamos dizer que sua página inteira pode ter cache exceto para um banner que é
	mostrado abaixo do lado direito da sua página. Usando uma função insert para o banner,
	você pode deixar esse elemento dinâmico dentro do conteúdo de cache. Veja a documentação
	em <link linkend="language.function.insert">insert</link> para 
	detalhes e exemplos.
	</para>
	<para>
	Você pode limpar todos os arquivos de cache com a função <link
	linkend="api.clear.all.cache">clear_all_cache()</link>, ou
	arquivos de cache individuais (ou grupos) com a função <link
	linkend="api.clear.cache">clear_cache()</link>.	
	</para>
    <example>
     <title>Limpando o cache</title>
     <programlisting>
require('Smarty.class.php');
$smarty = new Smarty;

$smarty->caching = true;

// clear out all cache files
$smarty->clear_all_cache();

// clear only cache for index.tpl
$smarty->clear_cache('index.tpl');

$smarty->display('index.tpl');</programlisting>
    </example>
   </sect1>
   <sect1 id="caching.multiple.caches">
    <title>Multiple Caches Per Page</title>
	<para>
	Você pode ter múltiplos arquivos de cache para uma simples chamada de display()
	ou fetch(). Vamos dizer que uma chamada para display('index.tpl') deve ter vários
	conteúdo de saída diferentes dependendo de alguma condição, e você quer separar
	os caches para cada um. Você pode fazer isso passando um cache_id como um
	segundo parâmetro para a chamada da função.
	</para>
    <example>
     <title>Passando um cache_id para display()</title>
     <programlisting>
require('Smarty.class.php');
$smarty = new Smarty;

$smarty->caching = true;

$my_cache_id = $_GET['article_id'];

$smarty->display('index.tpl',$my_cache_id);</programlisting>
    </example>
	<para>
	Acima, nós estamos passando a variável $my_cache_id para display() com o
	cache_id. Para cada valor único de $my_cache_id, um cache em separado irá ser
	gerado para index.tpl. Nesse exemplo, "article_id" foi passado em URL e é usado
	como o cache_id.
	</para>
	<note>
	<title>Notas Técnicas</title>
	<para>
	Tenha muito cuidado quando passar valores do cliente (web brownser) dentro
	da Smarty (ou alguma aplicação PHP.) Embora o exemplo acima usando o article_id
	vindo de uma URL pareça fácil, isso poderia ter consequências ruins. O
	cache_id é usado para criar um diretório no sistema de arquivos, então se o usuário
	decidir passar um valor extremamente largo para article_id, ou escrever um script
	que envia article_ids randômicos em um ritmo rápido, isso poderia possivelmente causar
	problemas em nível de servidor. Tenha certeza de limpar algum dado passado antes de usar isso. Nessa instãncia, talvez você
	saiba que o article_id tem um comprimento de 10 caracteres e isso é constituído somente
	de alfa-numéricos, e deve ser um
	article_id válido no database. Verifique isso!
	</para>
	</note>
	<para>
	Tenha certeza de passar o mesmo cache_id como o segundo
	parâmetro para <link linkend="api.is.cached">is_cached()</link> e
	<link linkend="api.clear.cache">clear_cache()</link>.
	</para>
	<example>
     <title>Passando um cache_id para is_cached()</title>
     <programlisting>
require('Smarty.class.php');
$smarty = new Smarty;

$smarty->caching = true;

$my_cache_id = $_GET['article_id'];

if(!$smarty->is_cached('index.tpl',$my_cache_id)) {
	// No cache available, do variable assignments here.
	$contents = get_database_contents();
	$smarty->assign($contents);
}

$smarty->display('index.tpl',$my_cache_id);</programlisting>
    </example>
	<para>
	Você pode limpar todos os caches para um cache_id em particular passando
	o primeiro parâmetro null para clear_cache().
	</para>
	<example>
     <title>Limpando todos os caches para um cache_id em particular</title>
     <programlisting>
require('Smarty.class.php');
$smarty = new Smarty;

$smarty->caching = true;

// clear all caches with "sports" as the cache_id
$smarty->clear_cache(null,"sports");

$smarty->display('index.tpl',"sports");</programlisting>
    </example>
	<para>
	Desta maneira, você pode "agrupar" seus 
	caches juntos dando-lhes o mesmo cache_id.
	</para>
   </sect1>
   <sect1 id="caching.groups">
    <title>Grupos de Cache</title>
	<para>
	Você pode fazer agrupamentos mais elaborados configurando grupos de cache_id. Isso é
	realizado pela separação de cada sub-grupo com uma barra vertical "|" no valor do 
	cache_id. Você pode ter muitos sub-grupos com você desejar.
	</para>
	<example>
     <title>Grupos de cache_id</title>
     <programlisting>
require('Smarty.class.php');
$smarty = new Smarty;

$smarty->caching = true;

// clear all caches with "sports|basketball" as the first two cache_id groups
$smarty->clear_cache(null,"sports|basketball");

// clear all caches with "sports" as the first cache_id group. This would
// include "sports|basketball", or "sports|(anything)|(anything)|(anything)|..."
$smarty->clear_cache(null,"sports");

$smarty->display('index.tpl',"sports|basketball");</programlisting>
    </example>
   <note>
   <title>Notas Técnicas</title>
   <para>
   O agrupamento de cache id NÃO use o path do template como alguma parte do cache_id.
   Por exemplo, se você tem display('themes/blue/index.tpl'), você não pode limpar o cache
   para tudo que estiver sob o diretório "themes/blue". Se você quiser fazer isso, você deve
   agrupá-los no cache_id, como display('themes/blue/index.tpl','themes|blue'); Então
   você pode limpar os caches para o 
   tema azul com with clear_cache(null,'themes|blue');
   </para>
   </note>
   </sect1>

   <sect1 id="caching.cacheable">
    <title>Controlling Cacheability of Plugins' Output</title>
	<para>
Desde Smarty-2.6.0 os caches de plugins pode ser declarados
ao registrá-los. O terceiro parâmetro para register_block,
register_compiler_function e register_function é chamado
<parameter>$cacheable</parameter> e o padrão para true que é também
o comportamento de plugins na versão da Smarty antecessores à 2.6.0
	</para>

	<para>
Quando registrando um plugin com $cacheable=false o plugin é chamado todo o tempo na página que está sendo mostrada, sempre se a página vier do cache. A função de plugin tem um comportamento levemente como uma função <link linkend="plugins.inserts">insert</link>.
	</para>

	<para>
Em contraste para <link linkend="language.function.insert">{insert}</link> o atributo para o plugin não está em cache por padrão. Eles podem ser declarados para serem cacheados com o quarto parâmetro <parameter>$cache_attrs</parameter>. <parameter>$cache_attrs</parameter> é um array de nomes de atributos que devem ser cacheados, então a função de plugin pega o valor como isso sendo o tempo que a página foi escrita para o cache todo o tempo isso é buscado do cache.
	</para>

	<example>
     <title>Prevenindo uma saída de plugin de ser cacheada</title>
     <programlisting>
index.php:

require('Smarty.class.php');
$smarty = new Smarty;
$smarty->caching = true;

function remaining_seconds($params, &amp;$smarty) {
    $remain = $params['endtime'] - time();
    if ($remain >=0)
        return $remain . " second(s)";
    else
        return "done";
}

$smarty->register_function('remaining', 'remaining_seconds', false, array('endtime'));

if (!$smarty->is_cached('index.tpl')) {
    // fetch $obj from db and assign...
    $smarty->assign_by_ref('obj', $obj);
}

$smarty->display('index.tpl');


index.tpl:

Tempo restante: {remain endtime=$obj->endtime}</programlisting>
	<para>
O número de segundos até que o endtime de $obj alcança alterações em cada display de página, mesmo que a página esteja em cache. Desde o atributo endtime esteja em cache o objeto somente tem que ser puxado do banco de dados quando a página está escrita para o cache mas não em requisições subsequentes da página. 
</para>
    </example>


	<example>
     <title>Prevenindo uma passagem inteira do template para o cache</title>
     <programlisting>
index.php:

require('Smarty.class.php');
$smarty = new Smarty;
$smarty->caching = true;

function smarty_block_dynamic($param, $content, &amp;$smarty) {
    return $content;
}
$smarty->register_block('dynamic', 'smarty_block_dynamic', false);

$smarty->display('index.tpl');


index.tpl:

Page created: {"0"|date_format:"%D %H:%M:%S"}

{dynamic}

Now is: {"0"|date_format:"%D %H:%M:%S"}

... do other stuff ...

{/dynamic}</programlisting>

	</example>
	<para>
Quando recarregado a página que você irá notar que ambas as datas diferem. Uma é "dinâmica" e uma é "estática". Você pode fazer qualquer coisa entre as tags {dynamic}...{/dynamic} e ter certeza que isso não irá ficar em cache como o restante da página. 
	</para>
   </sect1>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->