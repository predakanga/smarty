<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision$ -->
    <chapter id="language.builtin.functions">
     <title>Eingebaute Funktionen</title>
     <para>
      Smarty enth&auml;lt eine Reihe eingebauter Funktionen. Eingebaute Funktionen
      sind integral f&uuml;r die Template-Sprache. Sie k&ouml;nnen sie weder 
      ver&auml;ndern noch eigene Funktionen unter selbem Namen erstellen.
     </para>
     <sect1 id="language.function.capture">
      <title>capture (Ausgabe abfangen)</title>
            <informaltable frame="all">
                <tgroup cols="5">
                <colspec colname="param" align="center" />
                <colspec colname="type" align="center" />
                <colspec colname="required" align="center" />
                <colspec colname="default" align="center" />
                <colspec colname="desc" />
                <thead>
                    <row>
                        <entry>Attribut Name</entry>
                        <entry>Typ</entry>
                        <entry>Ben&ouml;tigt</entry>
                        <entry>Standardwert</entry>
                        <entry>Beschreibung</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>name</entry>
                        <entry>string</entry>
                        <entry>no</entry>
                        <entry><emphasis>default</emphasis></entry>
                        <entry>Der Name des abgefangenen Blocks</entry>
                    </row>
                    <row>
                        <entry>assign</entry>
                        <entry>string</entry>
                        <entry>No</entry>
                        <entry><emphasis>n/a</emphasis></entry>
                        <entry>Der Name der Variable welcher der Wert zugewiesen werden soll.</entry>
                    </row>
                </tbody>
                </tgroup>
            </informaltable>
      <para>
       'capture' wird verwendet, um die Template-Ausgabe abzufangen und in einer
       Variable zu speichern. Der Inhalt zwischen {capture name="foo"} und {/capture}
       wird unter der im 'name' Attribut angegebenen Variable abgelegt und kann &uuml;ber 
       '$smarty.capture.foo' angesprochen werden. Falls kein 'name'-Attribut
       &uuml;bergeben wurde, wird der Inhalt in 'default' abgelegt.
       Jede {capture} Sektion muss mit {/capture} beendet werden.
       'capture'-Bl&ouml;cke k&ouml;nnen verschachtelt sein.
      </para>
	  <note>
	  <title>Technische Bemerkung</title>
      <para>
       Smarty 1.4.0 - 1.4.4 speicherte den abgefangenen Inhalt in der
       Variable '$return'. Seit 1.4.5 wird das 'name'-Attribut verwenden.
       Bitte passen Sie Ihre Templates entsprechend an.
      </para>
	  </note>
      <caution>
       <para>
	Seien Sie vorsichtig, wenn sie die Ausgabe von <command>insert</command>
	abfangen wollen. Sie sollten die Ausgabe nicht abfangen, wenn Caching 
         eingeschaltet ist und Sie einen <command>insert</command>
	Befehl verwenden, um Ausgaben vom Caching auszuschliessen.
       </para>
      </caution>
      <para>
       <example>
        <title>Template-Inhalte abfangen</title>
        <programlisting>

{* Tabellenzeile nur ausgeben, wenn Inhalt vorhanden *}
{capture name=banner}
{include file="get_banner.tpl"}
{/capture}
{if $smarty.capture.banner ne ""}
	&lt;tr&gt;
		&lt;td&gt;
			{$smarty.capture.banner}
		&lt;/td&gt;
	&lt;/tr&gt;
{/if}</programlisting>
       </example>
      </para>
     </sect1>
		<sect1 id="language.function.config.load">
			<title>config_load (Konfiguration laden)</title>
            <informaltable frame="all">
                <tgroup cols="5">
                <colspec colname="param" align="center" />
                <colspec colname="type" align="center" />
                <colspec colname="required" align="center" />
                <colspec colname="default" align="center" />
                <colspec colname="desc" />
                <thead>
                    <row>
                        <entry>Attribut Name</entry>
                        <entry>Typ</entry>
                        <entry>Erforderlich</entry>       
                        <entry>Standardwert</entry>
                        <entry>Beschreibung</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>file</entry>
                        <entry>string</entry>
                        <entry>Ja</entry>
                        <entry><emphasis>n/a</emphasis></entry>
                        <entry>Definiert den Namen der einzubindenden Datei.</entry>
                    </row>
                    <row>
                        <entry>section</entry>
                        <entry>string</entry>
                        <entry>Nein</entry>
                        <entry><emphasis>n/a</emphasis></entry>
                        <entry>Definiert den Namen des zu ladenden Abschnitts.</entry>
                    </row>
                    <row>
                        <entry>scope</entry>
                        <entry>string</entry>
                        <entry>Nein</entry>
                        <entry><emphasis>local</emphasis></entry>
                        <entry>
			Definiert den Geltungsbereich der zu ladenden Variablen.
			Erlaubte Werte sind 'local','parent' und 'global'. 'local' bedeutet,
			dass die Variablen in den Context des lokalen Template geladen werden.
			'parent' bedeutet, dass die Variablen sowohl in den lokalen Context,
			als auch in den Context des aufrufenden Templates eingebunden werden. 
			'global' bedeutet, dass die Variablen von allen Templates zug&auml;nglich sind.
			</entry>
                    </row>
                    <row>
                        <entry>global</entry>
                        <entry>boolean</entry>
                        <entry>Nein</entry>
                        <entry><emphasis>No</emphasis></entry>
                        <entry>
						DEPRECATED:
						Definiert, ob die Variablen von allen Templates aus zug&auml;nglich sind.
						Dieses Attribut wird von 'scope' abgel&ouml;st und sollte nicht mehr 
                        verwendet werden. Falls 'scope' &uuml;bergeben wurde, wird 'global' ignoriert.
						</entry>
                    </row>
                </tbody>
                </tgroup>
            </informaltable>
			<para>
			Diese Funktion wird verwendet, um Variablen aus einer Konfigurationsdatei
			in das Template zu laden. Sehen sie <link linkend="config.files">Config Files (Konfigurationsdateien)</link>
			f&uuml;r weitere Informationen.
			</para>
<example>
<title>Funktion config_load</title>

<programlisting>
{config_load file="farben.conf"}
&lt;html&gt;
&lt;title&gt;{#seitenTitel#}&lt;/title&gt;
&lt;body bgcolor="{#bodyHintergrundFarbe#}"&gt;
&lt;table border="{#tabelleRahmenBreite#}" bgcolor="{#tabelleHintergrundFarbe#}"&gt;
&lt;tr bgcolor="{#reiheHintergrundFarbe#}"&gt;
        &lt;td&gt;Vornamen&lt;/td&gt;
        &lt;td&gt;Nachnamen&lt;/td&gt;
        &lt;td&gt;Adresse&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;</programlisting>
</example>
			<para>
	    Konfigurationsdateien k&ouml;nnen Abschnitte enthalten. Um Variablen
	    aus einem Abschnitt zu laden, k&ouml;nnen Sie das Attribut 
        <emphasis>section</emphasis> &uuml;bergeben.
			</para>
            <para>
	    Bemerkung: <emphasis>Konfigurationdatei-Abschnitte (sections)</emphasis> und die
	    eingebaute Template Funktion namens <emphasis>section</emphasis> haben ausser dem
        Namen nichts gemeinsam.
            </para>
<example>
<title>Funktion config_load mit Abschnitten</title>
<programlisting>
{config_load file="farben.conf" section="Kunde"}
&lt;html&gt;
&lt;title&gt;{#seitenTitel#}&lt;/title&gt;
&lt;body bgcolor="{#bodyHintergrundFarbe#}"&gt;
&lt;table border="{#tabelleRahmenBreite#}" bgcolor="{#tabelleHintergrundFarbe#}"&gt;
&lt;tr bgcolor="{#reiheHintergrundFarbe#}"&gt;
        &lt;td&gt;Vornamen&lt;/td&gt;
        &lt;td&gt;Nachnamen&lt;/td&gt;
        &lt;td&gt;Adresse&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/body&gt;
&lt;/html&gt;</programlisting>
</example>
		</sect1>
		<sect1 id="language.function.foreach">
			<title>foreach, foreachelse</title>
            <informaltable frame="all">
                <tgroup cols="5">
                <colspec colname="param" align="center" />
                <colspec colname="type" align="center" />
                <colspec colname="required" align="center" />
                <colspec colname="default" align="center" />
                <colspec colname="desc" />
                <thead>
                    <row>
                        <entry>Attribut Name</entry>
                        <entry>Typ</entry>
                        <entry>Erforderlich</entry>       
                        <entry>Standardwert</entry>
                        <entry>Beschreibung</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>from</entry>
                        <entry>string</entry>
                        <entry>Ja</entry>
                        <entry><emphasis>n/a</emphasis></entry>
                        <entry>Name des zu durchlaufenden Array.</entry>
                    </row>
                    <row>
                        <entry>item</entry>
                        <entry>string</entry>
                        <entry>Ja</entry>
                        <entry><emphasis>n/a</emphasis></entry>
                        <entry>Name f&uuml;r das aktuelle Element.</entry>
                    </row>
                    <row>
                        <entry>key</entry>
                        <entry>string</entry>
                        <entry>Nein</entry>
			<entry><emphasis>n/a</emphasis></entry>
			<entry>Name f&uuml;r den aktuellen Schl&uuml;ssel.</entry>
                    </row>
                    <row>
                        <entry>name</entry>
                        <entry>string</entry>
                        <entry>Nein</entry>
                        <entry><emphasis>n/a</emphasis></entry>
			<entry>Name der 'foreach'-Schleife, f&uuml;r die Abfrage der 'foreach'-Eigenschaften.</entry>
                    </row>
                </tbody>
                </tgroup>
            </informaltable>
			<para>
			Die <emphasis>foreach</emphasis> Schleife ist eine Alternative zu <emphasis>section</emphasis>.
			<emphasis>foreach</emphasis> wird verwendet, um ein assoziatives Array
			zu durchlaufen. Die Syntax von <emphasis>foreach</emphasis>-Schleifen ist viel einfacher als
			die von <emphasis>section</emphasis>. <emphasis>foreach</emphasis> tags m&uuml;ssen mit <emphasis>/foreach</emphasis>
			tags kombiniert werden. Erforderliche Parameter sind: <emphasis>from</emphasis> und
			<emphasis>item</emphasis>. Der Name der 'foreach'-Schleife kann frei vergeben werden
			und sowohl Buchstaben, Zahlen als auch Unterstriche enthalten. 
                            <emphasis>foreach</emphasis>-Schleifen k&ouml;nnen verschachtelt werden, dabei ist 
                            zu beachten, dass sich die definierten Namen voneinander unterscheiden. 
                            Die <emphasis>from</emphasis> Variable (normalerweise
			ein assoziatives Array) definiert die Anzahl der von <emphasis>foreach</emphasis>
			zu durchlaufenen Iterationen. <emphasis>foreachelse</emphasis> wird ausgef&uuml;hrt wenn
			keine Werte in der <emphasis>from</emphasis> Variable &uuml;bergeben wurden.
			</para>
<example>
<title>foreach</title>
<programlisting>



{* dieses Beispiel gibt alle Werte aus dem $KundenId Array aus *}
{foreach from=$KundenId item=aktuelle_id}
	id: {$aktuelle_id}&lt;br&gt;
{/foreach}

AUSGABE:

id: 1000&lt;br&gt;
id: 1001&lt;br&gt;
id: 1002&lt;br&gt;</programlisting>
</example>

<example>
<title>foreach key</title>
<programlisting>
{* Der Schl&uuml;ssel enth&auml;lt den Schl&uuml;ssel des jeweils iterierten Wertes

die Zuweisung sieht wie folgt aus:

$smarty->assign("kontakte", array(array("phone" =&gt; "1", "fax" =&gt; "2", "cell" =&gt; "3"),
      array("phone" =&gt; "555-4444", "fax" =&gt; "555-3333", "cell" =&gt; "760-1234")));

*}
      
{foreach name=aussen item=kontakt from=$kontakte}
  {foreach key=schluessel item=wert from=$kontakt}
    {$schluessel}: {$wert}&lt;br&gt;
  {/foreach}
{/foreach}

AUSGABE:

phone: 1&lt;br&gt;
fax: 2&lt;br&gt;
cell: 3&lt;br&gt;
phone: 555-4444&lt;br&gt;
fax: 555-3333&lt;br&gt;
cell: 760-1234&lt;br&gt;</programlisting>
</example>

               <para>
         Foreach-Loops haben auch eigene Variablen welche die Foreach Eigenschaften enthalten.
	 Diese werden wie folgt ausgewiesen: {$smarty.foreach.foreachname.varname}. foreachname
	 ist der Name der als <emphasis>name</emphasis> Attribut von Foreach &uuml;bergeben wurden.
               </para>
                       <sect2 id="foreach.property.iteration">
                       <title>iteration</title>
                       <para>
		       gibt die aktuelle iteration aus
                       </para>
                       <para>
		       iteration beginnt immer mit 1 und wird danach bei jedem durchgang um 1 inkrementiert.
                       </para>
                       </sect2>

                       <sect2 id="foreach.property.first">
                       <title>first</title>
                       <para>
               <emphasis>first</emphasis> ist TRUE wenn die aktuelle Iteration die erste ist
                       </para>
                       </sect2>

                       <sect2 id="foreach.property.last">
                       <title>last</title>
                       <para>
               <emphasis>last</emphasis> ist TRUE wenn die aktuelle Iteration die letzte ist
                       </para>
                       </sect2>

                       <sect2 id="foreach.property.show">
                       <title>show</title>
                       <para>
	               <emphasis>show</emphasis> wird als Parameter von foreach verwedet und ist ein boolscher Wert, TRUE oder FALSE. Auf FALSE wird
		       nichts ausgegeben und wenn foreachelse gefunden wird, dieser angezeigt.
                       </para>

                       </sect2>
                       <sect2 id="foreach.property.total">
                       <title>total</title>
                       <para>
                       <emphasis>total</emphasis> gibt die Anzahl Iterationen des Foreach Loops aus und kann in- oder nach- Foreach Bl&ouml;cken verwendet werden.
                       </para>
                       </sect2>

		</sect1>
		<sect1 id="language.function.include">
			<title>include (einbinden)</title>
            <informaltable frame="all">
                <tgroup cols="5">
                <colspec colname="param" align="center" />
                <colspec colname="type" align="center" />
                <colspec colname="required" align="center" />
                <colspec colname="default" align="center" />
                <colspec colname="desc" />
                <thead>
                    <row>
                        <entry>Attribut Name</entry>
                        <entry>Typ</entry>
                        <entry>Erforderlich</entry>       
                        <entry>Standardwert</entry>
                        <entry>Beschreibung</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>file</entry>
                        <entry>string</entry>
                        <entry>Ja</entry>
                        <entry><emphasis>n/a</emphasis></entry>
                        <entry>Name der Template-Datei, die eingebunden werden soll.</entry>
                    </row>
                    <row>
                        <entry>assign</entry>
                        <entry>string</entry>
                        <entry>Nein</entry>
                        <entry><emphasis>n/a</emphasis></entry>
                        <entry>Variable, welcher der eingebundene Inhalt zugewiesen werden soll.</entry>
                    </row>
                    <row>
                        <entry>[var ...]</entry>
                        <entry>[var typ]</entry>
                        <entry>Nein</entry>
                        <entry><emphasis>n/a</emphasis></entry>
                        <entry>Variablen welche dem Template lokal &uuml;bergeben werden sollen.</entry>
                    </row>
                </tbody>
                </tgroup>
            </informaltable>
			<para>
	    Include Tags werden verwendet, um andere Templates in das aktuelle Template einzubinden.
	    Alle Variablen des aktuellen Templates sind auch im eingebundenen Template verf&uuml;gbar.
	    Das include-Tag muss ein 'file' Attribut mit dem Pfad zum einzubindenden
	    Template enthalten.
			</para>
			<para>
			Optional kann mit dem <emphasis>assign</emphasis> Attribut definiert werden,
			in welcher Variable die Ausgabe des mit <emphasis>include</emphasis> eingebundenen
			Templates abgelegt werden soll statt sie auszugeben.
			</para>
<example>
<title>function include (einbinden)</title>
<programlisting>
{include file="header.tpl"}

{* hier kommt der body des Templates *}

{include file="footer.tpl"}</programlisting>
</example>
			<para>
			Sie k&ouml;nnen dem einzubindenden Template Variablen
			als Attribute &uuml;bergeben. Alle explizit &uuml;bergebenen
			Variablen sind nur im Anwendungsbereich (scope) dieses Template
			verf&uuml;gbar. Attribut-Variablen &uuml;berschreiben
			aktuelle Template-Variablen, falls sie den gleichen Namen haben.
			</para>
<example>
<title>include-Funktion und Variablen &Uuml;bergabe</title>
<programlisting>
{include file="header.tpl" title="Hauptmenu" table_bgcolor="#c0c0c0"}

{* hier kommt der body des Templates *}

{include file="footer.tpl" logo="http://my.domain.com/logo.gif"}</programlisting>
</example>
			<para>
			Benutzen sie die Syntax von <link linkend="template.resources">template resources</link>,
            um Templates ausserhalb des '$template_dir' einzubinden:
			</para>
<example>
<title>Beispiele f&uuml;r Template-Ressourcen bei der 'include'-Funktion</title>
<programlisting>
{* absoluter Dateipfad *}
{include file="/usr/local/include/templates/header.tpl"}

{* absoluter Dateipfad (gleich) *}
{include file="file:/usr/local/include/templates/header.tpl"}

{* absoluter Dateipfad unter Windows ("file:"-Prefix MUSS &uuml;bergeben werden) *}
{include file="file:C:/www/pub/templates/header.tpl"}

{* einbinden aus Template-Ressource namens 'db' *}
{include file="db:header.tpl"}</programlisting>
</example>
		</sect1>
		<sect1 id="language.function.include.php">
			<title>include_php (PHP-Code einbinden)</title>
            <informaltable frame="all">
                <tgroup cols="5">
                <colspec colname="param" align="center" />
                <colspec colname="type" align="center" />
                <colspec colname="required" align="center" />
                <colspec colname="default" align="center" />
                <colspec colname="desc" />
                <thead>
                    <row>
                        <entry>Attribut Name</entry>
                        <entry>Typ</entry>
                        <entry>Erforderlich</entry>       
                        <entry>Standardwert</entry>
                        <entry>Beschreibung</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>file</entry>
                        <entry>string</entry>
                        <entry>Ja</entry>
                        <entry><emphasis>n/a</emphasis></entry>
                        <entry>Der Name der einzubindenden PHP-Datei.</entry>
                    </row>
                    <row>
                        <entry>once</entry>
                        <entry>boolean</entry>
                        <entry>Nein</entry>
                        <entry><emphasis>true</emphasis></entry>
                        <entry>Definiert ob die Datei mehrmals geladen werden soll, falls sie mehrmals eingebunden wird.</entry>
                    </row>
                    <row>
                        <entry>assign</entry>
                        <entry>string</entry>
                        <entry>Nein</entry>
                        <entry><emphasis>n/a</emphasis></entry>
                        <entry>Der Name der Variable, der die Ausgabe von include_php zugewiesen wird.</entry>
                    </row>
                </tbody>
                </tgroup>
            </informaltable>
			<para>
			include_php-Tags werden verwendet, um PHP-Skripte in Ihre Templates
			einzubinden. Falls 'Sicherheit' aktiviert ist,
			muss das einzubindende Skript im '$trusted_dir' Pfad liegen. 
                            'include_php' muss das Attribut 'file' &uuml;bergeben werden, 
                            das den Pfad - entweder relativ zu '$trusted_dir' oder absolut -
			zum Skript enth&auml;lt.
			</para>
			<para>
			include_php ist ein einfacher Weg, um modularisierte Templates zu
			verwenden und PHP-Code von HTML zu separieren. Sie haben zum Beispiel
			ein Template f&uuml;r die Seitennavigation, welche direkt
			aus der Datenbank bezogen wird. Die Logik, die den Datenbankinhalt bezieht, 
                            k&ouml;nnen sie in einer eigenen Datei ablegen und am
			Anfang Ihres Templates einbinden. Nun k&ouml;nnen Sie das Template
			&uuml;berall wiederverwenden, ohne sich Gedanken zu machen, wie der Inhalt
			in die Navigationsstruktur gelangt.
			</para>
			<para>
			Normalerweise wird ein PHP-Skript nur einmal pro Aufruf geladen,
			selbst wenn es mehrfach eingebunden wird. Sie k&ouml;nnen dieses
			Verhalten durch die Verwendung des <emphasis>once</emphasis> Attributs
			steuern. Wenn Sie 'once' auf 'false' setzen, wird die Datei immer
			wenn sie eingebunden wird auch neu geladen.
			</para>
			<para>
			Optional kann das <emphasis>assign</emphasis> Attribut &uuml;bergeben werden.
			Die Ausgabe von <emphasis>include_php</emphasis> wird dann nicht direkt eingef&uuml;gt,
			sondern in der durch assign benannten Template-Variable abgelegt.
			</para>
			<para>
			Das Objekt '$smarty' kann in dem eingebundenen PHP-Script &uuml;ber '$this' angesprochen werden.
			</para>
<example>
<title>Funktion include_php</title>
<programlisting>
lade_nav.php
-------------

&lt;?php

	
	// lade die Variablen aus einer MySQL-Datenbank und weise sie dem Template zu
	require_once("MySQL.class.php");
	$sql = new MySQL;
	$sql->query("select * from site_nav_sections order by name",SQL_ALL);
	$this->assign($sections,$sql->record);

?&gt;


index.tpl
---------


{* absoluter Pfad, oder relativ zu '$trusted_dir' *}
{include_php file="/pfad/zu/lade_nav.php"}

{foreach item=$aktuelle_section from=$sections}
	&lt;a href="{$aktuelle_section.url}"&gt;{$aktuelle_section.name}&lt;/a&gt;&lt;br&gt;
{/foreach}</programlisting>
</example>
		</sect1>
		<sect1 id="language.function.insert">
			<title>insert (einf&uuml;gen)</title>
            <informaltable frame="all">
                <tgroup cols="5">
                <colspec colname="param" align="center" />
                <colspec colname="type" align="center" />
                <colspec colname="required" align="center" />
                <colspec colname="default" align="center" />
                <colspec colname="desc" />
                <thead>
                    <row>
                        <entry>Attribut Name</entry>
                        <entry>Typ</entry>
                        <entry>Erforderlich</entry>       
                        <entry>Standardwert</entry>
                        <entry>Beschreibung</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>name</entry>
                        <entry>string</entry>
                        <entry>Ja</entry>
                        <entry><emphasis>n/a</emphasis></entry>
                        <entry>Der Name der Insert-Funktion</entry>
                    </row>
                    <row>
                        <entry>assign</entry>
                        <entry>string</entry>
                        <entry>Nein</entry>
                        <entry><emphasis>n/a</emphasis></entry>
                        <entry>Name der Template-Variable, in der die Ausgabe der 'insert'-Funktion optional abgelegt wird.</entry>
                    </row>
                    <row>
                        <entry>script</entry>
                        <entry>string</entry>
                        <entry>Nein</entry>
                        <entry><emphasis>n/a</emphasis></entry>
                        <entry>Name des PHP-Skriptes, das vor Aufruf der 'insert'-Funktion eingebunden werden soll.</entry>
                    </row>
                    <row>
                        <entry>[var ...]</entry>
                        <entry>[var typ]</entry>
                        <entry>Nein</entry>
                        <entry><emphasis>n/a</emphasis></entry>
                        <entry>Variablen die der 'insert'-Funktion &uuml;bergeben werden sollen.</entry>
                    </row>
                </tbody>
                </tgroup>
            </informaltable>
			<para>
			'insert'-Tags funktionieren &auml;hnlich den 'include'-Tags,
			werden aber nicht gecached, falls <link linkend="caching">caching</link>
			eingeschaltet ist. Sie werden bei jedem Aufruf des Templates ausgef&uuml;hrt.
			</para>
            <para>
	        Stellen Sie sich vor, sie h&auml;tten ein Template mit einem
	        Werbebanner. Dieser Banner kann verschiedene Arten von
	        Inhalten haben: Bilder, HTML, Flash, etc. 
            Deshalb k&ouml;nnen wir nicht einfach einen statischen Link
	        verwenden und m&uuml;ssen vermeiden, dass dieser Inhalt gecached wird.
	        Hier kommt das 'insert'-Tag ins Spiel. Das Template kennt die Variablen
	        '#banner_location_id#' und '#site_id#' (zum Beispiel aus einer Konfigurationsdatei)
	        und soll eine Funktion aufrufen, die den Inhalt des Banners liefert.
			</para>
<example>
<title>Funktion 'insert'</title>
<programlisting>

{* erzeugen des Banners *}
{insert name="getBanner" lid=#banner_location_id# sid=#site_id#}</programlisting>
</example>
			<para>
			In diesem Beispiel verwenden wir die Funktion 'getBanner' und
			&uuml;bergeben die Parameter '#banner_location_id#' und '#site_id#'.
			Smarty wird daraufhin in Ihrer Applikatiopn nach einer Funktion
			namens 'getBanner' suchen und diese mit den Parametern '#banner_location_id#'
			und '#site_id#' aufrufen. Allen 'insert'-Funktionen in Ihrer Applikation
			muss 'insert_' vorangestellt werden, um Konflikte im Namensraum
			zu vermeiden. Ihre 'insert_getBanner()'-Funktion sollte etwas mit den
			&uuml;bergebenen Parametern unternehmen und das Resultat zur&uuml;ckgeben.
			Dieses Resultat wird an der Stelle des 'insert'-Tags in Ihrem Template ausgegeben.
			In diesem Beispiel w&uuml;rde Smarty folgende Funktion aufrufen:
			insert_getBanner(array("lid" => "12345","sid" => "67890")) und die erhaltenen Resultate
			an Stelle des 'insert'-Tags ausgeben.
			</para>
			<para>
			Falls Sie das 'assign'-Attribut &uuml;bergeben, wird die Ausgabe
			des 'insert'-Tags in dieser Variablen abgelegt. 
                            Bemerkung: dies ist nicht sinnvoll, wenn Caching eingeschaltet ist.
			</para>
			<para>
			Falls Sie das 'script'-Attribut &uuml;bergeben, wird das angegebene
			PHP-Skript vor der Ausf&uuml;hrung der 'insert'-Funktion eingebunden.
			Dies ist n&uuml;tzlich, um die 'insert'-Funktion erst in diesem
			Skript zu definieren.
			Der Pfad kann absolut oder relativ zu '$trusted_dir' angegeben werden.
			Wenn Sicherheit eingeschaltet ist, muss das Skript in '$trusted_dir'
			liegen.
			</para>
			<para>
			Als zweites Argument wird der 'insert'-Funktion das Smarty-Objekt selbst
                            &uuml;bergeben. Damit kann dort auf die Informationen im Smarty-Objekt 
                            zugegriffen werden.
			</para>
			<note>
			<title>Technische Bemerkung</title>
			<para>
	    Es gibt die M&ouml;glichkeit, Teile des Templates nicht zu cachen.
	    Wenn Sie <link linkend="caching">caching</link> eingeschaltet haben,
	    werden 'insert'-Tags nicht gecached. Sie werden jedesmal ausgef&uuml;hrt, wenn
	    die Seite erstellt wird - selbst innerhalb gecachter Seiten. Dies funktioniert
	    gut f&uuml;r Dinge wie Werbung (Banner), Abstimmungen, Wetterberichte, Such-Resultate, Benutzer-Feedback-Ecke, etc.
			</para>
			</note>
		</sect1>
		<sect1 id="language.function.if">
			<title>if,elseif,else</title>
			<para>
			'if'-Statements in Smarty erlauben die selbe Flexibilit&auml;t
			wie in PHP, bis auf ein paar Erweiterungen f&uuml;r die Template-Engine.
			Jedes <emphasis>if</emphasis> muss mit einem <emphasis>/if</emphasis>
			kombiniert sein. <emphasis>else</emphasis> und <emphasis>elseif</emphasis>
			sind ebenfalls erlaubt. "eq", "ne","neq","gt", "lt", "lte", "le", "gte" "ge",
			"is even","is odd", "is noteven","is not odd","not","mod","div by","even by",
			"odd by","==","!=","&gt;", "&lt;","&lt;=","&gt;=" sind alles erlaubte Bedingungen,
                            und m&uuml;ssen von umgebenden Elementen mit Leerzeichen abgetrennt werden.
			</para>
<example>
<title>if Anweisung</title>
<programlisting>

{* ein Beispiel mit 'eq' (gleich) *}
{if $name eq "Fred"}
	Willkommen der Herr.
{elseif $name eq "Wilma"}
	Willkommen die Dame.
{else}
	Willkommen, was auch immer Du sein magst.
{/if}

{* ein Beispiel mit 'or'-Logik *}
{if $name eq "Fred" or $name eq "Wilma"}
	...
{/if}

{* das selbe *}
{if $name == "Fred" || $name == "Wilma"}
	...
{/if}

{* die foldende Syntax ist nicht korrekt, da die Elemente welche die
   Bedingung umfassen nicht mit Leerzeichen abgetrennt sind*}
{if $name=="Fred" || $name=="Wilma"}
	...
{/if}



{* Klammern sind erlaubt *}
{if ( $anzahl &lt; 0 or $anzahl &gt; 1000 ) and $menge &gt;= #minMengeAmt#}
	...
{/if}


{* einbetten von php Funktionsaufrufen ('gt' steht f&uuml;r 'gr&ouml;sser als') *}
{if count($var) gt 0}
	...
{/if}


{* testen ob eine Zahl gerade (even) oder ungerade (odd) ist *}
{if $var is even}
	...
{/if}
{if $var is odd}
	...
{/if}
{if $var is not odd}
	...
{/if}


{* testen ob eine Zahl durch 4 teilbar ist (div by) *}
{if $var is div by 4}
	...
{/if}


{* testen ob eine Variable gerade ist, gruppiert nach 2
   0=gerade, 1=gerade, 2=ungerade, 3=ungerade, 4=gerade, 5=gerade, etc *}
{if $var is even by 2}
	...
{/if}

{* 0=gerade, 1=gerade, 2=gerade, 3=ungerade, 4=ungerade, 5=ungerade, etc *}
{if $var is even by 3}
	...
{/if}</programlisting>
</example>
		</sect1>
		<sect1 id="language.function.ldelim">
			<title>ldelim,rdelim (Ausgabe der Trennzeichen)</title>
			<para>
			ldelim und rdelim werden verwendet, um die Trennzeichen auszugeben -
			in unserem Fall "{" oder "}" - ohne dass Smarty versucht, sie zu 
            interpretieren.
			</para>
<example>
<title>ldelim, rdelim</title>
<programlisting>

{* gibt die konfigurierten Trennzeichen des Templates aus *}

{ldelim}funktionsname{rdelim} Funktionen sehen in Smarty so aus!


AUSGABE:

{funktionsname} Funktionen sehen in Smarty so aus!</programlisting>
</example>
		</sect1>
		<sect1 id="language.function.literal">
			<title>literal</title>
			<para>
			'literal'-Tags erlauben es, einen Block w&ouml;rtlich auszugeben,
            d.h. von der Interpretation durch Smarty auszuschliessen. 
            Dies ist vor allem f&uuml;r Javascript- oder andere Bl&ouml;cke 
            n&uuml;tzlich, die geschwungene Klammern verwenden. Alles 
            was zwischen den {literal}{/literal} Tags steht, wird direkt 
            angezeigt.</para>
<example>
<title>literal-Tags</title>
<programlisting>
{literal}
	&lt;script language=javascript&gt;

        	&lt;!--
                	function isblank(field) {
                	if (field.value == '') 
                        	{ return false; }
                	else
                        	{
                        	document.loginform.submit();
                        	return true;
                        	}
                	}
        	// --&gt;

	&lt;/script&gt;
{/literal}</programlisting>
</example>
		</sect1>
		<sect1 id="language.function.php">
			<title>php</title>
			<para>
			'php'-Tags erlauben es, PHP-Code direkt in das Template einzubetten. Der Inhalt
			wird nicht 'escaped', egal wie <link linkend="variable.php.handling">$php_handling</link> 
			konfiguriert ist. 
                            Dieses Tag ist nur f&uuml;r erfahrene Benutzer gedacht und wird 
                            auch von diesen normalerweise nicht ben&ouml;tigt.
			</para>
<example>
<title>php-Tags</title>
<programlisting>
{php}
		// php Skript direkt von Template einbinden
		include("/pfad/zu/zeige_weather.php");
{/php}</programlisting>
</example>
		</sect1>
		<sect1 id="language.function.section">
			<title>section,sectionelse</title>
            <informaltable frame="all">
                <tgroup cols="5">
                <colspec colname="param" align="center" />
                <colspec colname="type" align="center" />
                <colspec colname="required" align="center" />
                <colspec colname="default" align="center" />
                <colspec colname="desc" />
                <thead>
                    <row>
                        <entry>Attribut Name</entry>
                        <entry>Typ</entry>
                        <entry>Erforderlich</entry>       
                        <entry>Standardwert</entry>
                        <entry>Beschreibung</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>name</entry>
                        <entry>string</entry>
                        <entry>Ja</entry>
                        <entry><emphasis>n/a</emphasis></entry>
                        <entry>Der Name der 'section'</entry>
                    </row>
                    <row>
                        <entry>loop</entry>
                        <entry>[$variable_name]</entry>
                        <entry>Ja</entry>
                        <entry><emphasis>n/a</emphasis></entry>
                        <entry>Der Name des Z&auml;hlers f&uuml;r die Iterationen.</entry>
                    </row>
                    <row>
                        <entry>start</entry>
                        <entry>integer</entry>
                        <entry>Nein</entry>
			<entry><emphasis>0</emphasis></entry>
			<entry>
			Definiert die Startposition. Falls ein negativer Wert &uuml;bergeben wird,
			berechnet sich die Startposition ausgehend vom Ende des Arrays. Wenn zum Beispiel
			7 Werte in einem Array enthalten sind und die Startposition -2 ist, ist die
			berechnete Startposition 5. Unerlaubte Werte (Werte ausserhalb der Gr&ouml;sse des
			Arrays) werden automatisch auf den n&auml;chstm&ouml;glichen Wert gesetzt.</entry>
                    </row>
                    <row>
                        <entry>step</entry>
                        <entry>integer</entry>
                        <entry>Nein</entry>
                        <entry><emphasis>1</emphasis></entry>
			<entry>
			Definiert die Schrittweite mit welcher das Array durchlaufen wird.
			'step=2' iteriert durch 0, 2, 4, etc. Wenn ein negativer Wert &uuml;bergeben wurde,
			wird das Array r&uuml;ckw&auml;rts durchlaufen.
			</entry>
                    </row>
                    <row>
                        <entry>max</entry>
                        <entry>integer</entry>
                        <entry>Nein</entry>
                        <entry><emphasis>1</emphasis></entry>
			<entry>Maximale Anzahl an Iterationen, die Durchlaufen werden.</entry>
                    </row>
                    <row>
                        <entry>show</entry>
                        <entry>boolean</entry>
                        <entry>Nein</entry>
                        <entry><emphasis>true</emphasis></entry>
                        <entry>Definiert ob diese 'section' angezeigt werden soll oder nicht.</entry>
                    </row>
                </tbody>
                </tgroup>
            </informaltable>
			<para>
			Template-'sections' werden verwendet, um durch Arrays zu iterieren.
			Jedes <emphasis>section</emphasis>-Tag muss mit einem <emphasis>/section</emphasis>-Tag
			kombiniert werden. <emphasis>name</emphasis> und <emphasis>loop</emphasis> sind erforderliche
			Parameter. Der Name der 'section' kann frei gew&auml;hlt werden, muss jedoch aus Buchstaben, 
                            Zahlen oder Unterstrichen bestehen. 'sections' k&ouml;nnen verschachtelt werden. Dabei ist 
                            zu beachten, dass sich ihre Namen unterscheiden. Aus der 'loop'-Variable (normalerweise ein 
                            Array von Werten) resultiert die Anzahl der Iterationen, die durchlaufen werden. 
                            Wenn ein Wert aus der 'loop'-Variable innerhalb der 'section' ausgegeben werden soll, 
                            muss der 'section-name' umschlossen mit [] angef&uuml;gt werden.
			<emphasis>sectionelse</emphasis> wird ausgef&uuml;hrt, wenn keine Werte in der 
                            'loop'-Variable enthalten sind.
			</para>
<example>
<title>section</title>
<programlisting>


{* dieses Beispiel gibt alle Werte des $KundenId Arrays aus *}
{section name=kunde loop=$KundenId}
	id: {$KundenId[kunde]}&lt;br&gt;
{/section}

AUSGABE:

id: 1000&lt;br&gt;
id: 1001&lt;br&gt;
id: 1002&lt;br&gt;</programlisting>
</example>

<example>
<title>section loop Variable</title>
<programlisting>
{* die 'loop'-Variable definiert nur die Anzahl der Iterationen,
   Sie k&ouml;nnen in dieser 'section' auf jeden Wert des Templates
   zugreifen. Dieses Beispiel geht davon aus, dass $KundenId, $Namen und
   $Adressen Arrays sind, welche die selbe Anzahl Werte enthalten *}
{section name=kunde loop=$KundenId}
	id: {$KundenId[kunde]}&lt;br&gt;
	name: {$Namen[kunde]}&lt;br&gt;
	address: {$Adressen[kunde]}&lt;br&gt;
	&lt;p&gt;
{/section}


AUSGABE:

id: 1000&lt;br&gt;
name: Peter M&uuml;ller &lt;br&gt;
adresse: 253 N 45th&lt;br&gt;
&lt;p&gt;
id: 1001&lt;br&gt;
name: Fritz Muster&lt;br&gt;
adresse:: 417 Mulberry ln&lt;br&gt;
&lt;p&gt;
id: 1002&lt;br&gt;
name: Hans Meier&lt;br&gt;
adresse:: 5605 apple st&lt;br&gt;
&lt;p&gt;</programlisting>
</example>

<example>
<title>section names</title>
<programlisting>
{* die 'name'-Variable definiert den Namen der verwendet werden soll,
   um Daten aus dieser 'section' zu referenzieren *}
{section name=meinedaten loop=$KundenId}
	id: {$KundenId[meinedaten]}&lt;br&gt;
	name: {$Namen[meinedaten]}&lt;br&gt;
	address: {$Adressen[meinedaten]}&lt;br&gt;
	&lt;p&gt;
{/section}</programlisting>
</example>

<example>
<title>nested sections (verschachtelte 'sections')</title>
<programlisting>
{* Sections k&ouml;nnen unbegrenzt tief verschachtelt werden.
   Mit verschachtelten 'sections' k&ouml;nnen Sie auf komplexe Datenstrukturen
   zugreifen (wie zum Beispiel multidimensionale Arrays). Im folgenden Beispiel
   ist $contact_type[customer] ein Array mit Kontakttypen des aktuellen Kunden. *}
{section name=customer loop=$custid}
	id: {$custid[customer]}&lt;br&gt;
	name: {$name[customer]}&lt;br&gt;
	address: {$address[customer]}&lt;br&gt;
	{section name=contact loop=$contact_type[customer]}
		{$contact_type[customer][contact]}: {$contact_info[customer][contact]}&lt;br&gt;
	{/section}
	&lt;p&gt;
{/section}


AUSGABE:

id: 1000&lt;br&gt;
name: John Smith&lt;br&gt;
address: 253 N 45th&lt;br&gt;
home phone: 555-555-5555&lt;br&gt;
cell phone: 555-555-5555&lt;br&gt;
e-mail: john@mydomain.com&lt;br&gt;
&lt;p&gt;
id: 1001&lt;br&gt;
name: Jack Jones&lt;br&gt;
address: 417 Mulberry ln&lt;br&gt;
home phone: 555-555-5555&lt;br&gt;
cell phone: 555-555-5555&lt;br&gt;
e-mail: jack@mydomain.com&lt;br&gt;
&lt;p&gt;
id: 1002&lt;br&gt;
name: Jane Munson&lt;br&gt;
address: 5605 apple st&lt;br&gt;
home phone: 555-555-5555&lt;br&gt;
cell phone: 555-555-5555&lt;br&gt;
e-mail: jane@mydomain.com&lt;br&gt;
&lt;p&gt;</programlisting>
</example>

<example>
<title>sections und assoziative Arrays</title>
<programlisting>
{* Dies ist ein Beispiel wie man einen assoziativen Array
   in einer 'section' ausgeben kann.*}
{section name=customer loop=$contacts}
	name: {$contacts[customer].name}&lt;br&gt;
	home: {$contacts[customer].home}&lt;br&gt;
	cell: {$contacts[customer].cell}&lt;br&gt;
	e-mail: {$contacts[customer].email}&lt;p&gt;
{/section}

{* Anm. d. &uuml;bersetzers: Oft ist die Anwendung von 'foreach' k&uuml;rzer. *}

{foreach item=customer from=$contacts}
	name: {$customer.name}&lt;br&gt;
	home: {$customer.home}&lt;br&gt;
	cell: {$customer.cell}&lt;br&gt;
	e-mail: {$customer.email}&lt;p&gt;
{/foreach}


AUSGABE:

name: John Smith&lt;br&gt;
home: 555-555-5555&lt;br&gt;
cell: 555-555-5555&lt;br&gt;
e-mail: john@mydomain.com&lt;p&gt;
name: Jack Jones&lt;br&gt;
home phone: 555-555-5555&lt;br&gt;
cell phone: 555-555-5555&lt;br&gt;
e-mail: jack@mydomain.com&lt;p&gt;
name: Jane Munson&lt;br&gt;
home phone: 555-555-5555&lt;br&gt;
cell phone: 555-555-5555&lt;br&gt;
e-mail: jane@mydomain.com&lt;p&gt;</programlisting>
</example>



<example>
<title>sectionelse</title>
<programlisting>
{* sectionelse wird aufgerufen, wenn keine $custid Werte vorhanden sind *}
{section name=customer loop=$custid}
	id: {$custid[customer]}&lt;br&gt;
{sectionelse}
	keine Werte in $custid gefunden
{/section}</programlisting>
</example>
		<para>
		Die Eigenschaften der 'section' werden in besonderen Variablen abgelegt. 
                   Diese sind wie folgt aufgebaut: {$smarty.section.sectionname.varname}
		</para>
		<para>
		Bermerkung: Seit Smarty 1.5.0 hat sich die Syntax der 'section' Eigenschaften
		von {%sectionname.varname%} zu {$smarty.section.sectionname.varname} ge&auml;ndert.
		Die alte Syntax wird noch immer unterst&uuml;tzt, die Dokumentation erw&auml;hnt
		jedoch nur noch die neue Schreibweise.
		</para>
			<sect2 id="section.property.index">	
			<title>index</title>
			<para>
			'index' wird verwendet, um den aktuellen Schleifen-Index anzuzeigen. Er startet
			bei 0 (beziehungsweise der definierten Startposition) und inkrementiert in 1-er Schritten
			(beziehungsweise der definierten Schrittgr&ouml;sse).
			</para>
			<note>
				<title>Technische Bemerkung</title>
				<para>
				Wenn 'step' und 'start' nicht &uuml;bergeben werden, verh&auml;lt sich
				der Wert wie die 'section'-Eigenschaft 'iteration', ausser dass
				er bei 0 anstatt 1 beginnt.
				</para>
			</note>
	<example>
	<title>'section'-Eigenschaft 'index'</title>
	<programlisting>
	{section name=customer loop=$custid}
	{$smarty.section.customer.index} id: {$custid[customer]}&lt;br&gt;
	{/section}


	AUSGABE:

	0 id: 1000&lt;br&gt;
	1 id: 1001&lt;br&gt;
	2 id: 1002&lt;br&gt;
</programlisting>
	</example>
			</sect2>
			<sect2 id="section.property.index.prev">	
			<title>index_prev</title>
			<para>
			'index_prev' wird verwendet um den vorhergehenden Schleifen-Index
			auszugeben. Bei der ersten Iteration ist dieser Wert -1.
			</para>
	<example>
	<title>section'-Eigenschaft 'index_prev'</title>
	<programlisting>
	{section name=customer loop=$custid}
	{$smarty.section.customer.index} id: {$custid[customer]}&lt;br&gt;
	{* zur Information, $custid[customer.index] und $custid[customer] bedeuten das selbe *}
	{if $custid[customer.index_prev] ne $custid[customer.index]}
    		Die Kundennummer hat sich ge&auml;ndert.&lt;br&gt;
	{/if}
	{/section}


	AUSGABE:

	0 id: 1000&lt;br&gt;
    	Die Kundennummer hat sich ge&auml;ndert.&lt;br&gt;
	1 id: 1001&lt;br&gt;
    	Die Kundennummer hat sich ge&auml;ndert.&lt;br&gt;
	2 id: 1002&lt;br&gt;
    	Die Kundennummer hat sich ge&auml;ndert.&lt;br&gt;
</programlisting>
	</example>
			</sect2>
			<sect2 id="section.property.index.next">
			<title>index_next</title>
			<para>
		'index_next' wird verwendet um den n&auml;chsten 'loop'-Index
		auszugeben. Bei der letzten Iteration ist dieser Wert um 1 gr&ouml;sser
		als der aktuelle 'loop'-Index (inklusive dem definierten 'step' Wert).
			</para>
	<example>
	<title>section'-Eigenschaft 'index_next'</title>
	<programlisting>
	{section name=customer loop=$custid}
	{$smarty.section.customer.index} id: {$custid[customer]}&lt;br&gt;
	{* zur Information, $custid[customer.index] und $custid[customer] bedeuten das selbe *}
	{if $custid[customer.index_next] ne $custid[customer.index]}
    		Die Kundennummer wird sich &auml;ndern.&lt;br&gt;
	{/if}
	{/section}


	AUSGABE:

	0 id: 1000&lt;br&gt;
    	Die Kundennummer wird sich &auml;ndern.&lt;br&gt;
	1 id: 1001&lt;br&gt;
    	Die Kundennummer wird sich &auml;ndern.&lt;br&gt;
	2 id: 1002&lt;br&gt;
    	Die Kundennummer wird sich &auml;ndern.&lt;br&gt;
</programlisting>
	</example>
			</sect2>
			<sect2 id="section.property.iteration">
			<title>iteration</title>
			<para>
		'iteration' wird verwendet um die aktuelle Iteration auszugeben.
			</para>
			<para>
			Bemerkung: Die Eigenschaften 'start', 'step' und 'max' beeinflussen 'iteration'
                            nicht, die Eigenschaft 'index' jedoch schon. 'iteration' startet im gegensatz 
                            zu 'index' bei 1. 'rownum' ist ein Alias f&uuml;r 'iteration' und arbeitet identisch.
			</para>
	<example>
	<title>'section'-Eigenschaft 'iteration'</title>
	<programlisting>
	{section name=customer loop=$custid start=5 step=2}
	aktuelle loop iteration: {$smarty.section.customer.iteration}&lt;br&gt;
	{$smarty.section.customer.index} id: {$custid[customer]}&lt;br&gt;
	{* zur Information, $custid[customer.index] und $custid[customer] bedeuten das gleiche *}
	{if $custid[customer.index_next] ne $custid[customer.index]}
    	Die Kundennummer wird sich &auml;ndern.&lt;br&gt;
	{/if}
	{/section}


	AUSGABE:

	aktuelle loop iteration: 1
	5 id: 1000&lt;br&gt;
    	Die Kundennummer wird sich &auml;ndern.&lt;br&gt;
	aktuelle loop iteration: 2
	7 id: 1001&lt;br&gt;
    	Die Kundennummer wird sich &auml;ndern.&lt;br&gt;
	aktuelle loop iteration: 3
	9 id: 1002&lt;br&gt;
    	Die Kundennummer wird sich &auml;ndern.&lt;br&gt;
</programlisting>
	</example>
			</sect2>
			<sect2 id="section.property.first">
			<title>first</title>
			<para>
			
			'first' ist 'true', wenn die aktuelle Iteration die erste dieser 'section' ist.
			</para>
	<example>
	<title>'section'-Eigenschaft 'first'</title>
	<programlisting>
	{section name=customer loop=$custid}
	{if $smarty.section.customer.first}
    	&lt;table&gt;
	{/if}

	&lt;tr&gt;&lt;td&gt;{$smarty.section.customer.index} id:
        	{$custid[customer]}&lt;/td&gt;&lt;/tr&gt;

	{if $smarty.section.customer.last}
    	&lt;/table&gt;
	{/if}
	{/section}


	AUSGABE:

	&lt;table&gt;
	&lt;tr&gt;&lt;td&gt;0 id: 1000&lt;/td&gt;&lt;/tr&gt;
	&lt;tr&gt;&lt;td&gt;1 id: 1001&lt;/td&gt;&lt;/tr&gt;
	&lt;tr&gt;&lt;td&gt;2 id: 1002&lt;/td&gt;&lt;/tr&gt;
	&lt;/table&gt;
</programlisting>
	</example>
			</sect2>
			<sect2 id="section.property.last">
			<title>last</title>
			<para>
			
			'last' ist 'true' wenn die aktuelle Iteration die letzte dieser 'section' ist.
			</para>
	<example>
	<title>'section'-Eigenschaft 'last'</title>
	<programlisting>
	{section name=customer loop=$custid}
	{if $smarty.section.customer.first}
    	&lt;table&gt;
	{/if}

	&lt;tr&gt;&lt;td&gt;{$smarty.section.customer.index} id:
        	{$custid[customer]}&lt;/td&gt;&lt;/tr&gt;

	{if $smarty.section.customer.last}
    	&lt;/table&gt;
	{/if}
	{/section}


	AUSGABE:

	&lt;table&gt;
	&lt;tr&gt;&lt;td&gt;0 id: 1000&lt;/td&gt;&lt;/tr&gt;
	&lt;tr&gt;&lt;td&gt;1 id: 1001&lt;/td&gt;&lt;/tr&gt;
	&lt;tr&gt;&lt;td&gt;2 id: 1002&lt;/td&gt;&lt;/tr&gt;
	&lt;/table&gt;
</programlisting>
	</example>
			</sect2>
			<sect2 id="section.property.rownum">	
			<title>rownum</title>
			<para>
			'rownum' wird verwendet um die aktuelle Iteration (startend bei 1) auszugeben.
			'rownum' ist ein Alias f&uuml;r 'iteration' und arbeitet identisch.
			</para>
	<example>
	<title>'section'-Eigenschaft 'rownum'</title>
	<programlisting>
	{section name=customer loop=$custid}
	{$smarty.section.customer.rownum} id: {$custid[customer]}&lt;br&gt;
	{/section}


	AUSGABE:

	1 id: 1000&lt;br&gt;
	2 id: 1001&lt;br&gt;
	3 id: 1002&lt;br&gt;
</programlisting>
	</example>
			</sect2>
			<sect2 id="section.property.loop">	
			<title>loop</title>
			<para>
			'loop' wird verwendet, um die Nummer letzte Iteration der 'section' auszugeben.
                            Dieser Wert kann inner- und ausserhalb der 'section' verwendet werden.
			</para>
	<example>
	<title>'section'-Eigenschaft 'loop'</title>
	<programlisting>
	{section name=customer loop=$custid}
	{$smarty.section.customer.index} id: {$custid[customer]}&lt;br&gt;
	{/section}

	Es wurden {$smarty.section.customer.loop} Kunden angezeigt.

	AUSGABE:

	0 id: 1000&lt;br&gt;
	1 id: 1001&lt;br&gt;
	2 id: 1002&lt;br&gt;

	Es wurden 3 Kunden angezeigt.
</programlisting>
	</example>
			</sect2>
			<sect2 id="section.property.show">	
			<title>show</title>
			<para>
			<emphasis>show</emphasis> kann die Werte 'true' oder 'false' haben.
			Falls der Wert 'true' ist, wird die 'section' angezeigt. Falls
			der Wert 'false' ist, wird die 'section' - ausser dem 'sectionelse' - nicht ausgegeben.
			</para>
	<example>
	<title>'section'-Eigenschaft 'show'</title>
	<programlisting>
	{section name=customer loop=$custid show=$show_customer_info}
	{$smarty.section.customer.rownum} id: {$custid[customer]}&lt;br&gt;
	{/section}

	{if $smarty.section.customer.show}
	die 'section' wurde angezeigt
	{else}
	die 'section' wurde nicht angezeigt
	{/if}


	AUSGABE:

	1 id: 1000&lt;br&gt;
	2 id: 1001&lt;br&gt;
	3 id: 1002&lt;br&gt;

	die 'section' wurde angezeigt
</programlisting>
	</example>
			</sect2>
			<sect2 id="section.property.total">	
			<title>total</title>
			<para>
			Wird verwendet um die Anzahl der durchlaufenen Iterationen einer
			'section' auszugeben. Kann innerhalb oder ausserhalb der 'section' verwendet
			werden.
			</para>
	<example>
	<title>'section'-Eigenschaft 'total'</title>
	<programlisting>
	{section name=customer loop=$custid step=2}	
	{$smarty.section.customer.index} id: {$custid[customer]}&lt;br&gt;
	{/section}

	Es wurden {$smarty.section.customer.total} Kunden angezeigt.

	OUTPUT:

	0 id: 1000&lt;br&gt;
	2 id: 1001&lt;br&gt;
	4 id: 1002&lt;br&gt;

	Es wurden 3 Kunden angezeigt.
</programlisting>
	</example>
			</sect2>
		</sect1>
		<sect1 id="language.function.strip">
			<title>strip</title>
			<para>
			Webdesigner haben oft das Problem, dass Leerzeichen und Zeilenumbr&uuml;che
			die Ausgabe des erzeugten HTML im Browser beeinflussen. Oft werden deshalb alle
			Tags aufeinanderfolgend im Template notiert, was aber zu einer schlechten 
                            Lesbarkeit f&uuml;hrt.
			</para>
			<para>
			Aus dem Inhalt zwischen den {strip}{/strip}-Tags werden alle Leerzeichen und
			Zeilenumbr&uuml;che entfernt. So k&ouml;nnen Sie Ihre Templates lesbar
			halten, ohne sich Sorgen um die Leerzeichen zu machen.
			</para>
			<note>
			<title>Technische Bemerkung</title>
			<para>
			{strip}{/strip} &auml;ndert nicht den Inhalt einer Template-Variablen.
			Daf&uuml;r gibt es den <link linkend="language.modifier.strip">strip Modifikator</link>.
			</para>
			</note>
<example>
<title>strip tags</title>
<programlisting>

{* der folgende Inhalt wird in einer Zeile ausgegeben *}
{strip}
&lt;table border=0&gt;
	&lt;tr&gt;
		&lt;td&gt;
			&lt;A HREF="{$url}"&gt;
			&lt;font color="red"&gt;Das ist ein Test.&lt;/font&gt;
			&lt;/A&gt;
		&lt;/td&gt;
	&lt;/tr&gt;
&lt;/table&gt;
{/strip}


AUSGABE:

&lt;table border=0&gt;&lt;tr&gt;&lt;td&gt;&lt;A HREF="http://my.domain.com"&gt;&lt;font color="red"&gt;Das ist ein Test.&lt;/font&gt;&lt;/A&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</programlisting>
</example>
		<para>
		Achtung: im obigen Beispiel beginnen und enden alle Zeilen mit HTML-Tags.
		Falls Sie Abschnitte haben, die nur Text enthalten, werden diese ebenfalls 
                  zusammengeschlossen. Das kann zu unerw&uuml;nschten Resultaten f&uuml;hren.
		</para>
		</sect1>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->