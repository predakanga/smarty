<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision$ -->
 <chapter id="caching">
  <title>Caching</title>
  <para>
   Caching wird verwendet, um <link linkend="api.display">display()</link> oder
   <link linkend="api.fetch">fetch()</link> Aufrufe durch zwischenspeichern (cachen)
    der Ausgabe in einer Datei zu beschleunigen. Falls eine gecachte Version
    des Aufrufs existiert, wird diese ausgegeben, anstatt die Ausgabe neu zu generieren.
    Caching kann die Performance vor allem dann deutlich verbessern, wenn Templates
    l&auml;ngere Rechenzeit beanspruchen. Weil die Ausgabe von display() und fetch() gecached
    wird, kann ein Cache verschiedene Templates, Konfigurationsdateien usw. enthalten.
  </para>
  <para>
   Da Templates dynamisch sind ist es wichtig darauf zu achten, welche Inhalte
   f&uuml;r f&uuml;r wie lange gecached werden sollen. Wenn sich zum Beispiel die erste Seite Ihrer Website
   nur sporadisch &auml;ndert, macht es Sinn die Seite f&uuml;r eine
   Stunde oder l&auml;nger zu cachen. Wenn Sie aber eine Seite mit sich min&uuml;tlich
   erneuernden Wetterinformationen haben, macht es m&ouml;glicherweise keinen Sinn,
   die Seite &uuml;berhaupt zu cachen.
  </para>
  <sect1 id="caching.setting.up">
   <title>Caching einrichten</title>
   <para>
    Als erstes muss das Caching eingeschaltet werden. Dies erreicht man, indem
    <link linkend="variable.caching">$caching</link> auf 'true' (oder 1) gesetzt wird.
   </para>
   <example>
    <title>Caching einschalten</title>
    <programlisting>
     require('Smarty.class.php');
     $smarty = new Smarty;
     
     $smarty->caching = true;
     
     $smarty->display('index.tpl');</programlisting>
   </example>
   <para>
    Wenn Caching eingeschaltet ist, wird der Funktionsaufruf display('index.tpl')
    das Template normal rendern, zur selben Zeit jedoch auch eine Datei mit
    dem Inhalt in das <link linkend="variable.cache.dir">$cache_dir</link> schreiben
    (als gecachte Kopie). Beim n&auml;chsten Aufruf von display('index.tpl') wird die
    gecachte Kopie verwendet.
   </para>
   <note>
    <title>Technische Bemerkung</title>
    <para>
     Die im '$cache_dir' abgelegen Dateien haben einen &auml;hnlichen Namen
     wie das Template, mit dem sie erzeugt wurden. Obwohl sie eine '.php'-Endung
     aufweisen, sind sie keine ausf&uuml;hrbaren PHP-Skripte. 
     Editieren Sie diese Dateien NICHT!
    </para>
   </note>
   <para>
    Jede gecachte Seite hat eine Lebensdauer, die von <link linkend="variable.cache.lifetime">$cache_lifetime</link>
    bestimmt wird. Normalerweise betr&auml;gt der Wert 3600 Sekunden (= 1 Stunde). Nach Ablauf dieser Lebensdauer
    wird der Cache neu generiert. Sie k&ouml;nnen die Lebensdauer pro Cache bestimmen indem Sie '$caching'
    auf 2 setzen. Konsultieren Sie den Abschnitt &uuml;ber <link linkend="variable.cache.lifetime">$cache_lifetime</link>
    f&uuml;r weitere Informationen.
   </para>
   <example>
    <title>'$cache_lifetime' pro Cache einstellen</title>
    <programlisting>
     require('Smarty.class.php');
     $smarty = new Smarty;
     
     $smarty->caching = 2; // Lebensdauer ist pro Cache
     
     
     // Standardwert f&uuml;r '$cache_lifetime' auf 5 Minuten setzen
     $smarty->cache_lifetime = 300;
     $smarty->display('index.tpl');
     
     
     // '$cache_lifetime' f&uuml;r 'home.tpl' auf 1 Stunde setzen
     $smarty->cache_lifetime = 3600;
     $smarty->display('home.tpl');

     // ACHTUNG: die folgende Zuweisung an '$cache_lifetime' wird nicht funktionieren,
     // wenn '$caching' auf 2 gestellt ist. Wenn die '$cache_lifetime' f&uuml;r 'home.tpl' bereits
     // auf 1 Stunde gesetzt wurde, werden neue Werte ignoriert.
     // 'home.tpl' wird nach dieser Zuweisung immer noch eine '$cache_lifetime' von 1 Stunde haben.
     $smarty->cache_lifetime = 30; // 30 Sekunden
     $smarty->display('home.tpl');</programlisting>
   </example>
   <para>
    Wenn <link linkend="variable.compile.check">$compile_check</link> eingeschaltet ist,
    werden alle in den Cache eingeflossenen Templates und Konfigurationsdateien
    hinsichtlich ihrer letzten &auml;nderung &uuml;berpr&uuml;ft. 
    Falls eine der Dateien seit der Erzeugung des Cache ge&auml;ndert wurde,
    wird der Cache unverz&uuml;glich neu generiert. Dadurch ergibt sich ein
    geringer Mehraufwand. F&uuml;r optimale Performace sollte '$compile_check' 
    deshalb auf 'false' gesetzt werden.
   </para>
   <example>
    <title>'$compile_check' einschalten</title>
    <programlisting>
     require('Smarty.class.php');
     $smarty = new Smarty;
     
     $smarty->caching = true;
     $smarty->compile_check = true;
     
     $smarty->display('index.tpl');</programlisting>
   </example>
   <para>
    Wenn <link linkend="variable.force.compile">$force_compile</link> eingeschaltet ist,
    werden die Cache-Dateien immer neu generiert und das Caching damit wirkungslos gemacht.
    '$force_compile' wird normalerweise nur f&uuml;r die Fehlersuche verwendet. 
    Ein effizienterer Weg das Caching auszuschalten w&auml;re, 
    <link linkend="variable.caching">$caching</link> auf 'false' (oder 0) zu setzen.
   </para>
   <para>
    Mit der Funktion <link linkend="api.is.cached">is_cached()</link> kann &uuml;berpr&uuml;ft
    werden, ob von einem Template eine gecachte Version vorliegt.
    In einem Template, das zum Beispiel Daten aus einer Datenbank bezieht,
    k&ouml;nnen Sie diese Funktion verwenden, um den Prozess zu &uuml;berspringen.
   </para>
   <example>
    <title>is_cached() verwenden</title>
    <programlisting>
     require('Smarty.class.php');
     $smarty = new Smarty;
     
     $smarty->caching = true;
     
     if(!$smarty->is_cached('index.tpl')) {
     
     // kein Cache gefunden, also Variablen zuweisen
     $contents = get_database_contents();
     $smarty->assign($contents);
     }
     
     $smarty->display('index.tpl');</programlisting>
   </example>
   <para>
    Mit der <link linkend="language.function.insert">insert</link> Funktion k&ouml;nnen Sie
    Teile einer Seite dynamisch halten. Wenn zum Beispiel ein Banner in einer gecachten Seite
    nicht gecached werden soll, kann dessen Aufruf mit 'insert' dynamisch gehalten werden.
    Konsultieren Sie den Abschnitt &uuml;ber <link linkend="language.function.insert">insert</link>
    f&uuml;r weitere Informationen und Beispiele.
   </para>
   <para>
    Mit der Funktion <link linkend="api.clear.all.cache">clear_all_cache()</link> k&ouml;nnen
    Sie den gesamten Template-Cache l&ouml;schen. Mit <link linkend="api.clear.cache">clear_cache()</link>
    einzelne Templates oder Template-Gruppen.
   </para>
   <example>
    <title>Cache leeren</title>
    <programlisting>
     require('Smarty.class.php');
     $smarty = new Smarty;
     
     $smarty->caching = true;
     
     
     // alle Cache-Dateien l&ouml;schen
     $smarty->clear_all_cache();
     
     
     // nur Cache von 'index.tpl' l&ouml;schen
     $smarty->clear_cache('index.tpl');
     
     $smarty->display('index.tpl');</programlisting>
   </example>
  </sect1>
  <sect1 id="caching.multiple.caches">
   <title>Multiple Caches f&uuml;r eine Seite</title>
   <para>
    Sie k&ouml;nnen f&uuml;r Aufrufe von 'display()' oder 'fetch()' auch mehrere Caches erzeugen.
    Nehmen wir zum Beispiel an, der Aufruf von display('index.tpl') erzeuge f&uuml;r
    verschieden F&auml;lle unterschiedliche Inhalte und Sie wollen jeden dieser Inhalte
    separat cachen. Um dies zu erreichen, k&ouml;nnen Sie eine 'cache_id' beim Funktionsaufruf
    &uuml;bergeben.
   </para>
   <example>
    <title>'display()' eine 'cache_id' &uuml;bergeben</title>
    <programlisting>
     require('Smarty.class.php');
     $smarty = new Smarty;
     
     $smarty->caching = true;
     
     $my_cache_id = $_GET['article_id'];
     
     $smarty->display('index.tpl', $my_cache_id);</programlisting>
   </example>
   <para>
    Im oberen Beispiel &uuml;bergeben wir die Variable '$my_cache_id'
    als 'cache_id' an 'display()'. F&uuml;r jede einmalige 'cache_id' 
    wird ein eigener Cache von 'index.tpl' erzeugt. In diesem
    Beispiel wurde 'article_id' per URL &uuml;bergeben und als 'cache_id' verwendet.
   </para>
   <note>
    <title>Technische Bemerkung</title>
    <para>
     Seien Sie vorsichtig, wenn Sie Smarty (oder jeder anderen PHP-Applikation)
     Werte direkt vom Client (Webbrowser) &uuml;bergeben. Obwohl das Beispiel oben
     praktisch aussehen mag, kann es schwerwiegende Konsequenzen haben. Die 'cache_id'
     wird verwendet, um im Dateisystem ein Verzeichnis zu erstellen. Wenn ein Benutzer
     also &uuml;berlange Werte &uuml;bergibt oder ein Skript benutzt, das in hohem
     Tempo neue 'article_ids' &uuml;bermittelt, kann dies auf dem Server zu Problemen 
     f&uuml;hren. Stellen Sie daher sicher, dass Sie alle empfangenen Werte auf 
     ihre G&uuml;ltigkeit &uuml;berpr&uuml;fen und unerlaubte Sequenzen entfernen. 
     Sie wissen m&ouml;glicherweise, dass ihre 'article_id' nur 10 Zeichen lang sein kann, nur 
     aus alphanumerischen Zeichen bestehen darf und in der Datenbank eingetragen 
     sein muss. &uuml;berp&uuml;fen sie das!
    </para>
   </note>
   <para>
    Denken Sie daran, Aufrufen von <link linkend="api.is.cached">is_cached()</link>
    und <link linkend="api.clear.cache">clear_cache()</link> als zweiten Parameter
    die 'cache_id' zu &uuml;bergeben.
   </para>
   <example>
    <title>'is_cached()' mit 'cache_id' aufrufen</title>
    <programlisting>
     require('Smarty.class.php');
     $smarty = new Smarty;
     
     $smarty->caching = true;
     
     $my_cache_id = $_GET['article_id'];
     
     if(!$smarty->is_cached('index.tpl', $my_cache_id)) {
     
     // kein Cache gefunden, also Variablen zuweisen
     $contents = get_database_contents();
     $smarty->assign($contents);
     }
     
     $smarty->display('index.tpl', $my_cache_id);</programlisting>
   </example>
   <para>
    Sie k&ouml;nnen mit 'clear_cache()' den gesamten Cache einer bestimmten 'cache_id'
    auf einmal l&ouml;schen, wenn Sie als Parameter die 'cache_id' &uuml;bergeben.
   </para>
   <example>
    <title>Cache einer bestimmten 'cache_id' leeren</title>
    <programlisting>
     require('Smarty.class.php');
     $smarty = new Smarty;
     
     $smarty->caching = true;
     
     
     // Cache mit 'sports' als 'cache_id' l&ouml;schen
     $smarty->clear_cache(null, "sports");
     
     $smarty->display('index.tpl', "sports");</programlisting>
   </example>
   <para>
    Indem Sie allen dieselbe 'cache_id' &uuml;bergeben, lassen sich Caches gruppieren.
   </para>
  </sect1>
  <sect1 id="caching.groups">
   <title>Cache-Gruppen</title>
   <para>
    Sie k&ouml;nnen auch eine feinere Gruppierung vornehmen, indem Sie
    'cache_id'-Gruppen erzeugen. Dies erreichen Sie, indem Sie jede Cache-Untergruppe
    durch ein '|'-Zeichen (pipe) in der 'cache_id' abtrennen. Sie k&ouml;nnen so viele
    Untergruppen erstellen, wie Sie m&ouml;chten.
   </para>
   <example>
    <title>'cache_id'-Gruppen</title>
    <programlisting>
     require('Smarty.class.php');
     $smarty = new Smarty;
     
     $smarty->caching = true;
     
     
     // leere alle Caches welche 'sports|basketball' als erste zwei 'cache_id'-Gruppen enthalten
     $smarty->clear_cache(null, "sports|basketball");

     // leere alle Caches welche 'sports' als erste 'cache_id'-Gruppe haben. Dies schliesst
     // 'sports|basketball', oder 'sports|(anything)|(anything)|(anything)|...' ein
     $smarty->clear_cache(null, "sports");
     
     $smarty->display('index.tpl',"sports|basketball");</programlisting>
   </example>
   <note>
    <title>Technische Bemerkung</title>
    <para>
     Cache-Gruppierung benutzt nicht den Pfad zum Template f&uuml;r die 'cache_id'. Wenn Sie
     zum Beispiel display('themes/blue/index.tpl') aufrufen, k&ouml;nnen Sie NICHT 
     den ganzen Cache unter 'themes/blue' leeren. Wenn Sie dies tun m&ouml;chten, 
     m&uuml;ssen Sie die Caches anhand der 'cache_id' gruppieren - zum Beispiel 
     display('themes/blue/index.tpl','themes|blue');
     Danach k&ouml;nnen Sie alle Caches des 'blue-theme' mit clear_cache(null, 'themes|blue'); 
     leeren.
    </para>
   </note>
  </sect1>
  <sect1 id="caching.cacheable">
   <title>Die Ausgabe von cachebaren Plugins Kontrollieren</title>
      <para>
      Seit Smarty-2.6.0 kann bei der Registrierung angegeben werden ob ein Plugin
      cached werden soll. Der dritte Parameter f&uuml;r register_block, register_compiler_function
      und register_function heisst <parameter>$cacheable</parameter>, der Standardwert ist TRUE, was in Smarty vor
      Version 2.6.0 &uuml;blich war.
      </para>
      <para>
       Wenn ein Plugin mit $cacheable=false registriert wird, wird er bei jedem Besuch der Seite aufgerufen, selbst wenn die Site aus dem Cache stammt. Die Pluginfunktion verh&auml;lt sich ein wenig wie <link linkend="plugins.inserts">insert</link>.
      </para>
      <para>
       Im Gegensatz zu <link linkend="language.function.insert">{insert}</link> werden die Attribute standartm&auml;ssig nicht gecached. Sie k&ouml;nnen das caching jedoch mit dem vierten Parameter <parameter>$cache_attrs</parameter> kontrollieren. <parameter>$cache_attrs</parameter> ist ein Array aller Attributnamen die gecached wertden sollen.
      </para>
     <example>
     <title>Preventing a plugin's output from being cached</title>
     <programlisting>
index.php:

require('Smarty.class.php');
$smarty = new Smarty;
$smarty->caching = true;

function remaining_seconds($params, &amp;$smarty) {
    $remain = $params['endtime'] - time();
    if ($remain >=0)
        return $remain . " second(s)";
    else
        return "done";
}

$smarty->register_function('remaining', 'remaining_seconds', false, array('endtime'));

if (!$smarty->is_cached('index.tpl')) {
    // objekt $obj aus datenbank dem template zuweisen
    $smarty->assign_by_ref('obj', $obj);
}

$smarty->display('index.tpl');


index.tpl:

Time Remaining: {remain endtime=$obj->endtime}</programlisting>
    <para>
    Der Wert von $obj->endtime &auml;ndert bei jeder Anzeige der Seite, selbst wenn die Seite gecached wurde. Das Objekt $obj wird nur geladen wenn die Seite nicht gecached wurde.
    </para>
   </example>
   <example>
   <title>Verhindern dass Template Bl&ouml;cke gecached werden</title>
   <programlisting>
index.php:

require('Smarty.class.php');
$smarty = new Smarty;
$smarty->caching = true;

function smarty_block_dynamic($param, $content, &amp;$smarty) {
    return $content;
}
$smarty->register_block('dynamic', 'smarty_block_dynamic', false);

$smarty->display('index.tpl');


index.tpl:

Page created: {"0"|date_format:"%D %H:%M:%S"}

{dynamic}

Now is: {"0"|date_format:"%D %H:%M:%S"}

... do other stuff ...

{/dynamic}</programlisting>
    </example>
    <para>
Um sicherzustellen dass ein Teil eines Templates nicht gecached werden soll, kann dieser Abschnitt in einen {dynamic}...{/dynamic} Block verpackt werden.
    </para>
 </sect1>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->