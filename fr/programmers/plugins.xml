<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision$ -->
 <chapter id="plugins">
  <title>Etendre Smarty avec des plugins</title>
  <para>
  La version 2.0 a introduit l'architecture de plugin qui est
  utilisTe pour pratiquement toute les fonctionnalitTs
  personnalisables de Smarty. Ceci comprend : 
  <itemizedlist spacing="compact">
    <listitem><simpara>les fonctions</simpara></listitem>
    <listitem><simpara>les modificateurs</simpara></listitem>
    <listitem><simpara>les fonctions de blocs</simpara></listitem>
    <listitem><simpara>les fonctions de compilation</simpara></listitem>
    <listitem><simpara>les filtres de prT-compilation</simpara></listitem>
    <listitem><simpara>les filtres de post-compilation</simpara></listitem>
    <listitem><simpara>les filtres de sorties</simpara></listitem>
    <listitem><simpara>les ressources</simpara></listitem>
    <listitem><simpara>les insertions</simpara></listitem>
  </itemizedlist>
  A part pour les ressources, la compatibilitT avec les anciennes
  fatons d'enregistrer les fonctions de gestion avec l'API register_
  est conservTe. Si vous n'avez pas utilisT cette API et que vous avez
  a la place directement modifiT les variables de classes 
  <literal>$custom_funcs</literal>, <literal>$custom_mods</literal> et
  d'autres, vous devez alors modifier vos scripts pour utiliser
  l'API ou convertir vos fonctionnalitTs personnalisTes en plugins.
  </para>
     
  <sect1>
   <title>Comment fonctionnent les plugins</title>
   <para>
   Les plugins sont toujours chargTs a la demande. Seuls les modificateurs
   de variables, les ressources, etc invoquTs dans les scripts de templates
   seront chargTs. De plus, chaque plugin n'est chargT qu'une fois, et ce
   mOme si vous avez plusieurs instances de Smarty qui tournent dans
   la mOme requOte.
   </para>
   <para>
   Les filtres de post/prT-compilation et les filtres de sortie sont des cas
   un peu spTciaux.
   Comme ils ne sont pas mentionnTs dans les templates, ils doivent Otre dTclarTs
   ou chargTs explicitement via les fonctions de l'API avant que le template
   ne soit exTcutT. L'ordre dans lequel les filtres multiples d'un mOme type
   sont exTcutTs dTpend de l'ordre dans lequel ils sont enregistrTs ou chargTs.
   </para>
   <para>
   Il n'existe qu'un seul rTpertoire de plugin (pour des raisons de performances).
   Pour installer un plugin, copiez-le simplement dans le rTpertoire et Smarty
   l'utilisera automatiquement.
   </para>   
  </sect1>

   <sect1 id="plugins.naming.conventions">
    <title>Conventions de nommage</title>
    <para>
    Les fichiers et les fonctions de plugins doivent suivre une convention
    de nommage trFs spTcifique pour Otre localisTs par Smarty.
    </para>
    <para>
    Les fichiers de plugins doivent Otre nommTs de la faton suivante :
    <blockquote>
      <para>
       <filename>
        <replaceable>type</replaceable>.<replaceable>nom</replaceable>.php
       </filename>
      </para>
     </blockquote>
    </para>
    <para>
    Oú <literal>type</literal> est l'une des valeurs suivantes :
    <itemizedlist spacing="compact">
      <listitem><simpara>function</simpara></listitem>
      <listitem><simpara>modifier</simpara></listitem>
      <listitem><simpara>block</simpara></listitem>
      <listitem><simpara>compiler</simpara></listitem>
      <listitem><simpara>prefilter</simpara></listitem>
      <listitem><simpara>postfilter</simpara></listitem>
      <listitem><simpara>outputfilter</simpara></listitem>
      <listitem><simpara>resource</simpara></listitem>
      <listitem><simpara>insert</simpara></listitem>
     </itemizedlist>
    </para>
    <para>
    Et <literal>nom</literal> doit Otre un identifiant valide (lettres, nombres
    et underscore seulement).
    </para>
    <para>
    Quelques exemples : <literal>function.html_select_date.php</literal>,
    <literal>resource.db.php</literal>,
    <literal>modifier.spacify.php</literal>.
    </para>
    <para>
    Les fonctions de plugins dans les fichiers de plugins doivent Otre
    nommTes de la faton suivante :
    <blockquote>
      <para>
       <function>smarty_<replaceable>type</replaceable>_<replaceable>nom</replaceable></function>
      </para>
     </blockquote> 
    </para>
    <para>
    Les significations de <literal>type</literal> et de <literal>nom</literal> sont les mOmes
    que prTcTdemment.
    </para>
    <para>
    Smarty donnera des messages d'erreur appropriT si le fichier de plugin
    n'est pas trouvT, ou si le fichier ou la fonction de plugin ne sont
    pas nommTs correctement.
    </para>
    </sect1>

   <sect1 id="plugins.writing">
    <title>Ecrire des plugins</title>
    <para>
    Les plugins peuvent Otre soit chargTs automatiquement par Smarty
    depuis le systFme de fichier, soit Otre dTclarTs
    pendant l'exTcution via une fonction register_* de l'API. Ils peuvent
    aussi Otre dTsallouTs en utilisant une fonction unregister_* de
    l'API.
    </para>
    <para>
    Pour les plugins qui ne sont pas enregistrTs pendant l'exTcution, le nom
    des fonctions n'ont pas a suivre la convention de nommage.
    </para>
    <para>
    Si certaines fonctionnalitTs d'un plugin dTpendent d'un autre plugin
    (comme c'est le cas de certains plugins accompagnant Smarty), alors la maniFre appropriTe
    de charger le plugin est la suivante :
    </para>
    
    <programlisting>
require_once SMARTY_DIR . 'plugins/function.html_options.php';</programlisting>
    <para>
    Une rFgle gTnTrale est que chaque objet Smarty est toujours passT au plugin
    en tant que dernier paramFtre (a part pour les modificateurs).
    </para>    
   </sect1>

   <sect1 id="plugins.functions"><title>Les fonctions de templates</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>void <function>smarty_function_<replaceable>name</replaceable></function></funcdef>
      <paramdef>array <parameter>$params</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
    Tous les attributs passTs aux fonctions de template a partir du template
    sont contenus dans le tableau associatif <parameter>$params</parameter>.
    Vous pouvez accTder a ces valeurs soit directement, par exemple
    <varname>$params['start']</varname>, soit en utilisant
    <varname>extract($params)</varname> pour les importer dans la table
    des symboles.
    </para>
    <para>
    Le retour de la fonction sera substituTe a la balise de fonction
    du template (fonction <function>fetch</function> par exemple). Sinon,
    la fonction peut simplement accomplir une autre tGche sans sortie
    (la fonction <function>assign</function> par exemple)
    </para>
    <para>
    Si la fonction a besoin d'assigner des variables aux templates ou d'utiliser
    d'autres fonctionnalitTs fournies par Smarty, elle peut recevoir un
    objet <parameter>$smarty</parameter> pour cela.
    </para>
    <para>
     RTfTrez-vous aussi a :
     <link linkend="api.register.function">register_function()</link>,
     <link linkend="api.unregister.function">unregister_function()</link>.
    </para>
    <para>
     <example>
      <title>fonction de plugin avec sortie</title>
      <programlisting>
&lt;?php
/*
 * Smarty plugin
 * -------------------------------------------------------------
 * Fichier :  function.eightball.php
 * Type :     fonction
 * Nom :      eightball
 * R(le :     renvoie une phrase magique au hasard
 * -------------------------------------------------------------
 */
function smarty_function_eightball($params, &amp;$smarty)
{
    $answers = array('Yes',
                     'No',
                     'No way',
                     'Outlook not so good',
                     'Ask again soon',
                     'Maybe in your reality');

    $result = array_rand($answers);
    return $answers[$result];
}
?&gt;</programlisting>
     </example>
    </para>
    <para>
     peut Otre utilisTe dans le template de la faton suivante :
    </para>
    <programlisting>
Question: Will we ever have time travel?
Answer: {eightball}.</programlisting>
    <para>
     <example>
      <title>fonction de plugin sans sortie</title>
      <programlisting>
&lt;?php
/*
 * Smarty plugin
 * -------------------------------------------------------------
 * Fichier :  function.assign.php
 * Type :     fonction
 * Nom :      assign
 * Purpose :  assigne une valeur a une variable de template
 * -------------------------------------------------------------
 */
function smarty_function_assign($params, &amp;$smarty)
{
    extract($params);

    if (empty($var)) {
        $smarty->trigger_error("assign: missing 'var' parameter");
        return;
    }

    if (!in_array('value', array_keys($params))) {
        $smarty->trigger_error("assign: missing 'value' parameter");
        return;
    }

    $smarty->assign($var, $value);
}
?&gt;</programlisting>
     </example>
    </para>
   </sect1>

   <sect1 id="plugins.modifiers"><title>Modificateurs</title>
    <para>
    Les modificateurs sont des petites fonctions appliquTes a une variable
    de template avant qu'elle ne soit affichTe ou utilisTe dans un autre contexte.
    Les modificateurs peuvent Otre chaenTs entre eux.
    </para>
    <funcsynopsis>
     <funcprototype>
      <funcdef>mixed <function>smarty_modifier_<replaceable>name</replaceable></function></funcdef>
      <paramdef>mixed <parameter>$value</parameter></paramdef>
      <paramdef>[mixed <parameter>$param1</parameter>, ...]</paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
    Le premier paramFtre passT au modificateur est la valeur
    sur laquelle le modificateur est supposT opTrer. Les autres paramFtres
    peuvent Otre optionnels, dTpendant de quel genre d'opTration doit Otre
    effectuT.
    </para>
    <para>
    Le modificateur doit retourner le rTsultat de son exTcution.
    </para>
    <para>
    Regardez aussi
    <link linkend="api.register.modifier">register_modifier()</link>,
     <link linkend="api.unregister.modifier">unregister_modifier()</link>.
    </para>
    <example>
     <title>plugin modificateur simple</title>
     <para>
     Ce plugin est un alias d'une fonction PHP. Il n'a aucun paramFtre
     supplTmentaires.
     </para>
     <programlisting>
&lt;?php
/*
 * Smarty plugin
 * -------------------------------------------------------------
 * Fichier :  modifier.capitalize.php
 * Type :     modificateur
 * Name :     capitalize
 * R(le :     met une majuscule aux mots d'une phrase
 * -------------------------------------------------------------
 */
function smarty_modifier_capitalize($string)
{
    return ucwords($string);
}
?&gt;</programlisting>
    </example>
    <para></para>
    <example>
     <title>un plugin modificateur un peu plus complexe</title>
     <programlisting>
&lt;?php
/*
 * Smarty plugin
 * -------------------------------------------------------------
 * Fichier :  modifier.truncate.php
 * Type :     modificateur
 * Name :     truncate
 * R(le :     Tronque une chaene a une certaine longueur si
 *            nTcessaire, la coupe optionnellement au milieu
 *            d'un mot et ajoute la chaene $etc 
 * -------------------------------------------------------------
 */
function smarty_modifier_truncate($string, $length = 80, $etc = '...',
                                  $break_words = false)
{
    if ($length == 0)
        return '';

    if (strlen($string) > $length) {
        $length -= strlen($etc);
        $fragment = substr($string, 0, $length+1);
        if ($break_words)
            $fragment = substr($fragment, 0, -1);
        else
            $fragment = preg_replace('/\s+(\S+)?$/', '', $fragment);
        return $fragment.$etc;
    } else
        return $string;
}
?&gt;</programlisting>
    </example>
   </sect1>

   <sect1 id="plugins.block.functions"><title>Fonctions de blocs</title>
    <funcsynopsis>
     <funcprototype>
      <funcdef>void <function>smarty_block_<replaceable>name</replaceable></function></funcdef>
      <paramdef>array <parameter>$params</parameter></paramdef>
      <paramdef>mixed <parameter>$content</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
    Les fonctions de blocs sont des fonctions de la forme {func} .. {/func}.
    En d'autres mots, elles englobent des blocs de template et opFrent sur les
    contenus de ces blocs. Les fonctions de blocs ont la prioritT sur les
    fonctions utilisateurs de mOme nom, ce qui signifie que vous ne
    pouvez avoir une fonction utilisateur {func} et une fonction de bloc
    {func} .. {/func}.
    </para>
    <para>
    L'implTmentation de votre fonction est appelTe deux fois par Smarty :
    une fois pour la balise ouvrante et une autre fois pour la balise
    fermante.
    </para>
    <para>
    Seule la balise ouvrante d'une fonction de bloc peut avoir des attributs.
    Tous les attributs passTs par le template aux fonctions de templates sont
    contenues dans le tableau associatif <parameter>$params</parameter>.
    Vous pouvez accTder a ces valeurs soit directement, par exemple
    <varname>$params['start']</varname>, soit en utilisant
    <varname>extract($params)</varname> pour les importer dans la table
    des symboles. Votre fonction a aussi accFs aux attributs de la balise
    ouvrante quand c'est la balise fermante qui est exTcutTe.     
    </para>
    <para>
    La valeur de la variable <parameter>$content</parameter> est diffTrente
    selon si votre fonction est appelTe pour la balise ouvrante ou la
    balise fermante. Si c'est pour la balise ouvrante, elle sera a
    <literal>null</literal> et si c'est la balise fermante elle sera
    Tgale au contenu du bloc de template. Notez que le bloc de template
    aura dTja TtT exTcutT par Smarty, vous recevrez donc la sortie du
    template et non sa source.    
    </para>
    <para>
    Si vous imbriquT des fonctions de bloc, il est possible de connaetre
    la fonction de bloc parente grGce a la variable <varname>$smarty->_tag_stack</varname>.
    Faites un var_dump() dessus et la structure devrait apparaetre.
    </para>    
    <para>
     Regardez aussi :
     <link linkend="api.register.block">register_block()</link>,
     <link linkend="api.unregister.block">unregister_block()</link>.
    </para>
    <example>
     <title>fonction de bloc</title>
     <programlisting>
&lt;?php
/*
 * Smarty plugin
 * -------------------------------------------------------------
 * Fichier :  block.translate.php
 * Type :     bloc
 * Nom :      translate
 * R(le :     traduire un bloc de texte
 * -------------------------------------------------------------
 */
function smarty_block_translate($params, $content, &amp;$smarty)
{
    if ($content) {
        $lang = $params['lang'];
        // fait une traduction de $content
        echo $translation;
    }
}</programlisting>
    </example>
   </sect1>

   <sect1 id="plugins.compiler.functions"><title>Fonctions de compilation</title>
    <para>
    Les fonctions de compilation sont appelTes durant la compilation du template.
    Elles sont utiles pour injecter du code PHP ou du contenu "statique variant
    avec le temps" (bandeau de pub par ex.). Si une fonction de compilation et
    une fonction personnalisTe ont le mOme
    nom, la fonction de compilation a prioritT. 
    </para>
    <funcsynopsis>
     <funcprototype>
      <funcdef>mixed <function>smarty_compiler_<replaceable>name</replaceable></function></funcdef>
      <paramdef>string <parameter>$tag_arg</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
    Les fonctions de compilation ont deux paramFtres : une chaene contenant
    la balise - en gros, tout, depuis le nom de la fonction jusqu'au dTlimiteur de fin - et
    l'objet Smarty. Elles sont censTes retourner le code PHP qui doit Otre
    injectT dans le template compilT.
    </para>
    <para>
     Regardez aussi
     <link linkend="api.register.compiler.function">register_compiler_function()</link>,
     <link linkend="api.unregister.compiler.function">unregister_compiler_function()</link>.
    </para>
    <example>
     <title>fonction de compilation simple</title>
     <programlisting>
&lt;?php
/*
 * Smarty plugin
 * -------------------------------------------------------------
 * Fichier :   compiler.tplheader.php
 * Type :      compilation
 * Nom :       tplheader
 * R(le :      Renvoie l'en-tOte contenant le nom du fichier
 *             source et le temps de compilation.
 * -------------------------------------------------------------
 */
function smarty_compiler_tplheader($tag_arg, &amp;$smarty)
{
    return "\necho '" . $smarty-&gt;_current_file . " compiled at " . date('Y-m-d H:M'). "';";
}
?&gt;</programlisting>
     <para>
     Cette fonction peut-Otre appelT depuis le template comme suivant :
     </para>     
     <programlisting>
{* cette fonction n'est executTe que lors de la compilation *}
{tplheader}</programlisting>
     <para>
     Le code PHP rTsultant dans les templates compilTs ressemblerait a ta :
     </para>
     <programlisting>
&lt;php
echo 'index.tpl compiled at 2002-02-20 20:02';
?&gt;</programlisting>
    </example>
   </sect1>

   <sect1 id="plugins.prefilters.postfilters">
    <title>filtres de prT-compilation/filtres de post-compilation</title>
    <para>
    Les filtres de prT-compilation et les filtres de post-compilation ont des concepts trFs
    proches. Ils diffTrent dans leur exTcution, plus prTcisTment dans le
    moment oú ils sont exTcutTs.
    </para>
    <funcsynopsis>
     <funcprototype>
      <funcdef>string <function>smarty_prefilter_<replaceable>name</replaceable></function></funcdef>
      <paramdef>string <parameter>$source</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
    Les filtres de prT-compilation sont utilisTs pour transformer la source d'un template
    juste avant la compilation. Le premier paramFtre passT a la fonction
    de filtre de prT-compilation est la source du template, Tventuellement modifiTe par
    d'autres filtre de prT-compilations. Le plugin est supposT retourner la source modifiTe.
    Notez que cette source n'est sauvegardTe nulle part, elle est seulement
    utilisT pour la compilation.
    </para>
    <funcsynopsis>
     <funcprototype>
      <funcdef>string <function>smarty_postfilter_<replaceable>name</replaceable></function></funcdef>
      <paramdef>string <parameter>$compiled</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
    Les filtres de post-compilation sont utilisTs pour modifier la sortie du template
    (le code PHP) juste aprFs que la compilation a TtT faite mais juste
    avant que le template ne soit sauvegardT sur le systFme de fichiers.
    Le premier paramFtre passT a la fonction de filtre de post-compilation est le code
    du template compilT, Tventuellement dTja modifiT par d'autres filtre de post-compilations.
    Le plugin est censT retourner la version modifiT du code.
    </para>
    <example>
     <title>plugin de filtre de post-compilation</title>
     <programlisting>
&lt;?php
/*
 * Smarty plugin
 * -------------------------------------------------------------
 * Fichier :  prefilter.pre01.php
 * Type :     filtre de prT-compilation
 * Nom :      pre01
 * R(le :     Passe les balises HTML en minuscules.
 * -------------------------------------------------------------
 */
 function smarty_prefilter_pre01($source, &amp;$smarty)
 {
     return preg_replace('!&lt;(\w+)[^&gt;]+&gt;!e', 'strtolower("$1")', $source);
 }
?&gt;</programlisting>
    </example>
    <para></para>
    <example>
     <title>plugin de filtre de post-compilation</title>
     <programlisting>
&lt;?php
/*
 * Smarty plugin
 * -------------------------------------------------------------
 * Fichier :  postfilter.post01.php
 * Type:      filtre de post-compilation
 * Nom :      post01
 * R(le :     Renvoie du code qui liste toutes les variables
 *            du template.
 * -------------------------------------------------------------
 */
 function smarty_postfilter_post01($compiled, &amp;$smarty)
 {
     $compiled = "&lt;pre&gt;\n&lt;?php print_r(\$this-&gt;get_template_vars()); ?&gt;\n&lt;/pre&gt;" . $compiled;
     return $compiled;
 }
?&gt;</programlisting>
    </example>
   </sect1>

   <sect1 id="plugins.outputfilters"><title>Filtres de sortie</title>
    <para>
    Les plugins de filtres de sortie opFrent sur la sortie du template,
    aprFs que le template a TtT chargT et exTcutT, mais avant que
    la sortie ne soit affichTe.
    </para>    
    <funcsynopsis>
     <funcprototype>
      <funcdef>string <function>smarty_outputfilter_<replaceable>name</replaceable></function></funcdef>
      <paramdef>string <parameter>$template_output</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
    Le premier paramFtre passT a la fonction du filtre de sortie est la
    sortie du template qui doit Otre modifiTe et le second paramFtre
    est l'instance de Smarty appelant le plugin. Le plugin est supposT
    faire un traitement et en retourner le rTsultat.
    </para>
    <example>
     <title>plugin de filtre de sortie</title>
     <programlisting>
/*
 * Smarty plugin
 * -------------------------------------------------------------
 * Fichier :  outputfilter.protect_email.php
 * Type :     filtre de sortie
 * Nom :      protect_email
 * R(le:     Convertie les @ en %40 pour protTger des 
 *           robots spammers.
 * -------------------------------------------------------------
 */
 function smarty_outputfilter_protect_email($output, &amp;$smarty)
 {
     return preg_replace('!(\S+)@([a-zA-Z0-9\.\-]+\.([a-zA-Z]{2,3}|[0-9]{1,3}))!',
                         '$1%40$2', $output);
 }
     </programlisting>
    </example>
   </sect1>

   <sect1 id="plugins.resources"><title>Ressources</title>
    <para>
    Les plugins ressources sont un moyen gTnTrique de fournir des sources
    de templates ou des composants de scripts PHP a Smarty. Quelques exemples
    de ressources : bases de donnTes, LDAP, mTmoire partagTe, sockets, et ainsi
    de suite.
    </para>
    <para>
    Il y au total 4 fonctions qui ont besoin d'Otre enregistrTes pour
    chaque type de ressource. Chaque fonction retoit le nom de la ressource demandTe
    comme premier paramFtre et l'objet Smarty comme dernier paramFtre.
    Les autres paramFtres dTpendent de la fonction.
    </para>
    <funcsynopsis>
     <funcprototype>
      <funcdef>bool <function>smarty_resource_<replaceable>name</replaceable>_source</function></funcdef>
      <paramdef>string <parameter>$rsrc_name</parameter></paramdef>
      <paramdef>string <parameter>&amp;$source</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
     <funcprototype>
      <funcdef>bool <function>smarty_resource_<replaceable>name</replaceable>_timestamp</function></funcdef>
      <paramdef>string <parameter>$rsrc_name</parameter></paramdef>
      <paramdef>int <parameter>&amp;$timestamp</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
     <funcprototype>
      <funcdef>bool <function>smarty_resource_<replaceable>name</replaceable>_secure</function></funcdef>
      <paramdef>string <parameter>$rsrc_name</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
     <funcprototype>
      <funcdef>bool <function>smarty_resource_<replaceable>name</replaceable>_trusted</function></funcdef>
      <paramdef>string <parameter>$rsrc_name</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>

    <para>
    La premiFre fonction est supposTe rTcupTrer la ressource. Son second
    paramFtre est une variable passTe par rTfTrence oú le rTsultat doit Otre
    stockT. La fonction est supposTe retourner <literal>true</literal> si
    elle rTussi a rTcupTrer la ressource et <literal>false</literal> sinon.
    </para>

    <para>
    La seconde fonction est supposTe rTcupTrer la date de derniFre modification 
    de la ressource demandTe (comme un timestamp UNIX). Le second paramFtre
    est une variable passTe par rTfTrence dans laquelle la date doit
    Otre stockTe. La fonction est supposTe renvoyer <literal>true</literal> si elle
    a rTussi a rTcupTrer la date et <literal>false</literal> sinon.
    </para>

    <para>
    La troisiFme fonction est supposTe retourner <literal>true</literal>
    ou <literal>false</literal> selon si la ressource demandTe est svre
    ou non. La fonction est utilisTe seulement pour les ressources templates
    mais doit tout de mOme Otre dTfinie.
    </para>

    <para>
    La quatriFme fonction est supposTe retourner <literal>true</literal>
    ou <literal>false</literal> selon si on peut faire confiance ou
    non a la ressource demandTe. Cette fonction est utilisTe seulement
    pour les composants de scripts PHP demandTs par les balises
    <command>include_php</command> ou <command>insert</command>
    ayant un attribut <structfield>src</structfield>. Quoiqu'il en soit,
    elle doit Otre dTfinie pour les ressources templates.
    </para>

    <para>
     Regardez aussi
     <link linkend="api.register.resource">register_resource()</link>,
     <link linkend="api.unregister.resource">unregister_resource()</link>.
    </para>
    <example>
     <title>resource plugin</title>
     <programlisting>
&lt;?php
/*
 * Smarty plugin
 * ------------------------------------------------------------- 
 * Fichier :  resource.db.php
 * Type :     ressource
 * Nom :      db
 * R(le :     RTcupFre des templates depuis une base de donnTes
 * -------------------------------------------------------------
 */
function smarty_resource_db_source($tpl_name, &amp;$tpl_source, &amp;$smarty)
{
    // fait des requOtes BD pour rTcupTrer votre template
    // et remplir $tpl_source
    $sql = new SQL;
    $sql->query("select tpl_source
                   from my_table
                  where tpl_name='$tpl_name'");
    if ($sql->num_rows) {
        $tpl_source = $sql->record['tpl_source'];
        return true;
    } else {
        return false;
    }
}

function smarty_resource_db_timestamp($tpl_name, &amp;$tpl_timestamp, &amp;$smarty)
{
    // fait des requOtes BD pour remplir $tpl_timestamp
    $sql = new SQL;
    $sql->query("select tpl_timestamp
                   from my_table
                  where tpl_name='$tpl_name'");
    if ($sql->num_rows) {
        $tpl_timestamp = $sql->record['tpl_timestamp'];
        return true;
    } else {
        return false;
    }
}

function smarty_resource_db_secure($tpl_name, &amp;$smarty)
{
    // suppose que tous les templates sont svrs
    return true;
}

function smarty_resource_db_trusted($tpl_name, &amp;$smarty)
{
    // inutilisTe pour les templates
}
?&gt;</programlisting>
    </example>
   </sect1>

   <sect1 id="plugins.inserts"><title>Insertions</title>
    <para>
    Les plugins d'insertion sont utilisTs pour implTmenter les fonctions
    qui sont appelTes par les balises 
    <link linkend="language.function.insert"><command>insert</command></link>
    dans les templates.
    </para>
    <funcsynopsis>
     <funcprototype>
      <funcdef>string <function>smarty_insert_<replaceable>name</replaceable></function></funcdef>
      <paramdef>array <parameter>$params</parameter></paramdef>
      <paramdef>object <parameter>&amp;$smarty</parameter></paramdef>
     </funcprototype>
    </funcsynopsis>
    <para>
    Le premier paramFtre passT a la fonction est une tableau associatif
    d'attributs. Vous pouvez accTder a ces valeurs soit directement, par exemple
    <varname>$params['start']</varname>, soit en utilisant
    <varname>extract($params)</varname> pour les importer dans la table
    des symboles.
    </para>
    <para>
    La fonction d'insertion est supposTe retourner le rTsultat qui sera
    substituT a la balise <command>insert</command> dans le template.
    </para>    
    <example>
     <title>plugin d'insertion</title>
     <programlisting>
&lt;?php
/*
 * Smarty plugin
 * ------------------------------------------------------------- 
 * Fichier :  insert.time.php
 * Type :     temps
 * Nom :      time
 * R(le :     Insert la date/heure courante conformTment
 *            au format
 * -------------------------------------------------------------
 */
function smarty_insert_time($params, &amp;$smarty)
{
    if (empty($params['format'])) {
        $smarty->trigger_error("insert time: missing 'format' parameter");
        return;
    }

    $datetime = strftime($params['format']);
    return $datetime;
}
?&gt;</programlisting>
    </example>
   </sect1>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->