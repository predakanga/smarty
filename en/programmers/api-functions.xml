<?xml version="1.0" encoding="iso-8859-1"?>
<!-- $Revision$ -->
   <chapter id="api.functions">
     <title>Methods</title>
        <sect1 id="api.append">
         <title>append</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>append</function></funcdef>
           <paramdef>mixed <parameter>var</parameter></paramdef>
          </funcprototype>
          <funcprototype>
           <funcdef>void <function>append</function></funcdef>
           <paramdef>string <parameter>varname</parameter></paramdef>
           <paramdef>mixed <parameter>var</parameter></paramdef>
          </funcprototype>
          <funcprototype>
           <funcdef>void <function>append</function></funcdef>
           <paramdef>string <parameter>varname</parameter></paramdef>
           <paramdef>mixed <parameter>var</parameter></paramdef>
           <paramdef>boolean <parameter>merge</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
		  This is used to append an element to an assigned array. If you append
		  to a string value, it is converted to an array value and then
		  appended to. You can explicitly pass name/value pairs, or associative
		  arrays containing the name/value pairs. If you pass the optional third
		  parameter of true, the value will be merged with the current array
		  instead of appended.
         </para>
		 <note>
		 <title>Technical Note</title>
		 <para>
		 The merge parameter respects array keys, so if you merge two
		 numerically indexed arrays, they may overwrite each other or result in
		 non-sequential keys. This is unlike the array_merge() function of PHP
		 which wipes out numerical keys and renumbers them.
		 </para>
		 </note>
         <example>
          <title>append</title>
          <programlisting role="php">
<![CDATA[
<?php
// passing name/value pairs
$smarty->append("Name","Fred");
$smarty->append("Address",$address);

// passing an associative array
$smarty->append(array("city" => "Lincoln","state" => "Nebraska"));
?>
]]>
</programlisting>
</example>
		</sect1>
     <sect1 id="api.append.by.ref">
      <title>append_by_ref</title>
      <funcsynopsis>
       <funcprototype>
        <funcdef>void <function>append_by_ref</function></funcdef>
        <paramdef>string <parameter>varname</parameter></paramdef>
        <paramdef>mixed <parameter>var</parameter></paramdef>
       </funcprototype>
       <funcprototype>
        <funcdef>void <function>append_by_ref</function></funcdef>
        <paramdef>string <parameter>varname</parameter></paramdef>
        <paramdef>mixed <parameter>var</parameter></paramdef>
        <paramdef>boolean <parameter>merge</parameter></paramdef>
       </funcprototype>
      </funcsynopsis>
      <para>
	   This is used to append values to the templates by reference.
	   If you append a variable by reference then change its
       value, the appended value sees the change as well. For objects, 
       append_by_ref() also avoids an in-memory copy of the appended object.
       See the PHP manual on variable referencing for an in-depth
	   explanation. If you pass the optional third parameter of true,
       the value will be merged with the current array instead of appended.
      </para>
	  <note>
	  <title>Technical Note</title>
	  <para>
	  The merge parameter respects array keys, so if you merge two
	  numerically indexed arrays, they may overwrite each other or result in
	  non-sequential keys. This is unlike the array_merge() function of PHP
	  which wipes out numerical keys and renumbers them.
	  </para>
	  </note>
      <example>
       <title>append_by_ref</title>
        <programlisting role="php">
<![CDATA[
<?php
// appending name/value pairs
$smarty->append_by_ref("Name", $myname);
$smarty->append_by_ref("Address", $address);
?>
]]>
</programlisting>
</example>
		</sect1>
     <sect1 id="api.assign">
      <title>assign</title>
      <funcsynopsis>
       <funcprototype>
        <funcdef>void <function>assign</function></funcdef>
        <paramdef>mixed <parameter>var</parameter></paramdef>
       </funcprototype>
       <funcprototype>
        <funcdef>void <function>assign</function></funcdef>
        <paramdef>string <parameter>varname</parameter></paramdef>
        <paramdef>mixed <parameter>var</parameter></paramdef>
       </funcprototype>
      </funcsynopsis>
      <para>
       This is used to assign values to the templates. You can
       explicitly pass name/value pairs, or associative arrays
       containing the name/value pairs.
      </para>
      <example>
       <title>assign</title>
       <programlisting role="php">
<![CDATA[
<?php
// passing name/value pairs
$smarty->assign('Name', 'Fred');
$smarty->assign('Address', $address);

// passing an associative array
$smarty->assign(array("city" => "Lincoln", "state" => "Nebraska"));
?>
]]>
</programlisting>
</example>
		</sect1>
     <sect1 id="api.assign.by.ref">
      <title>assign_by_ref</title>
      <funcsynopsis>
       <funcprototype>
        <funcdef>void <function>assign_by_ref</function></funcdef>
        <paramdef>string <parameter>varname</parameter></paramdef>
        <paramdef>mixed <parameter>var</parameter></paramdef>
       </funcprototype>
      </funcsynopsis>
      <para>
	   This is used to assign values to the templates by reference instead of
	   making a copy. See the PHP manual on variable referencing for an explanation.
      </para>
	  <note>
	  <title>Technical Note</title>
	  <para>
	   This is used to assign values to the templates by reference.
	   If you assign a variable by reference then change its
       value, the assigned value sees the change as well. For objects, 
       assign_by_ref() also avoids an in-memory copy of the assigned object.
       See the PHP manual on variable referencing for an in-depth
	   explanation.
	  </para>
	  </note>
      <example>
       <title>assign_by_ref</title>
        <programlisting role="php">
<![CDATA[
<?php
// passing name/value pairs
$smarty->assign_by_ref('Name', $myname);
$smarty->assign_by_ref('Address', $address);
?>
]]>
</programlisting>
</example>
		</sect1>
		<sect1 id="api.clear.all.assign">
			<title>clear_all_assign</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>clear_all_assign</function></funcdef>
				<paramdef><parameter></parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
				This clears the values of all assigned variables.
			</para>
<example>
<title>clear_all_assign</title>
<programlisting role="php">
<![CDATA[
<?php
// clear all assigned variables
$smarty->clear_all_assign();
?>
]]>
</programlisting>
</example>
		</sect1>
		<sect1 id="api.clear.all.cache">
			<title>clear_all_cache</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>clear_all_cache</function></funcdef>
				<paramdef>int <parameter>expire time</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
				This clears the entire template cache. As an optional
				parameter, you can supply a minimum age in seconds the cache
				files must be before they will get cleared.
			</para>
<example>
<title>clear_all_cache</title>
<programlisting role="php">
<![CDATA[
<?php
// clear the entire cache
$smarty->clear_all_cache();
?>
]]>
</programlisting>
</example>
		</sect1>
		<sect1 id="api.clear.assign">
			<title>clear_assign</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>clear_assign</function></funcdef>
				<paramdef>string <parameter>var</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
				This clears the value of an assigned variable. This
                can be a single value, or an array of values.
			</para>
<example>
<title>clear_assign</title>
<programlisting role="php">
<![CDATA[
<?php
// clear a single variable
$smarty->clear_assign("Name");

// clear multiple variables
$smarty->clear_assign(array("Name","Address","Zip"));
?>
]]>
</programlisting>
</example>
		</sect1>
		<sect1 id="api.clear.cache">
			<title>clear_cache</title>
			<methodsynopsis>
			<type>void</type><methodname>clear_cache</methodname>
				<methodparam choice="opt"><type>string</type><parameter>template</parameter></methodparam>
				<methodparam choice="opt"><type>string</type><parameter>cache id</parameter></methodparam>
				<methodparam choice="opt"><type>string</type><parameter>compile id</parameter></methodparam>
				<methodparam choice="opt"><type>string</type><parameter>expire time</parameter></methodparam>
			</methodsynopsis>
			<para>
				This clears the cache for a specific template. If you have
				multiple caches for this template, you can clear a specific
				cache by supplying the cache id as the second parameter. You
				can also pass a compile id as a third parameter. You can "group"
				templates together so they can be removed as a group. See the
				<link linkend="caching">caching section</link> for more
				information. As an optional fourth parameter, you can supply a
				minimum age in seconds the cache file must be before it will
				get cleared.
			</para>
<example>
<title>clear_cache</title>
<programlisting role="php">
<![CDATA[
<?php
// clear the cache for a template
$smarty->clear_cache("index.tpl");

// clear the cache for a particular cache id in an multiple-cache template
$smarty->clear_cache("index.tpl","CACHEID");
?>
]]>
</programlisting>
</example>
		</sect1>
		<sect1 id="api.clear.compiled.tpl">
			<title>clear_compiled_tpl</title>
			<methodsynopsis>
			<type>void</type><methodname>clear_compiled_tpl</methodname>
				<methodparam choice="opt"><type>string</type><parameter>tpl_file</parameter></methodparam>
				<methodparam choice="opt"><type>string</type><parameter>compile_id</parameter></methodparam>
				<methodparam choice="opt"><type>string</type><parameter>exp_time</parameter></methodparam>
			</methodsynopsis>
			<para>
			This clears the compiled version of the specified template
			resource, or all compiled template files if one is not specified.
			if you pass a compile_id only the compiled template for this
			specific compile_id is cleared. if you pass an exp_time, then only
			compiled templates older than exp_time seconds are cleared, by
			default all compiled templates are cleared regardless of their age.
			This function is for advanced use only, not normally needed.
			</para>
<example>
<title>clear_compiled_tpl</title>
<programlisting role="php">
<![CDATA[
<?php
// clear a specific template resource
$smarty->clear_compiled_tpl("index.tpl");

// clear entire compile directory
$smarty->clear_compiled_tpl();
?>
]]>
</programlisting>
</example>
		</sect1>
		<sect1 id="api.clear.config">
			<title>clear_config</title>
			<methodsynopsis>
			<type>void</type><methodname>clear_config</methodname>
				<methodparam choice="opt"><type>string</type><parameter>var</parameter></methodparam>
			</methodsynopsis>
			<para>
			This clears all assigned config variables. If a variable name is
			supplied, only that variable is cleared.
			</para>
<example>
<title>clear_config</title>
<programlisting role="php">
<![CDATA[
<?php
// clear all assigned config variables.
$smarty->clear_config();

// clear one variable
$smarty->clear_config('foobar');
?>
]]>
</programlisting>
</example>
		</sect1>
		<sect1 id="api.config.load">
			<title>config_load</title>
			<methodsynopsis>
			<type>void</type><methodname>config_load</methodname>
				<methodparam><type>string</type><parameter>file</parameter></methodparam>
				<methodparam choice="opt"><type>string</type><parameter>section</parameter></methodparam>
			</methodsynopsis>
			<para>
			This loads config file data and assigns it to the template. This
			works identical to the template <link
			linkend="language.function.config.load">config_load</link>
			function.
			</para>
		  <note>
		  <title>Technical Note</title>
    	  <para>
		   As of Smarty 2.4.0, assigned template variables are kept across
		   invocations of fetch() and display(). Config vars loaded from
		   config_load() are always global scope. Config files are also
		   compiled for faster execution, and respect the <link
		   linkend="variable.force.compile">force_compile</link> and <link
		   linkend="variable.compile.check">compile_check</link> settings.
    	  </para>
		  </note>
<example>
<title>config_load</title>
<programlisting role="php">
<![CDATA[
<?php
// load config variables and assign them
$smarty->config_load('my.conf');

// load a section
$smarty->config_load('my.conf','foobar');
?>
]]>
</programlisting>
</example>
		</sect1>
		<sect1 id="api.display">
			<title>display</title>
			<methodsynopsis>
			<type>void</type><methodname>display</methodname>
				<methodparam><type>string</type><parameter>template</parameter></methodparam>
				<methodparam choice="opt"><type>string</type><parameter>cache_id</parameter></methodparam>
				<methodparam choice="opt"><type>string</type><parameter>compile_id</parameter></methodparam>
			</methodsynopsis>
			<para>
                This displays the template. Supply a valid <link
                linkend="template.resources">template resource</link>
                type and path. As an optional second parameter, you can pass a
                cache id. See the <link linkend="caching">caching
                section</link> for more information.
			</para>
			<para>
				As an optional third parameter, you can pass a compile id. This
				is in the event that you want to compile different versions of
				the same template, such as having separate templates compiled
				for different languages. Another use for compile_id is when you
				use more than one $template_dir but only one $compile_dir. Set
				a separate compile_id for each $template_dir, otherwise
				templates of the same name will overwrite each other. You can
				also set the <link
				linkend="variable.compile.id">$compile_id</link> variable once
				instead of passing this to each call to display().
			</para>
<example>
<title>display</title>
<programlisting role="php">
<![CDATA[
<?php
include("Smarty.class.php");
$smarty = new Smarty;
$smarty->caching = true;

// only do db calls if cache doesn't exist
if(!$smarty->is_cached("index.tpl"))
{

    // dummy up some data
    $address = "245 N 50th";
    $db_data = array(
	    "City" => "Lincoln",
	    "State" => "Nebraska",
	    "Zip" => "68502"
	    );

    $smarty->assign("Name","Fred");
    $smarty->assign("Address",$address);
    $smarty->assign($db_data);

}

// display the output
$smarty->display("index.tpl");
?>
]]>
</programlisting>
</example>
			<para>
			Use the syntax for <link
			linkend="template.resources">template resources</link> to
			display files outside of the $template_dir directory.
			</para>
<example>
<title>function display template resource examples</title>
<programlisting role="php">
<![CDATA[
<?php
// absolute filepath
$smarty->display("/usr/local/include/templates/header.tpl");

// absolute filepath (same thing)
$smarty->display("file:/usr/local/include/templates/header.tpl");

// windows absolute filepath (MUST use "file:" prefix)
$smarty->display("file:C:/www/pub/templates/header.tpl");

// include from template resource named "db"
$smarty->display("db:header.tpl");
?>
]]>
</programlisting>
</example>

		</sect1>
		<sect1 id="api.fetch">
			<title>fetch</title>
			<methodsynopsis>
			<type>string</type><methodname>fetch</methodname>
				<methodparam><type>string</type><parameter>template</parameter></methodparam>
				<methodparam choice="opt"><type>string</type><parameter>cache_id</parameter></methodparam>
				<methodparam choice="opt"><type>string</type><parameter>compile_id</parameter></methodparam>
			</methodsynopsis>
			<para>
                This returns the template output instead of displaying it.
                Supply a valid <link
                linkend="template.resources">template resource</link>
                type and path. As an optional second parameter, you can pass a
                cache id. See the <link linkend="caching">caching
                section</link> for more information.
			</para>
			<para>
				As an optional third parameter, you can pass a compile id. This
				is in the event that you want to compile different versions of
				the same template, such as having separate templates compiled
				for different languages. Another use for compile_id is when you
				use more than one $template_dir but only one $compile_dir. Set
				a separate compile_id for each $template_dir, otherwise
				templates of the same name will overwrite each other. You can
				also set the <link
				linkend="variable.compile.id">$compile_id</link> variable once
				instead of passing this to each call to fetch().
			</para>
<example>
<title>fetch</title>
<programlisting role="php">
<![CDATA[
<?php
include("Smarty.class.php");
$smarty = new Smarty;

$smarty->caching = true;

// only do db calls if cache doesn't exist
if(!$smarty->is_cached("index.tpl"))
{

    // dummy up some data
    $address = "245 N 50th";
    $db_data = array(
	    "City" => "Lincoln",
	    "State" => "Nebraska",
	    "Zip" => "68502"
	    );

    $smarty->assign("Name","Fred");
    $smarty->assign("Address",$address);
    $smarty->assign($db_data);

}

// capture the output
$output = $smarty->fetch("index.tpl");

// do something with $output here

echo $output;
?>
]]>
</programlisting>
</example>
		</sect1>
		<sect1 id="api.get.config.vars">
			<title>get_config_vars</title>
			<methodsynopsis>
			<type>array</type><methodname>get_config_vars</methodname>
				<methodparam choice="opt"><type>string</type><parameter>varname</parameter></methodparam>
			</methodsynopsis>
			<para>
				This returns the given loaded config variable value. If no parameter
				is given, an array of all loaded config variables is returned.
			</para>
<example>
<title>get_config_vars</title>
<programlisting role="php">
<![CDATA[
<?php
// get loaded config template var 'foo'
$foo = $smarty->get_config_vars('foo');

// get all loaded config template vars
$config_vars = $smarty->get_config_vars();

// take a look at them
print_r($config_vars);
?>
]]>
</programlisting>
</example>
		</sect1>
		<sect1 id="api.get.registered.object">
			<title>get_registered_object</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>array <function>get_registered_object</function></funcdef>
				<paramdef>string <parameter>object_name</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
				This returns a reference to a registered object. This is useful
				from within a custom function when you need direct access to a
				registered object.
			</para>
<example>
<title>get_registered_object</title>
<programlisting role="php">
<![CDATA[
<?php
function smarty_block_foo($params, &$smarty) {
	if (isset($params['object'])) {
		// get reference to registered object
   		$obj_ref = &$smarty->get_registered_object($params['object']);
		// use $obj_ref is now a reference to the object
	}
}
?>
]]>
</programlisting>
</example>
		</sect1>
		<sect1 id="api.get.template.vars">
			<title>get_template_vars</title>
			<methodsynopsis>
			<type>array</type><methodname>get_template_vars</methodname>
				<methodparam choice="opt"><type>string</type><parameter>varname</parameter></methodparam>
			</methodsynopsis>
			<para>
				This returns the given assigned variable value. If no parameter
				is given, an array of all assigned variables is returned.
			</para>
<example>
<title>get_template_vars</title>
<programlisting role="php">
<![CDATA[
<?php
// get assigned template var 'foo'
$foo = $smarty->get_template_vars('foo');

// get all assigned template vars
$tpl_vars = $smarty->get_template_vars();

// take a look at them
print_r($tpl_vars);
?>
]]>
</programlisting>
</example>
		</sect1>
		<sect1 id="api.is.cached">
			<title>is_cached</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>boolean <function>is_cached</function></funcdef>
				<paramdef>string <parameter>template</parameter></paramdef>
				<paramdef>[string <parameter>cache_id</parameter>]</paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
                This returns true if there is a valid cache for this template.
                This only works if <link
                linkend="variable.caching">caching</link> is set to true.
			</para>
<example>
<title>is_cached</title>
<programlisting role="php">
<![CDATA[
<?php
$smarty->caching = true;

if(!$smarty->is_cached("index.tpl")) {
    // do database calls, assign vars here
}

$smarty->display("index.tpl");
?>
]]>
</programlisting>
</example>
            <para>
                You can also pass a cache id as an an optional second parameter
                in case you want multiple caches for the given template.
            </para>
<example>
<title>is_cached with multiple-cache template</title>
<programlisting role="php">
<![CDATA[
<?php
$smarty->caching = true;

if(!$smarty->is_cached("index.tpl","FrontPage")) {
    // do database calls, assign vars here
}

$smarty->display("index.tpl","FrontPage");
?>
]]>
</programlisting>
</example>
</sect1>
        <sect1 id="api.load.filter">
         <title>load_filter</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>load_filter</function></funcdef>
           <paramdef>string <parameter>type</parameter></paramdef>
           <paramdef>string <parameter>name</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
          This function can be used to load a filter plugin. The first
          argument specifies the type of the filter to load and can be one
          of the following: 'pre', 'post', or 'output'. The second argument
          specifies the name of the filter plugin, for example, 'trim'.
         </para>
<example>
<title>loading filter plugins</title>
<programlisting role="php">
<![CDATA[
<?php
$smarty->load_filter('pre', 'trim'); // load prefilter named 'trim'
$smarty->load_filter('pre', 'datefooter'); // load another prefilter named 'datefooter'
$smarty->load_filter('output', 'compress'); // load output filter named 'compress'
?>
]]>
</programlisting>
</example>
        </sect1>
		<sect1 id="api.register.block">
			<title>register_block</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>register_block</function></funcdef>
				<paramdef>string <parameter>name</parameter></paramdef>
				<paramdef>mixed <parameter>impl</parameter></paramdef>
				<paramdef>bool <parameter>cacheable</parameter></paramdef>
				<paramdef>array or null <parameter>cache_attrs</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
             Use this to dynamically register block functions plugins.
             Pass in the block function name, followed by the PHP
             function callback that implements it.
			</para>

			<para>
             The php-function callback <parameter>impl</parameter> can be either (a) a string
             containing the function name or (b) an array of the form
             <literal>array(&amp;$object, $method)</literal> with
             <literal>&amp;$object</literal> being a reference to an
             object and <literal>$method</literal> being a string
             containing the mehod-name or (c) an array of the form
             <literal>array(&amp;$class, $method)</literal> with
             <literal>$class</literal> being a classname and
             <literal>$method</literal> being a class method of that
             class.
			</para>
			<para>
<parameter>$cacheable</parameter> and <parameter>$cache_attrs</parameter> can be omitted in most cases. See <link linkend="caching.cacheable">Controlling Cacheability of Plugins' Output</link> on how to use them properly.
			</para>
<example>
<title>register_block</title>
<programlisting role="php">
<![CDATA[
<?php
$smarty->register_block("translate", "do_translation");

function do_translation ($params, $content, &$smarty, &$repeat) {
    if (isset($content)) {
        $lang = $params['lang'];
        // do some translation with $content
        return $translation;
    }
}
?>

{* template *}
{translate lang="br"}
   Hello, world!
{/translate}
]]>
</programlisting>
</example>
		</sect1>
		<sect1 id="api.register.compiler.function">
			<title>register_compiler_function</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>register_compiler_function</function></funcdef>
				<paramdef>string <parameter>name</parameter></paramdef>
				<paramdef>mixed <parameter>impl</parameter></paramdef>
				<paramdef>bool <parameter>cacheable</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
                Use this to dynamically register a compiler function plugin.
                Pass in the compiler function name, followed by the PHP
                function that implements it.
			</para>
			<para>
                The php-function callback <parameter>impl</parameter> can be either (a) a string
		containing the function name or (b) an array of the form
		<literal>array(&amp;$object, $method)</literal> with
		<literal>&amp;$object</literal> being a reference to an
		object and <literal>$method</literal> being a string
		containing the mehod-name or (c) an array of the form
		<literal>array(&amp;$class, $method)</literal> with
		<literal>$class</literal> being a classname and
		<literal>$method</literal> being a class method of that
		class.
			</para>
			<para>
                <parameter>$cacheable</parameter> can be omitted in
                most cases. See <link linkend="caching.cacheable">Controlling
                Cacheability of Plugins' Output</link> on how to it properly.
			</para>
		</sect1>
		<sect1 id="api.register.function">
			<title>register_function</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>register_function</function></funcdef>
				<paramdef>string <parameter>name</parameter></paramdef>
				<paramdef>mixed <parameter>impl</parameter></paramdef>
				<paramdef>bool <parameter>cacheable</parameter></paramdef>
				<paramdef>array or null <parameter>cache_attrs</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
             Use this to dynamically register template function plugins.
             Pass in the template function name, followed by the PHP
             function name that implements it.
			</para>
			<para>
             The php-function callback <parameter>impl</parameter> can be either (a) a string
             containing the function name or (b) an array of the form
	     <literal>array(&amp;$object, $method)</literal> with
             <literal>&amp;$object</literal> being a reference to an
             object and <literal>$method</literal> being a string
             containing the mehod-name or (c) an array of the form
             <literal>array(&amp;$class, $method)</literal> with
             <literal>$class</literal> being a classname and
             <literal>$method</literal> being a class method of that
             class.
                        </para>
			<para>
<parameter>$cacheable</parameter> and <parameter>$cache_attrs</parameter> can be omitted in most cases. See <link linkend="caching.cacheable">Controlling Cacheability of Plugins' Output</link> on how to use them properly.
			</para>
<example>
<title>register_function</title>
<programlisting role="php">
<![CDATA[
<?php
$smarty->register_function("date_now", "print_current_date");

function print_current_date ($params) {
    if(empty($params['format']))
        $format = "%b %e, %Y";
    else
        $format = $params['format'];
    return strftime($format,time());
}

// now you can use this in Smarty to print the current date: {date_now}
// or, {date_now format="%Y/%m/%d"} to format it.
?>
]]>
</programlisting>
</example>
		</sect1>
		<sect1 id="api.register.modifier">
         <title>register_modifier</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>register_modifier</function></funcdef>
           <paramdef>string <parameter>name</parameter></paramdef>
           <paramdef>mixed <parameter>impl</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
          Use this to dynamically register modifier plugin. Pass in the
          template modifier name, followed by the PHP function that it
          implements it.
         </para>
         <para>
	  The php-function callback <parameter>impl</parameter> can be either (a) a string
	  containing the function name or (b) an array of the form
	  <literal>array(&amp;$object, $method)</literal> with
	  <literal>&amp;$object</literal> being a reference to an
	  object and <literal>$method</literal> being a string
	  containing the mehod-name or (c) an array of the form
	  <literal>array(&amp;$class, $method)</literal> with
	  <literal>$class</literal> being a classname and
	  <literal>$method</literal> being a class method of that
	  class.
	</para>

<example>
<title>register_modifier</title>
<programlisting role="php">
<![CDATA[
<?php
// let's map PHP's stripslashes function to a Smarty modifier.

$smarty->register_modifier("sslash","stripslashes");

// now you can use {$var|sslash} to strip slashes from variables
?>
]]>
</programlisting>
</example>
		</sect1>
		<sect1 id="api.register.object">
			<title>register_object</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>register_object</function></funcdef>
				<paramdef>string <parameter>object_name</parameter></paramdef>
				<paramdef>object <parameter>$object</parameter></paramdef>
				<paramdef>array <parameter>allowed methods/properties</parameter></paramdef>
				<paramdef>boolean <parameter>format</parameter></paramdef>
				<paramdef>array <parameter>block methods</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
            <para>
			This is to register an object for use in the templates. See the
			<link linkend="advanced.features.objects">object section</link>
			of the manual for examples.
            </para>
		</sect1>
		<sect1 id="api.register.outputfilter">
			<title>register_outputfilter</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>register_outputfilter</function></funcdef>
				<paramdef>mixed <parameter>function</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
                <para>
                 Use this to dynamically register outputfilters to operate on
                 a template's output before it is displayed. See
                 <link linkend="advanced.features.outputfilters">template output
                 filters</link>
                 for more information on how to set up an output filter function.
                </para>
                <para>
                 The php-function callback <parameter>function</parameter> can be either (a) a string
                 containing the function name or (b) an array of the form
                 <literal>array(&amp;$object, $method)</literal> with
                 <literal>&amp;$object</literal> being a reference to an
                 object and <literal>$method</literal> being a string
                 containing the mehod-name or (c) an array of the form
                 <literal>array(&amp;$class, $method)</literal> with
                 <literal>$class</literal> being a classname and
                 <literal>$method</literal> being a class method of that
                 class.
                </para>
		</sect1>
		<sect1 id="api.register.postfilter">
			<title>register_postfilter</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>register_postfilter</function></funcdef>
				<paramdef>mixed <parameter>function</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
                Use this to dynamically register postfilters to run templates
                through after they are compiled. See <link
                linkend="advanced.features.postfilters">template postfilters</link> for
                more information on how to setup a postfiltering function.
			</para>
            <para>
                The php-function callback <parameter>function</parameter> can be either (a) a string
                containing the function name or (b) an array of the form
                <literal>array(&amp;$object, $method)</literal> with
                <literal>&amp;$object</literal> being a reference to an
                object and <literal>$method</literal> being a string
                containing the mehod-name or (c) an array of the form
                <literal>array(&amp;$class, $method)</literal> with
                <literal>$class</literal> being a classname and
                <literal>$method</literal> being a class method of that
                class.
            </para>
		</sect1>
		<sect1 id="api.register.prefilter">
			<title>register_prefilter</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>register_prefilter</function></funcdef>
				<paramdef>mixed <parameter>function</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
                Use this to dynamically register prefilters to run templates
                through before they are compiled. See <link
                linkend="advanced.features.prefilters">template prefilters</link> for
                more information on how to setup a prefiltering function.
			</para>
                        <para>
                The php-function callback <parameter>function</parameter> can be either (a) a string
                containing the function name or (b) an array of the form
                <literal>array(&amp;$object, $method)</literal> with
                <literal>&amp;$object</literal> being a reference to an
                object and <literal>$method</literal> being a string
                containing the mehod-name or (c) an array of the form
                <literal>array(&amp;$class, $method)</literal> with
                <literal>$class</literal> being a classname and
                <literal>$method</literal> being a class method of that
                class.
                        </para>
		</sect1>
        <sect1 id="api.register.resource">
         <title>register_resource</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>register_resource</function></funcdef>
           <paramdef>string <parameter>name</parameter></paramdef>
           <paramdef>array <parameter>resource_funcs</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
          Use this to dynamically register a resource plugin with Smarty.
          Pass in the name of the resource and the array of PHP functions
          implementing it. See
          <link linkend="template.resources">template resources</link>
          for more information on how to setup a function for fetching
          templates.
         </para>
		 <note>
		 <title>Technical Note</title>
		 <para>
		 A resource name must be at least two characters in length. One
		 character resource names will be ignored and used as part of the file
		 path, such as $smarty->display('c:/path/to/index.tpl');
		 </para>
		 </note>
         <para>
          The php-function-array <parameter>resource_funcs</parameter>
          must have 4 or 5 elements. With 4 elements the elements are
          the functions-callbacks for the respective "source",
          "timestamp", "secure" and "trusted" functions of the
          resource. With 5 elements the first element has to be an
          object reference or a class name of the object or class
          implementing the resource and the 4 following elements have
          to be the method names implementing "source", "timestamp",
          "secure" and "trusted".
         </para>
<example>
<title>register_resource</title>
<programlisting role="php">
<![CDATA[
<?php
$smarty->register_resource("db", array("db_get_template",
                                       "db_get_timestamp",
                                       "db_get_secure",
                                       "db_get_trusted"));
?>
]]>
</programlisting>
</example>
		</sect1>
        <sect1 id="api.trigger.error">
         <title>trigger_error</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>trigger_error</function></funcdef>
           <paramdef>string <parameter>error_msg</parameter></paramdef>
           <paramdef>[int <parameter>level</parameter>]</paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
          This function can be used to output an error message using Smarty.
          <parameter>level</parameter> parameter can be one of the values
          used for trigger_error() PHP function, i.e. E_USER_NOTICE,
          E_USER_WARNING, etc. By default it's E_USER_WARNING.
         </para>
        </sect1>

        <sect1 id="api.template.exists">
         <title>template_exists</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>bool <function>template_exists</function></funcdef>
           <paramdef>string <parameter>template</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
          This function checks whether the specified template exists. It can
          accept either a path to the template on the filesystem or a
          resource string specifying the template.
         </para>
        </sect1>
        <sect1 id="api.unregister.block">
         <title>unregister_block</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>unregister_block</function></funcdef>
           <paramdef>string <parameter>name</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
          Use this to dynamically unregister block function plugin.
          Pass in the block function name.
         </para>
		</sect1>
        <sect1 id="api.unregister.compiler.function">
         <title>unregister_compiler_function</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>unregister_compiler_function</function></funcdef>
           <paramdef>string <parameter>name</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
          Use this to dynamically unregister a compiler function. Pass in
          the name of the compiler function.
         </para>
        </sect1>
		<sect1 id="api.unregister.function">
         <title>unregister_function</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>unregister_function</function></funcdef>
           <paramdef>string <parameter>name</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
          Use this to dynamically unregister template function plugin.
          Pass in the template function name.
         </para>
<example>
<title>unregister_function</title>
<programlisting role="php">
<![CDATA[
<?php
// we don't want template designers to have access to system files

$smarty->unregister_function("fetch");
?>
]]>
</programlisting>
</example>
		</sect1>
		<sect1 id="api.unregister.modifier">
         <title>unregister_modifier</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>unregister_modifier</function></funcdef>
           <paramdef>string <parameter>name</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
          Use this to dynamically unregister modifier plugin. Pass in the
          template modifier name.
         </para>
<example>
<title>unregister_modifier</title>
<programlisting role="php">
<![CDATA[
<?php
// we don't want template designers to strip tags from elements

$smarty->unregister_modifier("strip_tags");
?>
]]>
</programlisting>
</example>
		</sect1>
		<sect1 id="api.unregister.object">
			<title>unregister_object</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>unregister_object</function></funcdef>
				<paramdef>string <parameter>object_name</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
                Use this to unregister an object.
			</para>
		</sect1>
		<sect1 id="api.unregister.outputfilter">
			<title>unregister_outputfilter</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>unregister_outputfilter</function></funcdef>
				<paramdef>string <parameter>function_name</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
                Use this to dynamically unregister an output filter.
			</para>
		</sect1>
		<sect1 id="api.unregister.postfilter">
			<title>unregister_postfilter</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>unregister_postfilter</function></funcdef>
				<paramdef>string <parameter>function_name</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
                Use this to dynamically unregister a postfilter.
			</para>
		</sect1>
		<sect1 id="api.unregister.prefilter">
			<title>unregister_prefilter</title>
			<funcsynopsis>
			<funcprototype>
			<funcdef>void <function>unregister_prefilter</function></funcdef>
				<paramdef>string <parameter>function_name</parameter></paramdef>
			</funcprototype>
			</funcsynopsis>
			<para>
                Use this to dynamically unregister a prefilter.
			</para>
		</sect1>
        <sect1 id="api.unregister.resource">
         <title>unregister_resource</title>
         <funcsynopsis>
          <funcprototype>
           <funcdef>void <function>unregister_resource</function></funcdef>
           <paramdef>string <parameter>name</parameter></paramdef>
          </funcprototype>
         </funcsynopsis>
         <para>
          Use this to dynamically unregister a resource plugin. Pass in the
          name of the resource.
         </para>
<example>
<title>unregister_resource</title>
<programlisting role="php">
<![CDATA[
<?php
$smarty->unregister_resource("db");
?>
]]>
</programlisting>
</example>
		</sect1>
</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"../../../../manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
